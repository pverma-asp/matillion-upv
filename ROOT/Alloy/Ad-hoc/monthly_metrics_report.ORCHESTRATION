{"job":{"components":{"2961624":{"id":2961624,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-218,"y":-15,"width":32,"height":32,"inputConnectorIDs":[2961627],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"populate rdl.monthly_metrics_report"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"\n-- # start with account table : unique row for each account id\n-- append to user table : unique row for each user id and account id - should not be any nulls\n-- join with period data : create multiple rows for each acct id\n-- join with monthly activity table : join on acct id and period\n-- join with cross sell data table : join on acct id and period\n\n\n-- PRE-WORK\n-- STEP 1: create monthly activity table\n-- MONTHLY ACTIVITY\ndrop table if exists etl.urs_monthly_login\n;\n\ncreate table etl.urs_monthly_login as\n  (\n    SELECT\n      dta.unique_account_id,\n      (dtudd.date :: date - dta.inception_date :: date) / 30.0 :: integer AS \"period\",\n      MAX(CASE WHEN dtudd.has_web_login OR dtudd.has_ios_login OR dtudd.has_android_login\n        THEN 1\n          ELSE 0 END)                                                    AS \"has_login\"\n    FROM\n      bi.dt_accounts dta\n      INNER JOIN bi.dt_user_daily_data dtudd ON dta.user_id = dtudd.user_id\n    GROUP BY 1, 2\n  )\n;\n\ndrop table if exists etl.urs_monthly_transactions\n;\n\n\ncreate table etl.urs_monthly_transactions as\n  (\n    select\n      unique_account_id,\n      thirty_day_periods_since_inception,\n      sum(debit_card_no_pin_transactions)                                                                             as \"count_dcnopin\",\n      sum(debit_card_pin_transactions)                                                                                as \"count_dc_pin\",\n      sum(ach_deposit_count)                                                                                          as \"count_ach_dep\",\n      sum(ach_withdrawal_count)                                                                                       as \"count_ach_wd\",\n      sum(check_withdrawal_count)                                                                                     as \"count_check_wd\",\n      sum(check_deposit_count)                                                                                        as \"count_check_dep\",\n      sum(wire_deposit_count)                                                                                         as \"count_wire_dep\",\n      sum(wire_withdrawal_count)                                                                                      as \"count_wire_wd\",\n      sum(atm_deposit_count)                                                                                          as \"count_atm_dep\",\n      sum(atm_withdrawal_count)                                                                                       as \"count_atm_wd\",\n      sum(case when bill_pay_amount > 0 then 1 else 0 end)                                                            as \"bill_pay_transactions\",\n      coalesce((count_dcnopin + count_dc_pin + count_ach_dep + count_ach_wd + count_check_wd + count_check_dep +\n                count_wire_dep + count_wire_wd + count_atm_dep + count_atm_wd + bill_pay_transactions) :: integer, 0) as \"total_transactions\"\n    from bi.dt_account_period_data\n    --where unique_account_id = 'r180175'\n    group by 1, 2\n    )\n;\n\ndrop table if exists etl.urs_monthly_activity\n;\n\ncreate table etl.urs_monthly_activity as\n  (\n      select a.*, b.has_login,\n        case when (total_transactions + has_login) >0 then 1 else 0 end as \"is_active\"\n    from etl.urs_monthly_transactions a\n    left join etl.urs_monthly_login b\n    on a.unique_account_id = b.unique_account_id\n    and a.thirty_day_periods_since_inception = b.period\n  )\n;\n\n --select * from etl.urs_monthly_activity\n --;\n\n\n-- STEP 2: create cross sell table\ndrop table if exists etl.urs_cross_sell_cohort_data\n;\n\ncreate table etl.urs_cross_sell_cohort_data as\n  (\nWITH foo AS (\n  SELECT\n    dta.unique_account_id,\n    CASE WHEN dta2.inception_date::date > dta.inception_date::date\n      THEN (dta2.inception_date::date - dta.inception_date::date)/30.0::integer\n      ELSE 0\n    END AS \"period\"\n  FROM\n    bi.dt_accounts dta\n    INNER JOIN bi.dt_accounts dta2 ON dta.user_id = dta2.user_id\n), foo2 AS (\n  SELECT\n    dta.unique_account_id,\n    dtapd.thirty_day_periods_since_inception,\n    SUM(CASE WHEN foo.period <= dtapd.thirty_day_periods_since_inception THEN 1 ELSE 0 END) AS \"num_accounts\"\n  FROM\n    bi.dt_accounts dta\n    INNER JOIN foo ON dta.unique_account_id = foo.unique_account_id\n    INNER JOIN bi.dt_account_period_data dtapd ON dta.unique_account_id = dtapd.unique_account_id\n  GROUP BY 1,2\n)\nSELECT\n  unique_account_id, thirty_day_periods_since_inception, sum(num_accounts) as \"total_accounts\", (sum(num_accounts)-1) as \"cross_sell_count\"\nFROM\n  foo2\nGROUP BY 1,2\n  )\n;\n\ndrop table if exists etl.urs_accounts_users\n;\n\ncreate table etl.urs_accounts_users as\n  (\n        with my_dt_accounts as (\n        select distinct\n          dta.user_id,\n          dta.unique_account_id,\n          dta.account_type,\n          dta.inception_date,\n          dta.migration_date,\n          dta.funding_amount,\n          dta.opening_monthly_usd_fee_setting,\n          dta.termination_date,\n          dta.initial_monthly_recurring_investment_amount,\n          dta.current_monthly_recurring_investment_amount,\n          dta.is_joint_account,\n          dta.is_charged_off,  -- This comes from user provided Fraud table\n          dta.chargeoff_reason,\n          dta.total_amount_charged_off,\n          dta.is_cross_sell_account\n        from\n          bi.dt_accounts dta\n        where dta.funding_amount is not null\n      ), my_dt_users as (\n        select distinct\n          dtu.user_id,\n          dtu.zip_code,\n          dtu.state,\n          dtu.gender,\n          dtu.customer_age,\n          dtu.employment,\n          dtu.gross_income,\n          dtu.liquid_net_worth,\n          case\n          when dtu.gross_income = 0 then '$0k'\n          when dtu.gross_income <= 25000 then '<= $25k'\n          when  dtu.gross_income <= 50000 then '$25k <= $50k'\n          when dtu.gross_income <= 75000 then '$50k <= $75k'\n          when dtu.gross_income <= 100000 then '$75k <= $100k'\n          when dtu.gross_income <= 125000 then '$100k <= $125k'\n          else 'gt $125k' end as income_buckets,\n          case when dtu.liquid_net_worth = 0 then '$0k'\n          when dtu.liquid_net_worth <= 1000 then '<= $1k'\n          when dtu.liquid_net_worth <= 5000 then '$1k <= $5k'\n          when  dtu.liquid_net_worth <= 15000 then '$5k <= $15k'\n          when dtu.liquid_net_worth <= 25000 then '$15k <= $25k'\n          when dtu.liquid_net_worth <= 50000 then '$25k <= $50k'\n          when dtu.liquid_net_worth <= 100000 then '$50k <= $100k'\n          else 'gt $100k' end as liquid_net_worth_buckets\n        from\n          bi.dt_users dtu\n      )\n      select\n        dta.user_id,\n        dta.unique_account_id,\n        dta.account_type,\n        dta.inception_date,\n        to_char(dta.inception_date::date, 'yyyy-mm') as \"inception_month\",\n        to_char(dta.inception_date::date, 'yyyy-q') as \"inception_quarter\",\n        dta.migration_date,\n        dta.funding_amount,\n        dta.opening_monthly_usd_fee_setting,\n        dta.termination_date,\n        dta.initial_monthly_recurring_investment_amount,\n        dta.current_monthly_recurring_investment_amount,\n        dta.is_joint_account,\n        dta.is_charged_off,\n        dta.chargeoff_reason,\n        dta.total_amount_charged_off,\n        dta.is_cross_sell_account,\n        dtu.zip_code,\n        dtu.state,\n        dtu.gender,\n        dtu.customer_age,\n        dtu.employment,\n        dtu.gross_income,\n        dtu.liquid_net_worth,\n        case\n        when dtu.gross_income = 0 then '$0k'\n        when dtu.gross_income <= 25000 then '<= $25k'\n        when  dtu.gross_income <= 50000 then '$25k <= $50k'\n        when dtu.gross_income <= 75000 then '$50k <= $75k'\n        when dtu.gross_income <= 100000 then '$75k <= $100k'\n        when dtu.gross_income <= 125000 then '$100k <= $125k'\n        else 'gt $125k' end as income_buckets,\n        case when dtu.liquid_net_worth = 0 then '$0k'\n        when dtu.liquid_net_worth <= 1000 then '<= $1k'\n        when dtu.liquid_net_worth <= 5000 then '$1k <= $5k'\n        when  dtu.liquid_net_worth <= 15000 then '$5k <= $15k'\n        when dtu.liquid_net_worth <= 25000 then '$15k <= $25k'\n        when dtu.liquid_net_worth <= 50000 then '$25k <= $50k'\n        when dtu.liquid_net_worth <= 100000 then '$50k <= $100k'\n        else 'gt $100k' end as liquid_net_worth_buckets\n        from my_dt_accounts dta\n        inner join my_dt_users dtu\n        on dta.user_id = dtu.user_id\n--        where dta.account_type = 'Checking'\n        and dta.unique_account_id is not null\n    -- order by dta.inception_date\n      --limit 10\n  )\n;\n\n-- join to period data on unique_account_id\ndrop table if exists etl.urs_checking_cohort_table\n;\n\ncreate table etl.urs_checking_cohort_table as\n  (\n    select\n      au.*,\n      dtapd.peak_balance,\n      dtapd.average_balance,\n      dtapd.aim_scored_transactions,\n      dtapd.debit_card_pin_amount,\n      dtapd.debit_card_pin_transactions,\n      dtapd.debit_card_no_pin_amount,\n      dtapd.debit_card_no_pin_transactions,\n      dtapd.bill_pay_amount,\n      dtapd.yearly_percent_fee_setting,\n      dtapd.monthly_usd_fee_setting,\n      dtapd.ach_deposit_count,\n      dtapd.check_deposit_count,\n      dtapd.atm_deposit_count,\n      dtapd.wire_deposit_count,\n      dtapd.ach_deposit_amount,\n      dtapd.check_deposit_amount,\n      dtapd.atm_deposit_amount,\n      dtapd.wire_deposit_amount,\n      case when dtapd.is_terminated is true then 1 else 0 end as \"terminated_flag\",\n      ma.thirty_day_periods_since_inception,\n      ma.total_transactions,\n      ma.has_login,\n      ma.is_active,\n      ucs.total_accounts,\n      ucs.cross_sell_count\n    from\n      etl.urs_accounts_users au\n      inner join bi.dt_account_period_data dtapd\n        on au.unique_account_id = dtapd.unique_account_id\n      inner join etl.urs_monthly_activity ma\n        on dtapd.unique_account_id = ma.unique_account_id\n        and dtapd.thirty_day_periods_since_inception = ma.thirty_day_periods_since_inception\n      inner join etl.urs_cross_sell_cohort_data ucs\n        on dtapd.unique_account_id = ucs.unique_account_id\n        and dtapd.thirty_day_periods_since_inception = ucs.thirty_day_periods_since_inception\n  )\n;\n\n\n-- ####################################################################################################################\n--insert new month row into rdl table\ndrop table if exists tmp;\ncreate temp table tmp as\nselect (date_trunc('month', getdate()) - interval '1 month')::date as month\n;\n\ninsert into rdl.monthly_metrics_report\nselect t.month,null,null,null,null,null,null,null,null,null,null,null\nfrom tmp t\n  left join rdl.monthly_metrics_report mmr on mmr.month = t.month\nwhere mmr.month is null\n;\n\n--select * from rdl.monthly_metrics_report\n--*********************************************************************************************************************\n-- MONTHLY METRICS\n\n--new accounts\nupdate rdl.monthly_metrics_report\nset \"New Accounts\" = src.cnt\nfrom rdl.monthly_metrics_report tgt\n    join (select to_char(inception_date, 'yyyy-mm') as month, count(*) as cnt\n          from bi.dt_accounts\n          where to_char(inception_date, 'yyyy-mm') in (to_char(getdate() - 30, 'yyyy-mm'),\n                                                       to_char(getdate() - 60, 'yyyy-mm'),\n                                                       to_char(getdate() - 90, 'yyyy-mm'))\n          group by 1) src on src.month = to_char(tgt.month::date, 'yyyy-mm')\n;\n--*********************************************************************************************************************\n-- avg. summit balance on 5th\ndrop table if exists  tmp;\ncreate temp table tmp as\nwith aggregated_daily_data as (\n   select\n    dta.unique_account_id,\n    to_date(dtadd.date,'yyyy-mm') as \"month\",\n    max(dtadd.daily_balance) as \"balance\"\n  from\n    bi.dt_accounts dta\n    inner join bi.dt_account_daily_data dtadd on dta.unique_account_id = dtadd.unique_account_id\n  where\n    dta.account_type = 'Checking'\n    and to_char(dtadd.date,'dd') = '05'\n  group by 1,2\n)\nselect\n  add.month,\n  count(*),\n  avg(add.balance)\nfrom\n  bi.dt_accounts dta\n  inner join aggregated_daily_data add on dta.unique_account_id = add.unique_account_id\nwhere\n  dta.account_type = 'Checking'\n  and dta.is_ineligible_for_migration is false\n  and dta.unique_account_id not in (select unique_account_id from etl.urs_radius_transferred_accts) -- This excludes radius transferred guys for all months.\n-- Need to run this script twice to get data prior to july and after july and include the radius transferred accounts in data prior to july and exclude them after July 2018\ngroup by 1\n;\n\n--select * from tmp;\nupdate rdl.monthly_metrics_report\nset \"Average Balance Spend + Save sides\" = src.avg\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on to_char(src.month, 'yyyy-mm') = to_char(tgt.month::date, 'yyyy-mm')\nwhere to_char(src.month, 'yyyy-mm') in (to_char(getdate() - 30, 'yyyy-mm'),\n                                       to_char(getdate() - 60, 'yyyy-mm'),\n                                       to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n -- avg summit set fee on the 5th of the month\ndrop table if exists  tmp;\ncreate temp table tmp as\nselect\n  dtadd.date,\n  count(*),\n  sum(dtadd.monthly_usd_fee_setting),\n  avg(dtadd.monthly_usd_fee_setting)*12 as avg\nfrom\n  bi.dt_accounts dta\n  inner join bi.dt_account_daily_data dtadd on dta.unique_account_id = dtadd.unique_account_id\nwhere\n  dta.account_type = 'Checking'\n  and to_char(dtadd.date,'dd') = '05'\n  and (dta.termination_date is null or dta.termination_date::date > dtadd.date::date)\n  --and dta.termination_date is null\ngroup by 1\n;\n\n--select * from tmp;\nupdate rdl.monthly_metrics_report\nset \"Annualized Summit Fee\" = src.avg\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on to_char(src.date, 'yyyy-mm') = to_char(tgt.month::date, 'yyyy-mm')\nwhere to_char(src.date, 'yyyy-mm') in (to_char(getdate() - 30, 'yyyy-mm'),\n                                       to_char(getdate() - 60, 'yyyy-mm'),\n                                       to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n -- avg investment set fee on the 5th of the month\ndrop table if exists tmp;\ncreate temp table tmp as\nselect\n  dtadd.date,\n  count(*),\n  sum(dtadd.yearly_percent_fee_setting),\n  avg(dtadd.yearly_percent_fee_setting) as avg\nfrom\n  bi.dt_accounts dta\n  inner join bi.dt_account_daily_data dtadd on dta.unique_account_id = dtadd.unique_account_id\nwhere\n  dta.account_type <> 'Checking'\n  and to_char(dtadd.date,'dd') = '05'\n  and (dta.termination_date is null or dta.termination_date::date > dtadd.date::date)\n  --and dta.termination_date is null\ngroup by 1\n;\n\n--select * from tmp;\nupdate rdl.monthly_metrics_report\nset \"Annualized Investment Fee\" = src.avg\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on to_char(src.date, 'yyyy-mm') = to_char(tgt.month::date, 'yyyy-mm')\nwhere to_char(src.date, 'yyyy-mm') in (to_char(getdate() - 30, 'yyyy-mm'),\n                                       to_char(getdate() - 60, 'yyyy-mm'),\n                                       to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n-- % 90 day cross sell (only opening investment account, Save doesn't count)\ndrop table if exists tmp;\ncreate temp table tmp as\nwith total_accounts_opened as (\n  select\n    dtu.user_id,\n    min(dtu.first_account_inception_date::date) as \"first_account_inception_date\",\n    max(dtudd.opened_accounts) as \"total_accounts_opened\"\n  from\n    bi.dt_users dtu\n    inner join bi.dt_user_daily_data dtudd on dtu.user_id = dtudd.user_id\n  where\n    dtudd.date::date - dtu.first_account_inception_date::date BETWEEN 0 AND 89\n  group by 1\n)\nselect\n  to_char(first_account_inception_date::date,'yyyy-mm') as \"inception_month\",\n  sum(total_accounts_opened-1) as \"new_accounts_opened_in_90days\",\n  count(*) as \"number_people_first_incepted\",\n  \"new_accounts_opened_in_90days\" / (\"number_people_first_incepted\" * 1.0000) as \"xsell\"\nfrom\n  total_accounts_opened\nwhere\n  total_accounts_opened > 0\ngroup by 1\n;\n\n--select * from tmp;\n\nupdate rdl.monthly_metrics_report\nset \"90 day Cross-Sell\" = src.xsell\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on src.inception_month = to_char(tgt.month::date, 'yyyy-mm')\nwhere src.inception_month  in (to_char(getdate() - 30, 'yyyy-mm'),\n                                       to_char(getdate() - 60, 'yyyy-mm'),\n                                       to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n-- % 90 day churn\n-- dt tables\ndrop table if exists tmp;\ncreate temp table tmp as\nselect\n  to_char(inception_date,'yyyy-mm') as \"inception_month\",\n  sum(case when termination_date::date - inception_date::date < 90 and not is_charged_off then 1 else 0 end) as \"num_churned\",\n  count(distinct unique_account_id) as \"num_accounts\",\n  \"num_churned\" / (\"num_accounts\" * 1.0000) as \"pct_churned\"\nfrom\n  bi.dt_accounts dta\n  inner join bi.dt_users dtu on dta.user_id = dtu.user_id\n  -- where is_charged_off is not true SHOULD WE EXCLUDE THESE FROM CHURN CALCULATION?\ngroup by 1\n\n;\n--select * from tmp;\n\nupdate rdl.monthly_metrics_report\nset \"90 day Churn\" = src.pct_churned\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on src.inception_month = to_char(tgt.month::date, 'yyyy-mm')\nwhere src.inception_month in (to_char(getdate() - 30, 'yyyy-mm'),\n                             to_char(getdate() - 60, 'yyyy-mm'),\n                             to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n-- 90 day % people with 3 additional deposits\ndrop table if exists tmp;\ncreate temp table tmp as\nwith additional_deposits as (\n  select\n    dta.unique_account_id,\n    min(to_char(dta.inception_date,'yyyy-mm')) as \"inception_month\",\n    sum(dtapd.ach_deposit_count + dtapd.check_deposit_count + dtapd.atm_deposit_count + dtapd.wire_deposit_count) as \"deposits\"\n  from\n    bi.dt_accounts dta\n    inner join bi.dt_account_period_data dtapd on dta.unique_account_id = dtapd.unique_account_id\n  where\n    dtapd.thirty_day_periods_since_inception <= 2\n    and dta.account_type = 'Checking'\n  group by 1\n)\nselect\n  inception_month,\n  sum(case when deposits >= 4 then 1 else 0 end) as \"has_addtl_deposits\",\n  count(*) as \"num_accounts\",\n  \"has_addtl_deposits\" / (\"num_accounts\" * 1.0000) as \"pct_with_addtl_deposits\"\nfrom\n  additional_deposits\ngroup by 1\n\n;\n\n--select * from tmp;\n\nupdate rdl.monthly_metrics_report\nset \"90 day - Percent with 3 additional deposits\" = src.pct_with_addtl_deposits\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on src.inception_month = to_char(tgt.month::date, 'yyyy-mm')\nwhere src.inception_month in (to_char(getdate() - 30, 'yyyy-mm'),\n                             to_char(getdate() - 60, 'yyyy-mm'),\n                             to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n-- 30 day % of people that used debit card at least once\ndrop table if exists tmp;\ncreate temp table tmp as\nselect\n  to_char(dta.inception_date,'yyyy-mm') as \"inception_month\",\n  sum(case when debit_card_no_pin_transactions + debit_card_pin_transactions >= 1 then 1 else 0 end) as \"has_debit_use\",\n  count(*) as \"num_accounts\",\n  \"has_debit_use\" / (\"num_accounts\" * 1.0000) as \"pct_with_debit_use\"\nfrom\n  bi.dt_accounts dta\n  inner join bi.dt_account_period_data dtapd on dta.unique_account_id = dtapd.unique_account_id\nwhere\n  thirty_day_periods_since_inception = 0\n  and account_type = 'Checking'\n  and (galileo_save_id is null or (galileo_save_id is not null and spend_enable_date is not null))\ngroup by 1\n\n;\n--select * from tmp;\n\nupdate rdl.monthly_metrics_report\nset \"30 day - Percent with at least one debit card use\" = src.pct_with_debit_use\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on src.inception_month = to_char(tgt.month::date, 'yyyy-mm')\nwhere src.inception_month in (to_char(getdate() - 30, 'yyyy-mm'),\n                             to_char(getdate() - 60, 'yyyy-mm'),\n                             to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n-- % of people paying PWIF (should we do at account opening or do it at first 90 day or portfolio) - PULL THIS FOR NOV, DEC, JAN last year\n-- at acct opening\ndrop table if exists tmp;\ncreate temp table tmp as\nselect\n  to_char(dta.inception_date,'yyyy-mm') as \"inception_month\",\n  sum(case when opening_monthly_usd_fee_setting > 0 then 1 else 0 end) as \"num_with_pwif\",\n  count(*) as \"num_accounts\",\n  \"num_with_pwif\" / (\"num_accounts\" * 1.0000) as \"pct_with_pwif\"\nfrom\n  bi.dt_accounts dta\n  inner join bi.dt_account_period_data dtapd on dta.unique_account_id = dtapd.unique_account_id\nwhere\n  thirty_day_periods_since_inception = 0\n  and account_type = 'Checking'\ngroup by 1\n\n;\n--select * from tmp;\n\nupdate rdl.monthly_metrics_report\nset \"%PWIF at opening\" = src.pct_with_pwif\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on src.inception_month = to_char(tgt.month::date, 'yyyy-mm')\nwhere src.inception_month  in (to_char(getdate() - 30, 'yyyy-mm'),\n                             to_char(getdate() - 60, 'yyyy-mm'),\n                             to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n-- at 90 days\ndrop table if exists tmp;\ncreate temp table tmp as\nselect\n  inception_month,\n  sum(case when monthly_usd_fee_setting > 0 then 1 else 0 end) as \"num_with_pwif\",\n  count(*) as \"num_accounts\",\n  \"num_with_pwif\" / (\"num_accounts\" * 1.0000) as \"pct_with_pwif\"\nfrom\n  etl.urs_checking_cohort_table\nwhere\n  thirty_day_periods_since_inception = 2\n  and account_type = 'Checking'\ngroup by 1\n\n;\n--select * from tmp;\n\nupdate rdl.monthly_metrics_report\nset \"%PWIF at 90 days\" = src.pct_with_pwif\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on src.inception_month = to_char(tgt.month::date, 'yyyy-mm')\nwhere src.inception_month in (to_char(getdate() - 30, 'yyyy-mm'),\n                             to_char(getdate() - 60, 'yyyy-mm'),\n                             to_char(getdate() - 90, 'yyyy-mm'))\n;\n--*********************************************************************************************************************\n\n-- monthly active users\ndrop table if exists tmp;\ncreate temp table tmp as\nwith monthly_active_users as (\n  select\n    dta.unique_account_id,\n    to_char(dtadd.date::date,'yyyy-mm') as \"month\",\n    bool_or(case when dtudd.has_android_login or dtudd.has_ios_login or dtudd.has_web_login then true else false end) as \"has_login\",\n    bool_or(case when dtadd.atm_deposit_count + dtadd.wire_deposit_count + dtadd.check_deposit_count + dtadd.ach_deposit_count + dtadd.dbt_card_pin_count + dtadd.dbt_card_no_pin_count +\n              dtadd.atm_withdrawal_count + dtadd.wire_withdrawal_count + dtadd.check_withdrawal_count + dtadd.ach_withdrawal_count + dtadd.daily_bill_pay_count > 0 then true else false end) as \"has_trxn\"\n  from\n    bi.dt_users dtu\n    inner join bi.dt_user_daily_data dtudd on dtu.user_id = dtudd.user_id\n    inner join bi.dt_accounts dta on dtu.user_id = dta.user_id\n      and dta.account_type = 'Checking'\n      and termination_date is  null\n    inner join bi.dt_account_daily_data dtadd on dta.unique_account_id = dtadd.unique_account_id\n      and dtudd.date::date = dtadd.date::date\n  group by 1,2\n)\nselect\n  month,\n  sum(case when has_login or has_trxn then 1 else 0 end) as \"num_active\",\n  count(*) as \"num_accounts\",\n  \"num_active\" / (\"num_accounts\" * 1.0000) as \"pct_active\"\nfrom\n  monthly_active_users\ngroup by 1\n\n;\n\n--select * from tmp;\n\nupdate rdl.monthly_metrics_report\nset \"% Monthly Active Users\" = src.pct_active\nfrom rdl.monthly_metrics_report tgt\n    join tmp src on src.month = to_char(tgt.month::date, 'yyyy-mm')\nwhere src.month in (to_char(getdate() - 30, 'yyyy-mm'),\n                             to_char(getdate() - 60, 'yyyy-mm'),\n                             to_char(getdate() - 90, 'yyyy-mm'))\n;\n\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"2961625":{"id":2961625,"inputCardinality":"ZERO","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":444132438,"x":-400,"y":-16,"width":32,"height":32,"inputConnectorIDs":[],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[2961627],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Start 0"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]}},"successConnectors":{},"failureConnectors":{},"unconditionalConnectors":{"2961627":{"id":2961627,"sourceID":2961625,"targetID":2961624}},"trueConnectors":{},"falseConnectors":{},"iterationConnectors":{},"noteConnectors":{},"notes":{},"variables":{"table_schema":{"definition":{"name":"table_schema","type":"TEXT","scope":"TASKBATCH","description":"","visibility":"PUBLIC"},"value":"rdl"}},"grids":{}},"info":{"name":"monthly_metrics_report","description":null,"type":"ORCHESTRATION","tag":"dbe48f6c-408d-4854-8d5b-f7d6210c391b"}}