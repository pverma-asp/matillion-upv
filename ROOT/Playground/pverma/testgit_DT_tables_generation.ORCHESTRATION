{"job":{"components":{"3022951":{"id":3022951,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-560,"y":-64,"width":32,"height":32,"inputConnectorIDs":[3023042],"outputSuccessConnectorIDs":[3023039],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_users"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\nUSE WAREHOUSE ${WH_ETL};\nUSE DATABASE ${DB_ADW};\n\n--table for column cma_initiated_funding_date\ndrop table if exists etl.cma_initiated_funding_date;\ncreate table etl.cma_initiated_funding_date as\nwith accounts as (\n    select distinct USER_ID, JOINT_ACCOUNT_SECONDARY_USER_ID\n    from bi_new.DT_ACCOUNTS\n    where ACCOUNT_TYPE = 'Checking'\n    and INCEPTION_DATE is not null\n)\n, application as (\n    select USER_ID, FUNDING_AMOUNT, USER_BANK_ACCOUNT_ID, STRIPE_FUNDING_AMOUNT,\n           row_number() over (partition by USER_ID order by DATE_CREATED nulls last) as rn\n    from WEB_DB.USER_PRODUCT_APPLICATION\n    where PRODUCT_ID in (3,4,5)\n    and (STATUS = 4 or USER_ID in (select a.USER_ID from accounts a))\n)\n, stripe_with_application as (\n    --there are users with more than one verified stripe account\n    --we need the earliest one that matches their stripe funding amount\n    select a.USER_ID,\n           a.PAYMENT_ACCOUNT_LINKED_DATE,\n           c.AMOUNT/100 as stripe_amount_charged,\n           row_number() over (partition by a.USER_ID order by a.PAYMENT_ACCOUNT_LINKED_DATE nulls last) as rn\n    from bi_new.DT_BANKS a\n    join application b on a.USER_ID = b.USER_ID\n    join BANK_DB.STRIPE_LEDGER c on a.STRIPE_PAYMENT_METHOD_ID = c.PAYMENT_METHOD_ID\n    where a.VERIFICATION_TYPE = 'Stripe'\n    and a.IS_VERIFIED = true\n    and b.STRIPE_FUNDING_AMOUNT > 0\n    and b.STRIPE_FUNDING_AMOUNT = stripe_amount_charged\n    and b.rn = 1\n) \n, ach_with_application as (\n    select a.USER_ID,\n           a.PAYMENT_ACCOUNT_LINKED_DATE\n    from bi_new.DT_BANKS a\n    join application b on a.USER_ID = b.USER_ID\n                       and a.USER_PAYMENT_ACCOUNT_ID = b.USER_BANK_ACCOUNT_ID\n    where a.IS_VERIFIED = true\n    and b.FUNDING_AMOUNT > 0\n    and b.rn = 1\n) \n, no_application_funding as (\n    --DSA business rule where for using ACH and Stripe data for cma_initiated_funding_date:\n    ----look for first deposit transfer (regardless of status)\n    ----look for earliest stripe funding in dt depository transactions where description = ‘Aspiration account debit card funding’\n    ----compare a vs b and pick earliest (transfer date vs transaction date)\n    ----find the associated bank account and use bank account link date\n    select USER_ID,\n           PAYMENT_ACCOUNT_LINKED_DATE,\n           transaction_type,\n           row_number() over (partition by USER_ID\n                              order by evaluation_date nulls last, PAYMENT_ACCOUNT_LINKED_DATE nulls last) as rn\n    from (\n             --ach transfer - no funding indicated on application\n             select b.USER_ID,\n                    'ach' as transaction_type,\n                    convert_timezone('America/Los_Angeles', 'UTC', b.TRANSACTION_DATE::timestamp) as evaluation_date,\n                    c.PAYMENT_ACCOUNT_LINKED_DATE\n             from application a\n             --join rdl.ACH_GALILEO_DETAIL b on a.USER_ID = b.USER_ID\n             join bi_new.DT_TRANSFERS b on a.USER_ID = b.USER_ID\n             join bi_new.DT_BANKS c on b.USER_PAYMENT_ACCOUNT_ID = c.USER_PAYMENT_ACCOUNT_ID\n             --where b.TYPE = 'Deposit'\n             where b.TRANSFER_TYPE = 'Buy/Deposit'\n             and b.CATEGORY = 'ACH transfer'\n             and UNIQUE_ACCOUNT_ID != 'g211666' --DEPOSITORY_ID = 211666; exclude micro-deposits\n             union\n             --stripe - no funding indicated on application\n             select b.USER_ID,\n                    'stripe' as transaction_type,\n                    a.TRANSACTION_DATE::timestamp as evaluation_date,\n                    c.PAYMENT_ACCOUNT_LINKED_DATE::timestamp as PAYMENT_ACCOUNT_LINKED_DATE\n             from bi_new.DT_DEPOSITORY_TRANSACTIONS a\n             join bi_new.DT_ACCOUNTS b on a.UNIQUE_ACCOUNT_ID = b.UNIQUE_ACCOUNT_ID\n             join application d on b.USER_ID = d.USER_ID\n             join WEB_DB.GALILEO_POSTED_TRANSACTION gpt on a.POSTED_TRANSACTION_ID = gpt.POSTED_TRANSACTION_ID\n             join BANK_DB.STRIPE_LEDGER sl on gpt.EXTERNAL_TRANSACTION_ID = sl.ID\n             join bi_new.DT_BANKS c on sl.PAYMENT_METHOD_ID = c.STRIPE_PAYMENT_METHOD_ID\n             where a.DESCRIPTION = 'Aspiration account debit card funding'\n         )\n) \n, users as (\n    select a.USER_ID,\n           acct.USER_ID as primary_user_id,\n           a.FUNDING_AMOUNT,\n           a.STRIPE_FUNDING_AMOUNT,\n           ach.PAYMENT_ACCOUNT_LINKED_DATE as ach_link_date,\n           stripe.PAYMENT_ACCOUNT_LINKED_DATE as stripe_link_date,\n           no_app.PAYMENT_ACCOUNT_LINKED_DATE as transaction_link_date,\n           no_app.transaction_type,\n           nullif(least(ifnull(ach.PAYMENT_ACCOUNT_LINKED_DATE,'3000-01-01'),\n                        ifnull(stripe.PAYMENT_ACCOUNT_LINKED_DATE,'3000-01-01'),\n                        ifnull(no_app.PAYMENT_ACCOUNT_LINKED_DATE,'3000-01-01')\n                        )\n                 ,'3000-01-01') as cma_initiated_funding_date\n    from application a\n    left join accounts acct on a.USER_ID = acct.JOINT_ACCOUNT_SECONDARY_USER_ID\n    left join ach_with_application ach on a.USER_ID = ach.USER_ID\n    left join stripe_with_application stripe on a.USER_ID = stripe.USER_ID and stripe.rn = 1\n    left join no_application_funding no_app on a.USER_ID = no_app.USER_ID and no_app.rn = 1\n    where a.rn = 1\n)\nselect u.user_id,\n       IFF(u.primary_user_id is null,u.FUNDING_AMOUNT,primary.FUNDING_AMOUNT) as FUNDING_AMOUNT,\n       IFF(u.primary_user_id is null,u.STRIPE_FUNDING_AMOUNT,primary.STRIPE_FUNDING_AMOUNT) as STRIPE_FUNDING_AMOUNT,\n       IFF(u.primary_user_id is null,u.ach_link_date,primary.ach_link_date) as ach_link_date,\n       IFF(u.primary_user_id is null,u.stripe_link_date,primary.stripe_link_date) as stripe_link_date,\n       IFF(u.primary_user_id is null,u.transaction_link_date,primary.transaction_link_date) as transaction_link_date,\n       IFF(u.primary_user_id is null,u.transaction_type,primary.transaction_type) as transaction_type,\n       IFF(u.primary_user_id is null,u.cma_initiated_funding_date,primary.cma_initiated_funding_date) as cma_initiated_funding_date\nfrom users u\nleft join users primary on u.primary_user_id = primary.user_id;\n\n\n--3 temp tables below are used to extract segment url data\ndrop table if exists tmp_segment_lead;\ncreate temp table tmp_segment_lead as\nwith seg as (\n    select\n           --nullif(trim(user_id), '') as user_id,\n           email,\n           nullif(trim(context_campaign_source),'') as context_campaign_source,\n           nullif(trim(context_campaign_medium),'') as context_campaign_medium,\n           nullif(trim(context_campaign_term),'') as context_campaign_term,\n           nullif(trim(context_campaign_content),'') as context_campaign_content,\n           nullif(trim(context_campaign_name),'') as context_campaign_name,\n           case when context_page_search like '%click_id%'\n                then context_page_search\n                else null end as context_page_search,\n           case when context_page_referrer like '%click_id%'\n                then context_page_referrer\n                else null end as context_page_referrer,\n           received_at,\n           row_number() over (partition by email order by received_at nulls last) as rn\n    from segment_events.prod_segment_js.email_lead_submitted\n    where (context_page_search like '%click_id%'\n             or context_page_referrer like '%click_id%')\n      and nullif(trim(email), '') is not null\n)\nselect *,\n       nvl(context_page_referrer, context_page_search) as url\nfrom seg\nwhere rn = 1;\n\ndrop table if exists tmp_segment_pages;\ncreate temp table tmp_segment_pages as\nwith email as (\n    select\n        user_id,\n        email,\n        row_number() over (partition by user_id order by date_created desc nulls last) as rn\n    from web_db.user_email\n    where is_primary = true\n),\nseg as (\n    select\n           u.id as user_id,\n           e.email,\n           nullif(trim(p.context_campaign_source),'') as context_campaign_source,\n           nullif(trim(p.context_campaign_medium),'') as context_campaign_medium,\n           nullif(trim(p.context_campaign_term),'') as context_campaign_term,\n           nullif(trim(p.context_campaign_content),'') as context_campaign_content,\n           nullif(trim(p.context_campaign_name),'') as context_campaign_name,\n           case when p.context_page_search like '%click_id%'\n                then p.context_page_search\n                else null end as context_page_search,\n           case when p.context_page_referrer like '%click_id%'\n                then p.context_page_referrer\n                else null end as context_page_referrer,\n           p.received_at,\n           row_number() over (partition by p.user_id order by p.received_at nulls last) as rn\n    from segment_events.prod_segment_js.pages p\n    join web_db._user u on p.user_id = u.uuid\n    join email e on u.id = e.user_id and e.rn = 1\n    where (p.context_page_search like '%click_id%'\n             or p.context_page_referrer like '%click_id%')\n)\nselect *,\n       nvl(context_page_referrer, context_page_search) as url\nfrom seg\nwhere rn = 1;\n\ndrop table if exists etl.segment_url;\ncreate table etl.segment_url as\nwith combined as (\n    select email, received_at, url, context_campaign_source, context_campaign_name,\n           context_campaign_medium, context_campaign_term, context_campaign_content\n    from tmp_segment_lead\n    union\n    select email, received_at, url, context_campaign_source, context_campaign_name,\n           context_campaign_medium, context_campaign_term, context_campaign_content\n    from tmp_segment_pages\n    ),\ncombined_rn as (\n    select *,\n           row_number() over (partition by email order by received_at asc nulls last) as rn\n    from combined\n)\nselect *\nfrom combined_rn\nwhere rn = 1;\n\n--table for all the users, to remove duplicates\ndrop table if exists etl.user_list;\ncreate table etl.user_list as\nwith user_email as (\n    select USER_ID, lower(EMAIL) as email, IS_VALIDATED,\n           row_number() over (partition by user_id order by is_primary desc,\n                                                             last_updated desc) as rn\n    from web_db.user_email\n)\n, wait_list as (\n    select\n        wl.id,\n        wl.email,\n        wl.ACCOUNT_TYPE_ID,\n        wl.PRODUCT_ID,\n        wl.date_created,\n        wl.utm_content,\n        wl.utm_campaign,\n        wl.utm_medium,\n        wl.utm_source,\n        wl.utm_term,\n        wl.initial_url,\n        wl.referral_url,\n        lower(nullif(trim(split_part(CASE WHEN right(wl.referral_domain,1) = '.'\n                                          THEN left(wl.referral_domain,length(wl.referral_domain) - 1)\n                                          ELSE wl.referral_domain\n                                     END,':',1)),'')) AS referral_domain_clean\n    from web_db.wait_list_user wl\n    union all\n    select\n        pwl.id,\n        pwl.email,\n        pwl.ACCOUNT_TYPE_ID,\n        pwl.PRODUCT_ID,\n        pwl.date_created,\n        pwl.utm_content,\n        pwl.utm_campaign,\n        pwl.utm_medium,\n        pwl.utm_source,\n        pwl.utm_term,\n        pwl.initial_url,\n        pwl.referral_url,\n        lower(nullif(trim(split_part(CASE WHEN right(pwl.referral_domain,1) = '.'\n                                          THEN left(pwl.referral_domain,length(pwl.referral_domain) - 1)\n                                          ELSE pwl.referral_domain\n                                     END,':',1)),'')) AS referral_domain_clean\n    from web_db.PRODUCT_WAITLIST pwl\n    )\n    , wait_list_ranked as (\n        select  wl.id as wait_list_id,\n                lower(wl.email) as email,\n                wl.ACCOUNT_TYPE_ID,\n                wl.PRODUCT_ID,\n                wl.date_created as wl_date_created,\n                wl.utm_content,\n                wl.utm_campaign,\n                wl.utm_medium,\n                wl.utm_source,\n                wl.utm_term,\n                nvl(nullif(trim(wl.initial_url),''),su.url) as initial_url,\n                wl.referral_url,\n                CASE WHEN wl.referral_domain_clean IS NULL THEN 'direct'\n                            --when all numbers or there = no period, keep as is\n                     WHEN try_to_numeric(regexp_replace(wl.referral_domain_clean,'[.]','')) is not null OR\n                          charindex('.',wl.referral_domain_clean) = 0 THEN wl.referral_domain_clean\n                     ELSE\n                        --handle two-part (.com.uk) versus one-part (.com) top level domain\n                        CASE WHEN left(reverse(left(reverse(wl.referral_domain_clean),6)),4) IN\n                                  ('.co.','com.') AND wl.referral_domain_clean ILIKE '%.co%'\n                             THEN reverse(split_part(reverse(wl.referral_domain_clean),'.',3))\n                             ELSE reverse(split_part(reverse(wl.referral_domain_clean),'.',2))\n                        END\n                     END AS referral_domain_clean,\n                --prioritizing non-credit; dt_credit_users script will prioritize credit leads later\n                row_number() over (partition by wl.EMAIL order by wl.PRODUCT_ID nulls first, wl.DATE_CREATED) as rn\n        from wait_list wl\n        left join etl.segment_url su on wl.email = su.email\n                                    and wl.date_created::date = su.received_at::date\n                                    and ifnull(nullif(trim(wl.utm_campaign),''),'99999') = ifnull(su.context_campaign_name,'99999')\n                                    and ifnull(nullif(trim(wl.utm_source),''),'99999') = ifnull(su.context_campaign_source,'99999')\n    )\n, cte_waitlist as (\n    select * from wait_list_ranked where rn = 1\n)\n, has_account as (\n    select a.USER_ID\n    from WEB_DB.USER_ACCOUNT a\n    join WEB_DB.DEPOSITORY b on a.ACCOUNT_ID = b.ACCOUNT_ID\n    where INCEPTION_DATE is not null\n    union\n    select a.USER_ID\n    from WEB_DB.USER_ACCOUNT a\n    join WEB_DB.INVESTMENT b on a.ACCOUNT_ID = b.ACCOUNT_ID\n    where INCEPTION_DATE is not null\n    union\n    select CREDIT_USERS.USER_ID\n    from CREDIT_ACCOUNT_MANAGEMENT.CREDIT_USERS\n)\n, has_applied as (\n    select USER_ID\n    from WEB_DB.USER_PRODUCT_APPLICATION\n    group by 1\n)\n, incomplete_user_records as (\n    --These are records with no user profile or email attached that have\n    --a display_name that matches to an email of another _user record.\n    --It is likely that they are bad login attempts or did not complete\n    --the sign-up process. They are the source of records in dt_users that\n    --have a user_id, but no email.\n    --Note: only looking at display_names that are emails, because those should be unique\n    select u_incomplete.id as user_id\n    from WEB_DB._USER u\n    join WEB_DB.USER_EMAIL ue on u.ID = ue.USER_ID\n    left join WEB_DB._USER u_incomplete on ue.EMAIL = lower(u_incomplete.DISPLAY_NAME)\n    left join WEB_DB.USER_PROFILE up on u_incomplete.id = up.USER_ID\n    left join WEB_DB.USER_EMAIL e on u_incomplete.id = e.USER_ID\n    left join WEB_DB.USER_SIGNUP us on u_incomplete.id = us.INVITED_USER_ID\n    where u.id != u_incomplete.id\n    and u_incomplete.DISPLAY_NAME like '%@%'\n    and up.USER_ID is null\n    and e.USER_ID is null\n    and us.INVITED_USER_ID is null\n    union\n    --same principle as above - but matching via a user_invitation record\n    select u_incomplete.id as user_id\n    from WEB_DB._USER u_incomplete\n    join WEB_DB.USER_INVITATION ui on lower(u_incomplete.DISPLAY_NAME) = lower(ui.EMAIL)\n    left join WEB_DB.USER_PROFILE up on u_incomplete.id = up.USER_ID\n    left join WEB_DB.USER_EMAIL e on u_incomplete.id = e.USER_ID\n    left join WEB_DB.USER_SIGNUP us on u_incomplete.id = us.INVITED_USER_ID\n    where u_incomplete.DISPLAY_NAME like '%@%'\n    and up.USER_ID is null\n    and e.USER_ID is null\n    and (us.INVITED_USER_ID is null or us.USER_INVITATION_ID is null)\n) \n, user_id_records as (\n    select\n          u.id as user_id\n        , u.UUID\n        , u.DATE_CREATED as user_created\n        , ui.code as user_invitation_code\n        , wl.wl_date_created as date_created_waitlist\n        , us.DATE_CREATED as date_created_user_sign_up\n        , ui.DATE_CREATED as date_created_user_invitation\n        , lower(coalesce(ue.email,ui.email,wl.email)) AS user_email\n        , lower(coalesce(ui.email,wl.email)) as user_email_ui_wl\n        , ui.id AS user_invitation_id\n        , ui.INVITING_USER_ID as INVITING_USER_ID_UI\n        , us.ID as user_sign_up_id\n        , us.INVITING_USER_ID as INVITING_USER_ID_US\n        , wl.*\n        , case when app.USER_ID is not null then true else false end as has_applied\n        , case when acc.USER_ID is not null then true else false end as has_account\n        , case when up.USER_ID is not null then true else false end as has_profile\n        , u.ENABLED\n        , u.IS_IDENTITY_VERIFIED\n        , u.LAST_LOGIN\n        , ue.IS_VALIDATED\n        , row_number() over (partition by ifnull(user_email, u.id::varchar(50))\n                                 order by has_account desc nulls last,\n                                          has_applied desc nulls last,\n                                          has_profile desc nulls last,\n                                          u.ENABLED desc nulls last,\n                                          u.LAST_LOGIN desc nulls last,\n                                          u.IS_IDENTITY_VERIFIED desc nulls last,\n                                          ue.IS_VALIDATED desc nulls last) as rn_user_id\n        --row count below is used to remove repeating display names just within the no user_email group\n        , case when user_email is not null then 1\n               else row_number() over (partition by lower(u.DISPLAY_NAME), user_email\n                                           order by us.DATE_CREATED nulls last,\n                                                    u.DATE_CREATED)\n          end as rn_display\n        , u.DISPLAY_NAME\n    FROM web_db._user u\n    LEFT JOIN web_db.user_signup us ON u.id = us.invited_user_id\n    LEFT JOIN user_email ue ON u.id = ue.user_id AND ue.rn = 1\n    LEFT JOIN user_email ue2 ON u.id = ue2.user_id AND ue.rn = 2\n    LEFT JOIN web_db.user_invitation ui ON us.user_invitation_id = ui.id\n    --Sometimes there is no user_invitation_id value in user_signup, so in\n    --order to not miss the opportunity to get a match to wait list data,\n    --the coalesce below is used to match to it from other sources.\n    LEFT JOIN cte_waitlist wl ON wl.email = coalesce(lower(ui.email),ue.email,ue2.email)\n    left join has_account acc on u.id = acc.USER_ID\n    left join has_applied app on u.id = app.USER_ID\n    left join WEB_DB.USER_PROFILE up on u.id = up.USER_ID\n    where u.ID not in (select USER_ID from incomplete_user_records)\n) \n, user_id_email_list as (\n    --this is used to make sure that alternate emails are not inserted\n    --for the same person in the non_user_id_records cte\n    select user_email as email_user_id\n    from user_id_records\n    where user_email is not null\n    union\n    select user_email_ui_wl as email_user_id\n    from user_id_records\n    where user_email_ui_wl is not null\n) \n, non_user_id_records as (\n    select\n          null as user_id\n        , null as uuid\n        , null as user_created\n        , ui.code as user_invitation_code\n        , wl.wl_date_created as date_created_waitlist\n        , null as date_created_user_sign_up\n        , ui.DATE_CREATED as date_created_user_invitation\n        , lower(coalesce(ui.email,wl.email)) AS user_email\n        , user_email as user_email_ui_wl\n        , ui.id AS user_invitation_id\n        , ui.INVITING_USER_ID as INVITING_USER_ID_UI\n        , null as user_sign_up_id\n        , null as INVITING_USER_ID_US\n        , wl.*\n        , null as has_applied\n        , null as has_account\n        , null as has_profile\n        , null as ENABLED\n        , null as IS_IDENTITY_VERIFIED\n        , null as LAST_LOGIN\n        , null as IS_VALIDATED\n        --going with waitlist date 1st, user_invitation 2nd because of current lead_arrival_date logic\n        , row_number() over (partition by user_email order by wl.wl_date_created, ui.DATE_CREATED) as rn_no_user_id\n        , 1 as rn_display\n        , null as display_name\n    from web_db.user_invitation ui\n    full outer JOIN cte_waitlist wl ON wl.email = ui.email\n    where user_email not in (select email_user_id from user_id_email_list)\n)\nselect a.*\nfrom user_id_records a\nwhere a.rn_user_id = 1\n  and a.rn_display = 1\nunion all\nselect b.*\nfrom non_user_id_records b\nwhere b.rn_no_user_id = 1;\n\n--table to exclude users who only have the PYC Lite product\ndrop table if exists tmp_pyc_lite_only;\ncreate temp table tmp_pyc_lite_only as\nwith pyc_lite as (\n    select distinct USER_ID\n    from WEB_DB.USER_PRODUCT_APPLICATION upa\n    join WEB_DB.PRODUCT p on upa.PRODUCT_ID = p.id\n    where p.CODE = 'PYC-LITE'\n)\n, non_pyc_lite as (\n    select distinct USER_ID\n    from WEB_DB.USER_PRODUCT_APPLICATION upa\n    join WEB_DB.PRODUCT p on upa.PRODUCT_ID = p.id\n    where p.CODE != 'PYC-LITE'\n)\nselect pl.USER_ID\nfrom pyc_lite pl\nleft join non_pyc_lite npl on pl.USER_ID = npl.USER_ID\nwhere npl.USER_ID is null;\n\n--two temp tables below are used to identify credit leads\ndrop table if exists tmp_credit_lead_email;\ncreate temp table tmp_credit_lead_email as\nselect lower(email) as email\nfrom WEB_DB.WAIT_LIST_USER\nwhere PRODUCT_ID = 8\nunion\nselect lower(email) as email\nfrom WEB_DB.PRODUCT_WAITLIST\nwhere PRODUCT_ID = 8\nunion\nselect lower(email) as email\nfrom WEB_DB.USER_INVITATION\nwhere PRODUCT_ID = 8;\n\ndrop table if exists tmp_credit_lead_user_id;\ncreate temp table tmp_credit_lead_user_id as\nselect INVITED_USER_ID as USER_ID\nfrom WEB_DB.USER_SIGNUP a\njoin WEB_DB.PRODUCT_WAITLIST b on a.PRODUCT_WAITLIST_ID = b.ID\nwhere b.PRODUCT_ID = 8\nunion\nselect INVITED_USER_ID as USER_ID\nfrom WEB_DB.USER_SIGNUP a\njoin WEB_DB.USER_INVITATION b on a.USER_INVITATION_ID = b.ID\nwhere b.PRODUCT_ID = 8\nunion\n--need queries below for people where wait list email differs from primary email\nselect ue.USER_ID\nfrom tmp_credit_lead_email e\njoin WEB_DB.USER_EMAIL ue on e.EMAIL = lower(ue.EMAIL)\nunion\nselect c.INVITED_USER_ID\nfrom WEB_DB.PRODUCT_WAITLIST a\njoin WEB_DB.USER_INVITATION b on lower(a.EMAIL) = lower(b.EMAIL)\njoin WEB_DB.USER_SIGNUP c on b.ID = c.USER_INVITATION_ID\nwhere a.PRODUCT_ID = 8;\n\n--table below used for email lead matching for cases where people have changed their emails since becoming a lead\ndrop table if exists etl.dt_users_email;\ncreate table etl.dt_users_email as\nwith waitlist_emails as (\n    select lower(email) as email\n    from WEB_DB.WAIT_LIST_USER\n    union\n    select lower(email)\n    from WEB_DB.PRODUCT_WAITLIST\n)\n, user_data as (\n    select a.EMAIL,\n           c.INVITED_USER_ID as user_id\n    from waitlist_emails a\n    join WEB_DB.USER_INVITATION b on a.EMAIL = lower(b.EMAIL)\n    join WEB_DB.USER_SIGNUP c on b.ID = c.USER_INVITATION_ID\n)\n, email as (\n    select lower(email) as email,\n           user_id,\n           row_number() over (partition by user_id order by last_updated desc) as rn\n    from web_db.user_email\n    where is_primary = true\n)\n, list as (\n    select w.EMAIL,\n           e.EMAIL as primary_email,\n           u.user_id,\n           case when w.EMAIL = e.email then 1 else 2 end as priority_order,\n           row_number() over (partition by w.email order by priority_order) as rn\n    from waitlist_emails w\n    left join user_data u on w.EMAIL = u.EMAIL\n    left join email e on u.user_id = e.USER_ID and e.rn = 1\n    where primary_email is not null\n)\nselect email,\n       primary_email,\n       user_id\nfrom list\nwhere rn = 1;\n\n--remove email records where the link is probably to a different person or circular\ndelete\nfrom etl.dt_users_email\nwhere EMAIL != PRIMARY_EMAIL\nand EMAIL in (select PRIMARY_EMAIL from etl.DT_USERS_EMAIL);\n\n--etl.dt_users will be used as a base for both non-credit and credit versions of dt_users\nDROP TABLE IF EXISTS etl.dt_users;\nCREATE TABLE etl.dt_users\nAS (\n   WITH\n      users AS (\n         WITH\n            attribution_data AS (\n               SELECT CASE WHEN u.USER_INVITATION_CODE = 'mi' THEN 'iOS Signup'\n                           WHEN u.USER_INVITATION_CODE  = 'ma' THEN 'Android Signup'\n                           WHEN u.INVITING_USER_ID_UI > 1 OR u.USER_INVITATION_ID IS NULL THEN 'Referral'\n                           WHEN u.USER_INVITATION_ID IS NOT NULL THEN 'Web Signup'\n                           ELSE 'Unknown'\n                           END AS lead_source\n                    , CASE WHEN u.USER_INVITATION_CODE IN ('mi','ma') THEN u.DATE_CREATED_USER_SIGN_UP\n                           WHEN u.WAIT_LIST_ID IS NOT NULL THEN u.DATE_CREATED_WAITLIST\n                           WHEN u.USER_INVITATION_ID IS NOT NULL THEN u.DATE_CREATED_USER_INVITATION\n                           ELSE u.DATE_CREATED_USER_SIGN_UP\n                           END AS lead_arrival_date\n                    , u.user_email\n                    , u.USER_INVITATION_ID AS user_invitation_id\n                    , CASE WHEN u.WAIT_LIST_ID IS NULL OR u.USER_INVITATION_CODE IN ('mi','ma') THEN FALSE ELSE TRUE END AS is_wait_list_user\n                    , CASE WHEN u.USER_INVITATION_ID IS NULL OR u.USER_INVITATION_CODE IN ('mi','ma') THEN FALSE ELSE TRUE END AS is_invitation_sent\n                    , CASE WHEN u.USER_SIGN_UP_ID IS NULL THEN FALSE ELSE TRUE END AS is_signed_up\n                    , u.utm_source AS utm_source\n                    , case when up.SHOW_IN_DASHBOARD = true then 'Partner' else null end as utm_category\n                    , u.utm_medium AS utm_medium\n                    , u.utm_term AS utm_term\n                    , u.utm_content AS utm_content\n                    , u.utm_campaign AS utm_campaign\n                    , regexp_substr(u.initial_url,'click_?id=([^&]*)',1,1,'e') AS utm_click_id\n                    , regexp_substr(u.initial_url,'sub_?id1?=([^&]*)',1,1,'e') AS utm_click_sub_id\n                    , regexp_substr(u.initial_url,'sub_?id2=([^&]*)',1,1,'e') AS utm_click_sub_id2\n                    , regexp_substr(u.initial_url,'sub_?id3=([^&]*)',1,1,'e') AS utm_click_sub_id3\n                    , u.initial_url AS utm_initial_url\n                    , regexp_replace(u.initial_url,'(.*&gclid=([^&]*))?(.*)','$2') AS gcl_id\n                    , u.referral_domain_clean AS referral_domain\n                    , u.referral_url\n                    , CASE WHEN u.product_id = 1 AND u.account_type_id = 2 THEN 'Redwood Individual'\n                           WHEN u.product_id = 1 AND u.account_type_id = 3 THEN 'Redwood IRA'\n                           WHEN u.product_id = 2 AND u.account_type_id = 2 THEN 'Flagship Individual'\n                           WHEN u.product_id = 2 AND u.account_type_id = 3 THEN 'Flagship IRA'\n                           WHEN u.product_id IN (3,4) THEN 'Checking'\n                           WHEN u.product_id = 8 THEN 'Credit'\n                           ELSE 'Unattributed'\n                           END AS initial_product_selected\n                    , CASE WHEN u.INVITING_USER_ID_UI > 1 OR u.INVITING_USER_ID_US > 1 THEN TRUE\n                           ELSE FALSE\n                           END AS is_referral\n                    , u.user_id\n                    , CASE WHEN u.USER_INVITATION_ID IS NOT NULL THEN TRUE ELSE FALSE END AS has_entered_credentials\n                    , u.user_created AS entered_credentials_date\n                    , u.uuid AS external_user_id\n                    , NOT u.enabled AS user_disabled\n                    , utm_lander\n                    , nvl(cmp1.value, split_part(u.utm_campaign,'-',1)) AS utm_campaign_product\n                    , nvl(cmp2.value, ltrim(regexp_substr(u.utm_campaign,'-.*',1),'-')) AS utm_campaign_marketing_campaign\n                    , nvl(cnt1.value, split_part(u.utm_content,'-',1)) AS utm_content_creative_type\n                    , nvl(cnt2.value, split_part(u.utm_content,'-',2)) AS utm_content_creative_description\n                    , nvl(cnt3.value, split_part(u.utm_content,'-',3)) AS utm_content_cta\n                    , nvl(cnt4.value, split_part(u.utm_content,'-',4)) AS utm_content_placement\n                    , nvl(cnt5.value, split_part(u.utm_content,'-',5)) AS utm_content_variable\n                    , decode(regexp_replace(u.utm_content,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$|(((-)[^-]+){4})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9$12$12$12$12$12')\n                       , '-----', split_part(split_part(u.utm_content,'-',6),' ',2)\n                       ) AS utm_content_ad_id\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', trm1.value\n                       , '------', trm1.value\n                       ) AS utm_term_audience_type\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', trm2.value\n                       , '------', null\n                       ) AS utm_term_seed_audience\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', trm3.value\n                       , '------', null\n                       ) AS utm_term_lal_percentage\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', trm4.value\n                       , '------', null\n                       ) AS utm_term_messaging\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', null\n                       , '------', split_part(u.utm_term,'-',2)\n                       ) AS utm_term_ad_id\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', null\n                       , '------', split_part(u.utm_term,'-',3)\n                       ) AS utm_term_ad_platform\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', null\n                       , '------', split_part(u.utm_term,'-',4)\n                       ) AS utm_term_ad_placement\n                    , decode(regexp_replace(u.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n                       , '----', split_part(u.utm_term,'-',5)\n                       , '------', split_part(u.utm_term,'-',5) || rtrim(concat(' ',split_part(u.utm_term,'-',6))) || rtrim(concat(' ',split_part(u.utm_term,'-',7)))\n                       ) AS utm_term_start_date\n                    , u.INVITING_USER_ID_US as INVITING_USER_ID\n                    , CASE WHEN started_applications.user_id IS NULL THEN FALSE ELSE TRUE END AS has_started_application\n                    , CASE WHEN entered_funding.user_id IS NULL THEN FALSE ELSE TRUE END AS has_entered_funding_amount\n                    , CASE WHEN entered_fee.user_id IS NULL THEN FALSE ELSE TRUE END AS has_entered_fee\n                    , coalesce(u.is_validated,FALSE) AS has_validated_email\n\n               FROM etl.user_list u\n\n               LEFT JOIN web_db.dt_utm_fields_master utm ON utm.utm_generated_url_final = u.initial_url\n\n               LEFT JOIN rdl.utm_lookup cmp1 ON cmp1.utm = 'Campaign' AND cmp1.part = '1' AND lower(cmp1.code) = lower(split_part(u.utm_campaign,'-',1))\n               LEFT JOIN rdl.utm_lookup cmp2 ON cmp2.utm = 'Campaign' AND cmp2.part = '2' AND lower(cmp2.code) = lower(split_part(u.utm_campaign,'-',2))\n               LEFT JOIN rdl.utm_lookup cnt1 ON cnt1.utm = 'Content'  AND cnt1.part = '1' AND lower(cnt1.code) = lower(split_part(u.utm_content,'-',1))\n               LEFT JOIN rdl.utm_lookup cnt2 ON cnt2.utm = 'Content'  AND cnt2.part = '2' AND lower(cnt2.code) = lower(split_part(u.utm_content,'-',2))\n               LEFT JOIN rdl.utm_lookup cnt3 ON cnt3.utm = 'Content'  AND cnt3.part = '3' AND lower(cnt3.code) = lower(split_part(u.utm_content,'-',3))\n               LEFT JOIN rdl.utm_lookup cnt4 ON cnt4.utm = 'Content'  AND cnt4.part = '4' AND lower(cnt4.code) = lower(split_part(u.utm_content,'-',4))\n               LEFT JOIN rdl.utm_lookup cnt5 ON cnt5.utm = 'Content'  AND cnt5.part = '5' AND lower(cnt5.code) = lower(split_part(u.utm_content,'-',5))\n               LEFT JOIN rdl.utm_lookup trm1 ON trm1.utm = 'Term'     AND trm1.part = '1' AND lower(trm1.code) = lower(split_part(u.utm_term,'-',1))\n               LEFT JOIN rdl.utm_lookup trm2 ON trm2.utm = 'Term'     AND trm2.part = '2' AND lower(trm2.code) = lower(split_part(u.utm_term,'-',2))\n               LEFT JOIN rdl.utm_lookup trm3 ON trm3.utm = 'Term'     AND trm3.part = '3' AND lower(trm3.code) = lower(split_part(u.utm_term,'-',3))\n               LEFT JOIN rdl.utm_lookup trm4 ON trm4.utm = 'Term'     AND trm4.part = '4' AND lower(trm4.code) = lower(split_part(u.utm_term,'-',4))\n               LEFT JOIN rdl.utm_partnership up ON u.utm_source = up.utm_source\n               LEFT JOIN (\n                  SELECT user_id\n                  FROM web_db.user_product_application\n                  WHERE account_type_id IN (2,3)\n                  GROUP BY 1\n                  ) started_applications ON started_applications.user_id = u.user_id\n\n               LEFT JOIN (\n                  SELECT user_id\n                  FROM web_db.user_product_application\n                  WHERE account_type_id IN (2,3)\n                    AND (ifnull(funding_amount,0) != 0 or ifnull(STRIPE_FUNDING_AMOUNT, 0) != 0)\n                  GROUP BY 1\n                  ) entered_funding ON entered_funding.user_id = u.user_id\n\n               LEFT JOIN (\n                  SELECT user_id\n                  FROM web_db.user_product_application\n                  WHERE account_type_id IN (2,3)\n                    AND FEE_AMOUNT is not null\n                  GROUP BY 1\n                  ) entered_fee ON entered_fee.user_id = u.user_id\n               ),\n            aggregated_account_data AS (\n               WITH\n                  first_account AS (\n                     SELECT user_id\n                          , unique_account_id\n                          , inception_date\n                          , inception_date_time\n                          , funding_amount\n                          , opening_monthly_usd_fee_setting\n                          , opening_yearly_percent_fee_setting\n                          , a.account_type\n                          , funding_bank_account_id\n                          , initial_monthly_recurring_investment_amount\n                     FROM bi_new.dt_accounts a\n                     WHERE account_creation_order = 1\n                     ),\n                  second_account AS (\n                     SELECT user_id\n                          , unique_account_id\n                          , account_type\n                          , inception_date\n                          , inception_date_time\n                     FROM bi_new.dt_accounts a\n                     WHERE account_creation_order = 2\n                     ),\n\n                  initial_transfer_post as (\n                     SELECT user_id\n                          , min(initial_transfer_posted_date) as initial_transfer_posted_date\n                     FROM bi_new.dt_accounts a\n                     WHERE account_type = 'Checking'\n                     group by 1\n                  )\n\n               SELECT a.user_id\n                    , fa.account_type AS first_account_type\n                    , sa.account_type AS second_account_type\n                    , fa.funding_amount AS first_account_funding_amount\n                    , fa.inception_date AS first_account_inception_date\n                    , fa.inception_date_time AS first_account_inception_date_time\n                    , fa.opening_monthly_usd_fee_setting AS first_account_opening_monthly_usd_fee_setting\n                    , fa.opening_yearly_percent_fee_setting AS first_account_opening_yearly_percent_fee_setting\n                    , fa.funding_bank_account_id AS first_account_funding_bank_account_id\n                    , fa.initial_monthly_recurring_investment_amount AS first_account_initial_monthly_recurring_investment_account\n                    , sa.inception_date::DATE - fa.inception_date::DATE AS days_between_first_and_second_account\n                    , date_part('year',sa.inception_date) * 12 - date_part('year',fa.inception_date) * 12 +\n                      date_part('month',sa.inception_date) -\n                      date_part('month',fa.inception_date) AS months_between_first_and_second_account\n                    , itp.initial_transfer_posted_date as initial_transfer_posted_date\n                    , BOOLOR_AGG(a.account_type = 'Checking') AS has_checking_account\n                    , BOOLOR_AGG(a.account_type = 'Flagship Individual') AS has_flagship_individual\n                    , BOOLOR_AGG(a.account_type = 'Flagship IRA') AS has_flagship_ira\n                    , BOOLOR_AGG(a.account_type = 'Redwood Individual') AS has_redwood_individual\n                    , BOOLOR_AGG(a.account_type = 'Redwood IRA') AS has_redwood_ira\n                    , sum(current_balance) AS current_total_assets\n                    , count(*) AS total_accounts_opened\n                    , CASE WHEN count(*) >= 1 THEN TRUE ELSE FALSE END AS has_opened_aspiration_account\n                    , sum(current_monthly_recurring_investment_amount) AS current_monthly_recurring_investment_amount\n\n               FROM bi_new.dt_accounts a\n               INNER JOIN first_account fa ON a.user_id = fa.user_id\n               LEFT JOIN second_account sa ON a.user_id = sa.user_id\n               left join initial_transfer_post itp on itp.user_id = a.user_id\n               GROUP BY 1\n                      , 2\n                      , 3\n                      , 4\n                      , 5\n                      , 6\n                      , 7\n                      , 8\n                      , 9\n                      , 10\n                      , 11\n                      , 12\n                      , 13\n               ),\n            customer_information AS (\n               SELECT up.user_id\n                    , date_of_birth\n                    , datediff('months',date_of_birth,CURRENT_DATE) / 12 AS customer_age\n                    , upper(first_name) AS first_name\n                    , upper(middle_name) AS middle_name\n                    , upper(last_name) AS last_name\n                    , CASE gender_type WHEN 1 THEN 'Male' WHEN 2 THEN 'Female' ELSE 'Other' END AS gender\n                    , gross_income\n                    , liquid_net_worth\n                    , has_alternative_investments\n                    , has_bonds\n                    , has_cd\n                    , has_checking\n                    , has_etf\n                    , has_ira\n                    , has_mutual_funds\n                    , has_options\n                    , has_savings\n                    , has_stock\n                    , CASE uip.employment_status WHEN 0 THEN 'Undefined'\n                                                 WHEN 1 THEN 'Employed Full Time'\n                                                 WHEN 2 THEN 'Employed Part Time'\n                                                 WHEN 3 THEN 'Self Employed'\n                                                 WHEN 4 THEN 'Student'\n                                                 WHEN 5 THEN 'Retired'\n                                                 WHEN 6 THEN 'Not Employed'\n                                                 END AS employment\n                    , CASE marital_status WHEN 0 THEN 'Undefined'\n                                          WHEN 1 THEN 'Single'\n                                          WHEN 2 THEN 'Married'\n                                          WHEN 3 THEN 'Divorced'\n                                          WHEN 4 THEN 'Widowed'\n                                          WHEN 5 THEN 'Separated'\n                                          WHEN 6 THEN 'Domestic Partner'\n                                          END AS marital_status\n                    , has_trust\n                    , has401k\n                    , has_joint\n                    , upper(city) AS city\n                    , s.name AS state\n                    , upper(a.street1) AS street_line_1\n                    , upper(a.street2) AS street_line_2\n                    , phone_number\n                    , is_phone_validated\n                    , zip_or_postal_code AS zip_code\n               FROM web_db.user_profile up\n               LEFT JOIN web_db.user_investment_profile uip ON uip.user_id = up.user_id\n               LEFT JOIN web_db.address a ON a.id = coalesce(mailing_address_id,up.address_id)\n               LEFT JOIN web_db.state s ON s.id = a.state_id\n               ),\n            alloy_evaluation AS (\n               SELECT CIP_status\n                    , user_id\n                    , CIP_status_date\n                    , CIP_manual_review_completion_date\n                    , alloy_custom_model_score\n                    , alloy_custom_model_version\n                    , alloy_summary_application_version\n               FROM (\n                  SELECT d.\"alloy summary_outcome\" || CASE WHEN d.\"alloy summary_outcome\" = 'Manual Review'\n                                                              THEN cast(' - ' || coalesce(rd.outcome,'Pending') AS VARCHAR(50))\n                                                           ELSE ''\n                                                           END AS CIP_status\n                       , app.user_id AS user_id\n                       , e.submitted_at AS CIP_status_date\n                       , rd.timestamp AS CIP_manual_review_completion_date\n                       , d.\"custom models_model_score\" as alloy_custom_model_score\n                       , d.\"custom models_model_version\" as alloy_custom_model_version\n                       , d.\"alloy summary_application_version_id\" as alloy_summary_application_version\n                       , row_number() OVER (PARTITION BY app.user_id ORDER BY CIP_status_date DESC) AS row_num\n                  FROM aoa_db.alloy_evaluations e\n                  JOIN web_db.user_product_application app ON app.id = e.user_product_application_id\n                  JOIN rdl.alloy_evaluations_flattened d ON d.evaluation_id = e.id\n                  LEFT JOIN aoa_db.evaluation_reviews er ON er.alloy_evaluation_id = e.id\n                  LEFT JOIN rdl.alloy_evaluation_reviews_flattened rd ON rd.evaluation_review_id = er.id\n                  WHERE nullif(trim(d.\"alloy summary_outcome\"),'') IS NOT NULL\n                  ) AS a\n               WHERE a.row_num = 1\n               ),\n            cohorts AS (\n               SELECT uc.user_id\n                    , c.name AS cohort_name\n               FROM web_db.cohorts c\n               JOIN web_db.user_cohorts uc ON c.id = uc.cohorts_id\n               WHERE c.name IN ('check-deposit-disabled','withdrawal-disabled')\n               )\n\n         SELECT a.user_email\n              , a.has_validated_email\n              , a.user_id\n              , a.has_entered_credentials\n              , a.entered_credentials_date\n              , a.external_user_id\n              , a.lead_source\n              , a.utm_source\n              , a.utm_category\n              , a.lead_arrival_date\n              , a.utm_content\n              , nvl(a.referral_domain,'direct') AS referral_domain\n              , a.referral_url\n              , a.initial_product_selected\n              , a.is_signed_up\n              , a.utm_campaign\n              , ifnull(a.utm_click_id,'') AS utm_click_id\n              , ifnull(a.utm_click_sub_id,'') AS utm_click_sub_id\n              , ifnull(a.utm_click_sub_id2,'') AS utm_click_sub_id2\n              , ifnull(a.utm_click_sub_id3,'') AS utm_click_sub_id3\n              , a.utm_initial_url\n              , a.gcl_id\n              , a.utm_medium\n              , a.utm_term\n              , a.user_disabled\n              , utm_lander\n              , utm_campaign_product\n              , utm_campaign_marketing_campaign\n              , utm_content_creative_type\n              , utm_content_creative_description\n              , utm_content_cta\n              , utm_content_placement\n              , utm_content_variable\n              , utm_content_ad_id\n              , utm_term_audience_type\n              , utm_term_seed_audience\n              , utm_term_lal_percentage\n              , utm_term_messaging\n              , utm_term_ad_id\n              , utm_term_ad_platform\n              , utm_term_ad_placement\n              , utm_term_start_date\n              , has_started_application\n              , has_opened_aspiration_account\n              , CASE WHEN /*gross_income IS NULL or ssn IS NULL or*/ has_started_application = FALSE THEN FALSE\n                     ELSE has_entered_funding_amount\n                     END AS has_entered_funding_amount\n              , CASE WHEN /*gross_income IS NULL or ssn IS NULL or*/ has_started_application = FALSE OR has_entered_funding_amount = FALSE\n                        THEN FALSE\n                     ELSE has_entered_fee\n                     END AS has_entered_fee\n              , CASE WHEN /*ssn IS NULL or*/ has_started_application = FALSE OR first_name IS NULL THEN FALSE\n                     ELSE TRUE\n                     END AS has_entered_personal_information\n              , CASE WHEN /*gross_income IS NULL or ssn IS NULL or*/ has_started_application = FALSE OR first_name IS NULL\n                        THEN FALSE\n                     ELSE TRUE\n                     END AS has_entered_financial_information\n              , CASE WHEN\n                        /* gross_income IS NULL or ssn IS NULL or has_started_application = false or has_entered_funding_amount = false\n                        or has_entered_fee = false or*/ entered_bank.user_id IS NULL THEN FALSE\n                     ELSE TRUE\n                     END AS has_attempted_to_link_bank\n              , CASE WHEN\n                        /* gross_income IS NULL or ssn IS NULL or has_started_application = false or has_entered_funding_amount = false\n                        or has_entered_fee = false or*/ verified_bank.user_id IS NULL THEN FALSE\n                     ELSE TRUE\n                     END AS has_verified_bank\n              , CASE WHEN tc.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS has_accepted_terms_and_conditions\n              , b.zip_code\n              , b.state\n              , b.street_line_2\n              , b.marital_status\n              , b.street_line_1\n              , b.gender\n              , b.date_of_birth\n              , b.customer_age\n              -- ssn,\n              , b.employment\n              , b.phone_number\n              , b.is_phone_validated\n              , b.first_name\n              , b.city\n              , b.gross_income\n              , b.last_name\n              , b.middle_name\n              , b.has_checking\n              , b.has401k\n              , b.has_alternative_investments\n              , b.has_bonds\n              , b.has_cd\n              , b.has_etf\n              , b.has_ira\n              , b.has_joint\n              , b.has_mutual_funds\n              , b.has_options\n              , b.has_savings\n              , b.has_stock\n              , b.has_trust\n              , b.liquid_net_worth\n              , c.second_account_type\n              , c.first_account_type\n              , c.current_monthly_recurring_investment_amount\n              , c.current_total_assets\n              , c.days_between_first_and_second_account\n              , c.months_between_first_and_second_account\n              , c.first_account_funding_amount\n              , c.first_account_funding_bank_account_id\n              , c.first_account_inception_date\n              , c.first_account_inception_date_time\n              , c.first_account_opening_monthly_usd_fee_setting\n              , c.first_account_opening_yearly_percent_fee_setting\n              , coalesce(c.has_flagship_individual,FALSE) AS has_flagship_individual\n              , coalesce(c.has_flagship_ira,FALSE) AS has_flagship_ira\n              , coalesce(c.has_redwood_individual,FALSE) AS has_redwood_individual\n              , coalesce(c.has_redwood_ira,FALSE) AS has_redwood_ira\n              , coalesce(c.has_checking_account,FALSE) AS has_checking_account\n              , coalesce(c.total_accounts_opened,0) AS total_accounts_opened\n              , c.initial_transfer_posted_date\n              , CASE WHEN r_ind.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS redwood_individual_application_started\n              , CASE WHEN r_ira.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS redwood_ira_application_started\n              , CASE WHEN f_ind.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS flagship_individual_application_started\n              , CASE WHEN f_ira.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS flagship_ira_application_started\n              , CASE WHEN risk_cohorts.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS has_risk_cohorts\n              , a.inviting_user_id\n              , alloy.CIP_status AS CIP_status\n              , alloy.CIP_status_date AS CIP_status_date\n              , alloy.CIP_manual_review_completion_date AS CIP_manual_review_completion_date\n              , alloy.alloy_custom_model_score\n              , alloy.alloy_custom_model_version\n              , alloy.alloy_summary_application_version\n              , CASE WHEN cohort_deposit.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS is_mobile_check_deposit_disabled\n              , CASE WHEN cohort_withdrawal.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS is_withdrawal_disabled\n              , CASE WHEN HSA.STATUS in (4,5,6) THEN TRUE else FALSE end AS HAS_SUBMIT_APPLICATION\n          \n         FROM attribution_data a\n         LEFT JOIN customer_information b ON a.user_id = b.user_id\n         LEFT JOIN aggregated_account_data c ON a.user_id = c.user_id\n         LEFT JOIN (\n            SELECT user_id\n                 , status\n            FROM web_db.user_product_application\n            WHERE product_id = 1\n              AND account_type_id = 2\n            ) r_ind ON r_ind.user_id = a.user_id\n         LEFT JOIN (\n            SELECT user_id\n                 , status\n            FROM web_db.user_product_application\n            WHERE product_id = 1\n              AND account_type_id = 3\n            ) r_ira ON r_ira.user_id = a.user_id\n         LEFT JOIN (\n            SELECT user_id\n                 , status\n            FROM web_db.user_product_application\n            WHERE product_id = 2\n              AND account_type_id = 2\n            ) f_ind ON f_ind.user_id = a.user_id\n         LEFT JOIN (\n            SELECT user_id\n                 , status\n            FROM web_db.user_product_application\n            WHERE product_id = 2\n              AND account_type_id = 3\n            ) f_ira ON f_ira.user_id = a.user_id\n         LEFT JOIN (select row_number() over (partition by USER_ID order by DATE_CREATED desc ) as row_num, * from (\n              select DATE_CREATED, USER_ID,ACCOUNT_ID, STRIPE_FUNDING_AMOUNT, PRODUCT_ID, STATUS from WEB_DB.USER_PRODUCT_APPLICATION\n              where PRODUCT_ID in (4,5)\n              and STATUS in (4,5,6)\n            ) ) HSA ON HSA.user_id = a.user_id  and  hsa.row_num=1\n         LEFT JOIN (\n            SELECT DISTINCT user_id\n            FROM bi_new.dt_banks\n            WHERE is_checking_account = FALSE\n            ) entered_bank ON entered_bank.user_id = a.user_id\n         LEFT JOIN (\n            SELECT DISTINCT user_id\n            FROM bi_new.dt_banks\n            WHERE is_verified = TRUE\n              AND is_checking_account = FALSE\n            ) verified_bank ON verified_bank.user_id = a.user_id\n         LEFT JOIN (\n            SELECT DISTINCT user_id\n            FROM web_db.user_terms_conditions\n            ) tc ON tc.user_id = a.user_id\n\n         LEFT JOIN (\n            SELECT DISTINCT user_id\n            FROM web_db.user_cohorts\n            WHERE cohorts_id IN (22,23)\n            ) risk_cohorts ON risk_cohorts.user_id = a.user_id\n         LEFT JOIN cohorts AS cohort_deposit\n                   ON cohort_deposit.user_id = a.user_id AND cohort_deposit.cohort_name = 'check-deposit-disabled'\n         LEFT JOIN cohorts AS cohort_withdrawal\n                   ON cohort_withdrawal.user_id = a.user_id AND cohort_withdrawal.cohort_name = 'withdrawal-disabled'\n         LEFT JOIN alloy_evaluation AS alloy ON alloy.user_id = a.user_id\n         ),\n      aggregate_spending AS (\n         SELECT paid_channel_name\n              , utm_source_1\n              , utm_source_2\n              , start_date\n              , end_date\n              , spend / (1.0 * cnt) AS spend_per_acquisition\n         FROM (\n            SELECT m.channel_name AS paid_channel_name\n                 , utm_source_1\n                 , utm_source_2\n                 , start_date\n                 , end_date\n                 , m.spend\n                 , count(*) AS cnt\n            FROM users u\n            INNER JOIN web_db.dt_marketing_spend m\n                       ON (u.utm_source = m.utm_source_1 OR u.utm_source = m.utm_source_2) AND\n                          lead_arrival_date::DATE >= m.start_date AND lead_arrival_date::DATE < m.end_date AND\n                          m.spend IS NOT NULL AND u.total_accounts_opened > 0\n            GROUP BY 1\n                   , 2\n                   , 3\n                   , 4\n                   , 5\n                   , 6\n            ORDER BY 1\n                   , 2\n                   , 3\n                   , 4\n                   , 5\n                   , 6\n            ) a\n         ),\n      filled_end_dates AS (\n         SELECT channel_name\n              , utm_source_1\n              , utm_source_2\n              , start_date\n              , (\n            SELECT min(start_date)\n            FROM web_db.dt_marketing_spend a\n            WHERE a.channel_name = s.channel_name\n              AND a.start_date > s.start_date\n            ) AS end_date\n              , cpa\n              , cpl\n         FROM web_db.dt_marketing_spend s\n         WHERE cpl IS NOT NULL\n            OR cpa IS NOT NULL\n         ),\n      cpl_spends AS (\n         SELECT channel_name\n              , lead_arrival_month\n              , utm_source_1\n              , utm_source_2\n              , cpl * lead_count / (1.0 * customer_count) AS spend_per_aquisition\n         FROM (\n            SELECT channel_name\n                 , utm_source_1\n                 , utm_source_2\n                 , start_date\n                 , end_date\n                 , cpl\n                 , date_trunc('month',lead_arrival_date) :: DATE AS lead_arrival_month\n                 , count(*) AS lead_count\n                 , sum(CASE WHEN total_accounts_opened > 0 THEN 1 ELSE 0 END) AS customer_count\n            FROM filled_end_dates fed\n            INNER JOIN users u ON (fed.utm_source_1 = u.utm_source OR fed.utm_source_2 = u.utm_source) AND\n                                  lead_arrival_date::DATE >= start_date AND\n                                  (end_date IS NULL OR lead_arrival_date::DATE < end_date)\n            WHERE fed.cpl IS NOT NULL\n            GROUP BY 1\n                   , 2\n                   , 3\n                   , 4\n                   , 5\n                   , 6\n                   , 7\n            HAVING sum(CASE WHEN total_accounts_opened > 0 THEN 1 ELSE 0 END) > 0\n            ) a\n         ),\n      cpa_spends AS (\n         SELECT channel_name\n              , date_trunc('month',lead_arrival_date) :: DATE AS lead_arrival_month\n              , utm_source_1\n              , utm_source_2\n              , cpa AS spend_per_acquisition\n         FROM filled_end_dates fed\n         INNER JOIN users u ON (fed.utm_source_1 = u.utm_source OR fed.utm_source_2 = u.utm_source) AND\n                               lead_arrival_date::DATE >= start_date AND\n                               (end_date IS NULL OR lead_arrival_date::DATE < end_date)\n         WHERE cpa IS NOT NULL\n         GROUP BY 1\n                , 2\n                , 3\n                , 4\n                , 5\n         ),\n      months AS (\n         SELECT DATEADD('month',i - 1,'2014-10-01') AS month\n         FROM (\n                     select row_number() over(order by seq4()) as i\n                     from table(generator(\n                                rowcount =>3000\n                                )\n                         )\n                  )\n         WHERE i <= (DATE_PART('year',CURRENT_DATE) - DATE_PART('year','2014-10-01'::DATE)) * 12 +\n                    (DATE_PART('month',CURRENT_DATE) - DATE_PART('month','2014-10-01'::DATE)) + 1\n         ),\n      agg_spend AS (\n         SELECT paid_channel_name\n              , month\n              , utm_source_1\n              , utm_source_2\n              , spend_per_acquisition\n         FROM aggregate_spending a\n         INNER JOIN months b ON b.month >= a.start_date AND b.month < a.end_date\n         ),\n      all_spend AS (\n         SELECT *\n         FROM cpa_spends\n         UNION ALL\n         SELECT *\n         FROM cpl_spends\n         UNION ALL\n         SELECT *\n         FROM agg_spend\n         ),\n      invites_count AS (\n            SELECT u.inviting_user_id\n            , count(*) AS number_invites_sent\n            ,sum(case\n                  when a.initial_transfer_posted_date IS NOT NULL then 1\n                  else 0 end) as num_funded_referrals\n            FROM web_db.user_signup u\n               left join bi_new.dt_accounts a on u.invited_user_id = a.user_id\n                                             and a.account_type = 'Checking'\n            GROUP BY u.inviting_user_id\n         ),\n      cte_smart_limit AS (\n         SELECT DISTINCT user_id\n         FROM web_db.user_product_application\n         WHERE is_smart_limit = TRUE\n         )\n\n   SELECT distinct u.*\n        , utm_source_clean\n        , utm_channel_type\n        , utm_channel_grouping\n        , spend_per_acquisition AS marketing_cost_per_user\n        , most_current_nps_score\n        , most_current_nps_survey_date\n        , CASE WHEN f.chargeoff_reason IS NOT NULL OR sum.chargeoff_reason IS NOT NULL THEN TRUE\n               ELSE FALSE\n               END AS is_fraud_or_chargeoff\n        , coalesce(sum.chargeoff_reason,f.chargeoff_reason) AS fraud_or_chargeoff_type\n        , sum.total_amount_charged_off\n        , sum.hard_loss_charge_off\n        , sum.fees_charged_off\n        , invites_count.number_invites_sent\n        , invites_count.num_funded_referrals\n        , CASE WHEN csl.user_id IS NOT NULL THEN TRUE ELSE FALSE END AS is_smart_limit\n        , min_payment_account_linked_date AS external_bank_account_connected_date\n        , case when tcle.email is not null or tclui.user_id is not null\n               then true else false end as has_credit_lead\n        , case when upa_cred.USER_ID is not null\n               then true else false end as has_credit_product_application\n        , cifd.cma_initiated_funding_date\n   FROM users u\n\n   LEFT JOIN invites_count ON invites_count.inviting_user_id = u.user_id\n   LEFT JOIN cte_smart_limit csl ON csl.user_id = u.user_id\n   LEFT JOIN all_spend s ON (u.utm_source = s.utm_source_1 OR u.utm_source = s.utm_source_2) AND\n                            CASE WHEN total_accounts_opened > 0 THEN date_trunc('month',u.lead_arrival_date) :: DATE\n                                 ELSE NULL\n                                 END = s.lead_arrival_month\n\n   LEFT JOIN (\n    SELECT\n      a.email,\n      a.pull_date :: DATE AS most_current_nps_survey_date,\n      a.nps_rating        AS most_current_nps_score\n    FROM dataops_ace_db.nps_survey_candidate a\n      INNER JOIN (\n         SELECT\n           email,\n           max(pull_date) AS max_pull_date\n         FROM dataops_ace_db.nps_survey_candidate\n         GROUP BY email\n       ) b\n      ON a.email = b.email AND a.pull_date = b.max_pull_date\n     AND zendesk_nps_survey_id IS NOT NULL\n    ) nps ON u.user_email = nps.email\n\n   LEFT JOIN web_db.dt_input_fraud_users f ON u.user_email = f.email\n\n   LEFT JOIN (\n      SELECT user_id\n           , is_charged_off\n           , chargeoff_reason\n           , total_amount_charged_off\n           , hard_loss_charge_off\n           , fees_charged_off\n      FROM bi_new.dt_accounts\n      WHERE account_type = 'Checking'\n      ) sum ON sum.user_id = u.user_id\n\n   LEFT JOIN web_db.dt_external_user_ids e ON e.user_id = u.user_id\n\n   LEFT JOIN web_db.dt_utm_mapping m ON m.utm_source = u.utm_source\n\n   LEFT JOIN (\n      SELECT user_id\n           , min(payment_account_linked_date) min_payment_account_linked_date\n      FROM bi_new.dt_banks\n      WHERE is_verified = TRUE\n      GROUP BY user_id\n      ) payment_account_link_date ON payment_account_link_date.user_id = u.user_id\n\n   LEFT JOIN tmp_credit_lead_email tcle on lower(u.user_email) = tcle.email\n   LEFT JOIN tmp_credit_lead_user_id tclui on u.user_id = tclui.user_id\n   LEFT JOIN (select distinct user_id\n              from WEB_DB.USER_PRODUCT_APPLICATION\n              where PRODUCT_ID = 8) upa_cred on u.user_id = upa_cred.USER_ID\n   LEFT JOIN etl.cma_initiated_funding_date cifd on u.user_id = cifd.USER_ID\n\n   );\n\n--create the non-credit version of dt_users\ndrop table if exists bi_new.dt_users;\ncreate table bi_new.dt_users as\nselect u.*\nfrom etl.dt_users u\n-- exclude pyc-lite *only* users\nLEFT JOIN tmp_pyc_lite_only plo ON u.USER_ID = plo.USER_ID\nWHERE plo.USER_ID is null\n--keep credit leads in other non-credit products; remove credit only leads\nand (u.has_credit_lead = false\nor u.initial_product_selected != 'Credit'\nor (u.has_credit_lead = true\n    and u.user_id in (select user_id from WEB_DB.USER_PRODUCT_APPLICATION where PRODUCT_ID not in (7,8))))\n;"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022953":{"id":3022953,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-1859466705,"x":-688,"y":-416,"width":32,"height":32,"inputConnectorIDs":[3023024],"outputSuccessConnectorIDs":[3023005,3023006],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"WH - lrg, min 2 clusters"}}}},"visible":true},"2":{"slot":2,"name":"Warehouse","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"[Environment Default]"}}}},"visible":true},"3":{"slot":3,"name":"Command Type","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Set"}}}},"visible":true},"4":{"slot":4,"name":"New name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":""}}}},"visible":false},"5":{"slot":5,"name":"Properties","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"WAREHOUSE_SIZE"},"2":{"slot":2,"type":"STRING","value":"LARGE"}}},"2":{"slot":2,"values":{"1":{"slot":1,"type":"STRING","value":"MIN_CLUSTER_COUNT"},"2":{"slot":2,"type":"STRING","value":"2"}}}},"visible":true},"6":{"slot":6,"name":"Properties","elements":{},"visible":false}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022960":{"id":3022960,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-80,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023047],"outputSuccessConnectorIDs":[3023033],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"create migration view"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"--drop view if exists rdl.migration_stats;\ncreate or replace view rdl.migration_stats\nas\nselect\n\tua.user_id,\n  r.id as \"radius_depository_id\",\n  g.id as \"galileo_depository_id\",\n  r.inception_date as \"radius_inception_date\",\n  g.inception_date as \"galileo_inception_date\",\n  r.current_balance as \"radius_current_balance\",\n  cma.account_number as \"radius_account_number\",\n  case when g.id is null then ra.termination_date else ga.termination_date end as \"termination_date\",\n  case when uc.id is not null then true else false end as \"is_invited\",\n  case when uc.id is not null then uc.date_created else null end as \"invited_date\",\n\n  case when \"is_invited\"\n    then case when app.id is not null then true else false end\n    else null\n  end as \"is_migration_opt_in\",\n\n  case when \"is_invited\"\n    then case when app.status is not null then app.date_created else null end\n    else null\n  end as \"migration_opt_in_date\",\n\n  case when \"is_migration_opt_in\"\n    then case when app.status != 10 and cma.prn is not null then true else false end\n    else null\n  end as \"is_initial_flow_completed\",\n\n  case when \"is_initial_flow_completed\"\n    then case when cma.galileo_card_state = 3 then true else false end\n    else null\n  end as \"is_debit_activated\",\n\n  case when \"is_debit_activated\"\n    then case when cma.close_account_state = 3 then true else false end\n    else null\n  end as \"is_radius_closed\",\n\n  case when \"is_debit_activated\"\n    then case when cma.close_account_state = 3 then cma.close_account_date else null end\n    else null\n  end as \"radius_closed_date\",\n\n\tcma.opted_in_instant_transfer_at,\n  \n\tcase when deposits.user_id is not null then 1 else 0 end as deposits_count,\n\tcase when dd.user_id is not null then 1 else 0 end as dd_count,\n\tcase when bp.user_id is not null then 1 else 0 end as bp_count,\n\tcase when spend.user_id is not null then 1 else 0 end as spend_count,\n\tcase when save.user_id is not null then 1 else 0 end as save_count,\n\tcase when save_high.user_id is not null then 1 else 0 end as save_high_count,\n\tcase when save.user_id is not null and spend.user_id is null then 1 else 0 end as save_not_spend_count,\n\tcase when invest.user_id is not null then 1 else 0 end as invest_count,\n\tcase when dorm.user_id is null then 1 else 0 end as dormant_count,\n\tcase when login.user_id is not null then 1 else 0 end as login_count,\n\n\tcase \n\t\twhen dd_count = 1 then 'Direct Deposit User'\n\t\twhen bp_count = 1 then 'Bill Pay User'\n\t\twhen spend_count = 1 then 'Spender User'\n\t\twhen save_high_count = 1 then 'Savings High Balance User'\n\t\twhen save_count = 1 then 'Savings Medium Balance User'\n\t\twhen invest_count = 1 then 'Investment User'\n\t\twhen login_count = 1 then 'App Login User'\n-- \t\twhen deposits_count = 1 then 'Deposit User'\n\t\telse 'Inactive User'\n\tend as user_category,\n\n\tsegments.segment as checking_account_segment\n\nfrom web_db.depository r\ninner join web_db.account ra on r.account_id = ra.id\ninner join web_db.user_account ua on r.account_id = ua.account_id \ninner join web_db.user_product_application upa on (upa.user_id = ua.user_id and upa.account_id = ua.account_id)\nleft join web_db.user_cohorts uc on ua.user_id = uc.user_id and uc.cohorts_id = 27\nLEFT JOIN web_db.user_cohorts uc2 ON uc2.user_id = ua.user_id AND uc2.cohorts_id in (22, 23)\nleft join web_db.user_product_application app on ua.user_id = app.user_id and app.product_id = 4\nleft join web_db.account ga on app.account_id = ga.id\nleft join web_db.depository g on ga.id = g.account_id and g.product_id = 4\nleft join web_db.cma_migration cma on cma.depository_id = g.id\n\nleft join\n(\n\tselect dta.user_id, count(*)\n\tfrom bi.dt_depository_transactions ddt\n\tinner join bi.dt_accounts dta on (dta.unique_account_id = ddt.unique_account_id)\n\twhere 1=1\n\t\tand dta.account_type = 'Checking'\n\t\tand ddt.transaction_date >= DATEADD(month, -6, GETDATE()) \n\t\tand ddt.transaction_type in ('Debit Card - PIN', 'Debit Card - No PIN')\n\tgroup by dta.user_id\n-- \thaving count(*) = 0\n) as dorm on (dorm.user_id = ua.user_id)\n\nleft join\n(\n\tselect dta.user_id\n\tFROM bi.dt_accounts AS dta\n\tINNER JOIN bi.dt_account_monthly_data AS amd ON dta.unique_account_id = amd.unique_account_id \n\twhere 1=1\n\t\tand amd.month >= dateadd('month', -3, getdate())\n\t\tand ach_deposit_count + atm_deposit_count + check_deposit_count + wire_deposit_count > 0\n-- \t\tand amd.monthly_bill_pay_count > 0\n\tgroup by dta.user_id\n) as deposits on (deposits.user_id = ua.user_id)\n\nleft join\n(\n\tselect dta.user_id\n\tfrom bi.dt_depository_transactions ddt\n\tinner join bi.dt_accounts dta on (dta.unique_account_id = ddt.unique_account_id)\n\twhere 1=1\n\t\tand dta.account_type = 'Checking'\n\t\tand ddt.transaction_date >= DATEADD(month,-3, current_date())\n\t\tAND ddt.direct_deposit_ind = true\n\tgroup by dta.user_id\n) as dd on (dd.user_id = ua.user_id)\n\nleft join\n(\n\tselect dta.user_id\n\tFROM bi.dt_accounts AS dta\n\tINNER JOIN bi.dt_account_monthly_data AS amd ON dta.unique_account_id = amd.unique_account_id \n\twhere 1=1\n\t\tand amd.month >= dateadd('month', -3, current_date())\n\t\tand amd.monthly_bill_pay_count > 0\n\tgroup by dta.user_id\n) as bp on (bp.user_id = ua.user_id)\n\nleft join\n(\n\tselect dta.user_id\n\tfrom bi.dt_depository_transactions ddt\n\tinner join bi.dt_accounts dta on (dta.unique_account_id = ddt.unique_account_id)\n\twhere 1=1\n\t\tand dta.account_type = 'Checking'\n\t\tand ddt.transaction_date >= DATEADD(month, -6, current_date()) \n\t\tand ddt.transaction_type in ('Debit Card - PIN', 'Debit Card - No PIN')\n\tgroup by dta.user_id\n\thaving count(*) >= 1\n) as spend on (spend.user_id = ua.user_id)\n\nleft join\n(\n\tSELECT dta.user_id\n\tFROM bi.dt_accounts AS dta\n\tINNER JOIN bi.dt_account_monthly_data AS amd ON dta.unique_account_id = amd.unique_account_id \n\tWHERE 1=1\n\t\tAND dta.account_type = 'Checking' \n\t\tAND amd.end_of_month_balance between 100 and 1000 \n\t\tAND amd.month = '2019-02-01'\n\tGROUP BY dta.user_id\n) as save on (save.user_id = ua.user_id)\n\nleft join\n(\n\tSELECT dta.user_id\n\tFROM bi.dt_accounts AS dta\n\tINNER JOIN bi.dt_account_monthly_data AS amd ON dta.unique_account_id = amd.unique_account_id \n\tWHERE 1=1\n\t\tAND dta.account_type = 'Checking' \n\t\tAND amd.end_of_month_balance > 1000 \n\t\tAND amd.month = '2019-02-01'\n\tGROUP BY dta.user_id\n) as save_high on (save_high.user_id = ua.user_id)\n\nleft join\n(\n\tSELECT dta.user_id\n\tFROM bi.dt_accounts AS dta\n\tWHERE 1=1\n\t\tAND dta.account_type != 'Checking' \n\tGROUP BY dta.user_id\n\tHAVING SUM(dta.current_balance) >= 100\n) as invest on (invest.user_id = ua.user_id)\n\nleft join\n(\n\tSELECT uat.user_id\n\tFROM web_db.user_audit_trail uat\n\tWHERE 1=1\n\t\tand uat.audit_trail ilike '%logged in%'\n\t\tand uat.ip_address not like '206.108.41.10%'\n\t\tand uat.date_created >= DATEADD(month, -3, current_date()) \n\tgroup by uat.user_id\n) as login on (login.user_id = ua.user_id)\n\nleft join\n(\n\t  WITH deposits AS (\n\t    SELECT unique_account_id,\n\t      SUM(ach_deposit_count+atm_deposit_count+check_deposit_count+wire_deposit_count) AS \"num\"\n\t    FROM bi.dt_account_period_data\n\t    WHERE thirty_day_periods_since_inception <= 2\n\t    GROUP BY 1\n\t  )\n\t  SELECT dta.unique_account_id,\n\t  \tdta.user_id,\n\t    CASE WHEN dta.funding_amount >= 100 THEN TRUE ELSE FALSE END AS \"has_funding_amount_ge_100\",\n\t    CASE WHEN dtapd.debit_card_pin_transactions + dtapd.debit_card_no_pin_transactions >= 1 THEN TRUE ELSE FALSE END AS \"has_debit_usage\",\n\t    CASE WHEN dtapd.lowest_balance > 0 THEN TRUE ELSE FALSE END AS \"maintains_positive_balance\",\n\t    CASE WHEN dep.num >= 4 THEN TRUE ELSE FALSE END AS \"has_addl_deposits\",\n\n\t    CASE\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'High Risk'\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'High Risk'\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND     \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'Dormant'\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND     \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'Checking'\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'High Risk'\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'High Risk'\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND     \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'Checking'\n\t      WHEN NOT \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND     \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'Checking'\n\t      WHEN     \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'Dormant'\n\t      WHEN     \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'High Risk'\n\t      WHEN     \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND     \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'Savings'\n\t      WHEN     \"has_funding_amount_ge_100\" AND NOT \"has_debit_usage\" AND     \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'High Balance Checking'\n\t      WHEN     \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'High Risk'\n\t      WHEN     \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND NOT \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'High Risk'\n\t      WHEN     \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND     \"maintains_positive_balance\" AND NOT \"has_addl_deposits\" THEN 'Checking'\n\t      WHEN     \"has_funding_amount_ge_100\" AND     \"has_debit_usage\" AND     \"maintains_positive_balance\" AND     \"has_addl_deposits\" THEN 'High Balance Checking'\n\t    END AS \"segment\"\n\n\t  FROM bi.dt_accounts dta\n\t  INNER JOIN bi.dt_account_period_data dtapd ON dta.unique_account_id = dtapd.unique_account_id AND dtapd.thirty_day_periods_since_inception = 0\n\t  INNER JOIN deposits dep ON dta.unique_account_id = dep.unique_account_id\n\t  WHERE dta.account_type = 'Checking'\n) segments on (segments.user_id = ua.user_id)\n\nwhere 1=1\n\tand upa.account_type_id = 2\n\tand upa.status = 4 -- approved\n\tand r.inception_date is not null\n\tand r.product_id = 3\n\tAND ra.is_admin_disabled = false\n\tand uc2.id is null\n;\n\n--alter table rdl.migration_stats owner to svc_etl;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022961":{"id":3022961,"inputCardinality":"MANY","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":235671163,"x":-688,"y":-256,"width":32,"height":32,"inputConnectorIDs":[3023004,3023037],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023040],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"And 3"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022962":{"id":3022962,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-832,"y":-256,"width":32,"height":32,"inputConnectorIDs":[3023032],"outputSuccessConnectorIDs":[3023035,3023037],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_accounts_cleanup"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"DELETE FROM bi_new.dt_accounts\nWHERE unique_account_id in (\n  SELECT\n    da.unique_account_id\n  FROM bi_new.dt_accounts da\n  GROUP BY da.unique_account_id\n  HAVING count(1)>1\n)\n;\n\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022963":{"id":3022963,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-832,"y":-336,"width":32,"height":32,"inputConnectorIDs":[3023005],"outputSuccessConnectorIDs":[3023032],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_accounts"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\n--temp table for galileo termination date data\t\n--only accounts where all PRNs have been cancelled or charged off will get a termination date\t\ndrop table if exists tmp_galileo_termination;\t\ncreate temp table tmp_galileo_termination as\t\nwith customer_master as (\t\n    SELECT p.ASPIRATION_ACCOUNT_NUMBER\n         , rgcmd.galileo_account_id\n         , p.prn\n         , rgcmd.type_of_account\n         , rgcmd.file_date\n         , rgcmd.status\n         , row_number() over (partition by rgcmd.galileo_account_id\n                                order by rgcmd.file_date desc) as rn\n         , row_number() over (partition by p.aspiration_account_number\n                                  order by p.galileo_account_id::bigint,\n                                           --prioritize cancellation over charge-off to determine termination date\n                                           --this matches better with account closed notes in Admin\n                                           case rgcmd.status when 'C' then 1 when 'Z' then 1 when 'R' then 2 end,\n                                           rgcmd.type_of_account, rgcmd.file_date) as rn_termination\n    FROM rdl.raw_galileo_customer_master_data rgcmd\n    INNER JOIN rdl.VW_USER_PRN p on rgcmd.GALILEO_ACCOUNT_ID = p.GALILEO_ACCOUNT_ID\n)\t\n, customer_master_grouped as (\t\n    select\t\n      aspiration_account_number,\t\n      max(prn) as max_prn,\t\n      count(*) as total_prn,\t\n      sum(case when status in ('C', 'Z', 'R') then 1 else 0 end) as total_terminated\t\n    from customer_master\t\n    where rn = 1\t\n    group by 1\t\n    having total_prn = total_terminated\t\n)\t\nselect g.aspiration_account_number,\t\n       g.max_prn,\t\n       m.file_date as termination_date\t\nfrom customer_master_grouped g\t\njoin customer_master m on g.aspiration_account_number = m.aspiration_account_number\t\nwhere m.rn_termination = 1;\n\nDROP TABLE IF EXISTS bi_new.dt_accounts;\n\nCREATE TABLE bi_new.dt_accounts\nAS (\n   WITH\n      qualifying_depository AS (\n         SELECT DISTINCT d.id AS depository_id\n                       , d.account_id AS radius_account_id\n         FROM web_db.depository d\n         WHERE d.inception_date IS NOT NULL\n           AND d.inception_date >= '2017-01-01'\n           AND d.current_balance = 0\n         ),\n      ua_sec_rem AS (\n         SELECT ua.*\n         FROM (\n            SELECT account_id\n                 , MIN(date_created) AS min_date\n            FROM web_db.user_account\n            GROUP BY 1\n            ) a\n         INNER JOIN web_db.user_account ua ON a.account_id = ua.account_id AND a.min_date = ua.date_created\n         ),\n      active_upa_count AS (\n         SELECT qd.depository_id\n              , SUM(CASE WHEN upa.is_admin_disabled != TRUE THEN 1 ELSE 0 END) AS active_upa_count\n         FROM qualifying_depository qd\n         LEFT JOIN ua_sec_rem ua ON qd.radius_account_id = ua.account_id\n         LEFT JOIN web_db.user_payment_account upa ON ua.user_id = upa.user_id\n         WHERE upa.depository_id IS NULL\n         GROUP BY 1\n         ),\n      transaction_count AS (\n         SELECT qd.depository_id\n              , SUM(CASE WHEN NOT mt.description ILIKE 'YIELD=%' AND NOT mt.description ILIKE 'N/A' THEN 1\n                         ELSE 0\n                         END) AS transaction_count\n         FROM qualifying_depository qd\n         LEFT JOIN web_db.miser_transaction mt ON qd.depository_id = mt.depository_id\n         GROUP BY 1\n         ),\n      excluded_deposits AS (\n         SELECT depository_id\n              , SUM(COALESCE(amount,0)) AS interest_paid\n         FROM web_db.miser_transaction\n         WHERE description LIKE 'YIELD=%'\n            OR (amount <= 1 AND amount > 0)\n         GROUP BY 1\n         ),\n      failed_transactions AS (\n         SELECT 'r' || depository_id AS unique_account_id\n         FROM web_db.miser_transaction mt\n         INNER JOIN web_db.depository d ON mt.depository_id = d.id AND mt.transaction_date <= DATEADD(dd, 10, inception_date)\n         WHERE description LIKE 'ACH RETURN%'\n            OR description LIKE '%REVERSAL OF ACH%'\n            OR description LIKE '%PAID ACH NSF%'\n            OR description LIKE '%ACH REVERSAL%'\n         GROUP BY 1\n         ),\n      data AS (\n         SELECT a.*\n              , account_number AS radius_account_number\n              , ip.interest_paid\n         FROM (\n            SELECT d.id AS depository_id\n                 , d.inception_date\n                 , MAX(db.current_balance) AS largest_post_30_day_balance\n            FROM failed_transactions ft\n            INNER JOIN web_db.depository d ON 'r' || d.id = ft.unique_account_id\n            LEFT JOIN web_db.depository_balance db\n                      ON d.id = db.depository_id AND db.balance_date >= least(d.inception_date + 30,(\n                         SELECT MAX(balance_date)::DATE\n                         FROM web_db.depository_balance\n                         ))\n            GROUP BY 1\n                   , 2\n            ) a\n         LEFT JOIN excluded_deposits ip ON a.depository_id = ip.depository_id\n         INNER JOIN web_db.user_payment_account upa ON a.depository_id = upa.depository_id\n         ),\n      excluded_accounts AS (\n         SELECT depository_id\n         FROM data\n         WHERE largest_post_30_day_balance <= coalesce(interest_paid,0)\n           AND inception_date >= '2017-12-01'\n\n         UNION\n\n         SELECT qd.depository_id\n         FROM qualifying_depository qd\n         INNER JOIN web_db.depository d ON qd.depository_id = d.id\n         LEFT JOIN active_upa_count auc ON qd.depository_id = auc.depository_id\n         LEFT JOIN transaction_count tc ON qd.depository_id = tc.depository_id\n         WHERE active_upa_count = 0\n           AND transaction_count = 0\n           AND d.inception_date >= '2017-12-01'\n         ),\n      radius_accounts AS (\n         SELECT ua.user_id\n              , d.id AS radius_id\n         FROM web_db.depository d\n         INNER JOIN ua_sec_rem ua ON ua.account_id = d.account_id\n         INNER JOIN web_db.account a ON a.id = d.account_id\n         LEFT JOIN excluded_accounts ea ON ea.depository_id = d.id\n         WHERE a.custodian_id = 2\n           AND d.product_id = 3\n           AND ea.depository_id IS NULL\n           AND d.inception_date IS NOT NULL\n         ),\n      galileo_accounts AS (\n         SELECT ua.user_id\n              , d.id AS galileo_id\n              , depo.galileo_save_id\n              , d.inception_date AS galileo_inception_date\n              , case\n                      when d.account_approved_time is null then d.INCEPTION_DATE\n                      when d.account_approved_time::date != d.INCEPTION_DATE then d.INCEPTION_DATE\n                      else d.account_approved_time\n                 end as account_approved_time\n              , CASE WHEN d.product_id = 4 AND depo.account_id IS NOT NULL THEN d.inception_date\n                     ELSE NULL\n                     END AS spend_enable_date\n\n         FROM (\n            SELECT id\n                 , account_id\n                 , product_id\n                 , min(inception_date) OVER (PARTITION BY account_id ORDER BY inception_date asc nulls last) AS inception_date\n                 , min(ACCOUNT_APPROVED_TIME) OVER (PARTITION BY account_id ORDER BY inception_date asc nulls last) AS ACCOUNT_APPROVED_TIME\n--                 , least(nvl(lead(inception_date) OVER (PARTITION BY account_id ORDER BY product_id),\n--                         inception_date)) AS inception_date\n                 , row_number() OVER (PARTITION BY account_id ORDER BY product_id, id) AS rowNum\n            FROM web_db.depository\n            WHERE product_id IN (4,5)\n            ) AS d\n         INNER JOIN ua_sec_rem ua ON ua.account_id = d.account_id\n         INNER JOIN web_db.account a ON a.id = d.account_id\n         LEFT JOIN (\n            SELECT id AS galileo_save_id\n                 , account_id\n                 , inception_date\n                 , row_number() OVER (PARTITION BY account_id ORDER BY id) AS rowNum\n            FROM web_db.depository\n            WHERE product_id = 5\n            ) depo ON depo.account_id = d.account_id AND depo.rowNum = 1\n         WHERE a.custodian_id = 3\n           AND d.rowNum = 1\n--\t\t\tAND d.product_id = 4\n--\t\t\tAND d.inception_date IS NOT NULL -- termporary fix until soft eng fixes inception_date for migrated accounts\n         ),\n      account_map AS (\n         SELECT COALESCE(r.user_id,g.user_id) AS user_id\n              , r.radius_id\n              , g.galileo_id\n              , g.galileo_save_id\n              , COALESCE('r' || r.radius_id,'') || COALESCE('g' || g.galileo_id,'') AS unique_account_id\n              , g.galileo_inception_date\n              , g.account_approved_time\n              , g.spend_enable_date\n         FROM radius_accounts r\n         FULL OUTER JOIN galileo_accounts g ON r.user_id = g.user_id\n         ),\n     galileo_initial_posted AS (\n         SELECT pt.depository_id\n              , d.ACCOUNT_ID\n              , pt.amount\n              , pt.post_date::timestamptz as post_date\n              , ROW_NUMBER() OVER (PARTITION BY d.ACCOUNT_ID ORDER BY pt.transaction_date,pt.id) AS rn\n         FROM web_db.posted_transaction pt\n         join WEB_DB.GALILEO_POSTED_TRANSACTION gpt on pt.id = gpt.POSTED_TRANSACTION_ID\n         JOIN WEB_DB.DEPOSITORY d on pt.DEPOSITORY_ID = d.ID\n         WHERE gpt.TRANSACTION_CODE_TYPE != 'PMDV'\n           AND NOT ((pt.description ILIKE '%verif%' OR pt.description ILIKE '%trial%cred%') AND pt.amount < 1) \n           AND pt.amount > 0\n         ),\n      radius_initial_posted AS (\n         SELECT mt.depository_id\n              , mt.amount\n              , mt.posting_date\n              , ROW_NUMBER() OVER (PARTITION BY mt.depository_id ORDER BY mt.transaction_date, mt.id) AS rn\n         FROM web_db.miser_transaction mt\n         WHERE NOT ((description ILIKE '%verif%' OR description ILIKE '%trial%cred%') AND mt.amount < 1)\n           AND mt.amount > 0\n         ),\n      initial_posted_amount_galileo AS (\n          SELECT gip.depository_id\n               , depo.ACCOUNT_ID\n               , depo.product_id\n               , gip.amount    AS initial_transfer_posted_amount\n               , gip.post_date AS initial_transfer_posted_date\n          FROM galileo_initial_posted gip\n                   JOIN web_db.depository depo ON gip.depository_id = depo.id\n          WHERE rn = 1\n      ),\n      initial_posted_amount_radius AS (\n         SELECT rip.depository_id\n              , NULL AS product_id\n              , rip.amount initial_transfer_posted_amount\n              , rip.posting_date AS initial_transfer_posted_date\n         FROM radius_initial_posted rip\n         JOIN web_db.depository depo ON rip.depository_id = depo.id\n         WHERE rn = 1\n         ),\n      current_fee AS (\n         SELECT depository_id\n              , fee_amount\n         FROM (\n            SELECT depository_id\n                 , fee_amount\n                 , row_number() OVER (PARTITION BY depository_id ORDER BY date_created DESC NULLS LAST) row_num\n            FROM web_db.depository_fee_history\n            ) AS a\n         WHERE row_num = 1\n         ),\n      initial_recurring_transfer AS (\n         --if spend/save, only pull initial recurring data from spend record\n         SELECT account_id\n              , product_id\n              , sum(CASE initial_recurring_frequency WHEN 'weekly' THEN 4\n                                                     WHEN 'biweekly' THEN 2\n                                                     WHEN 'monthly' THEN 1\n                                                     END * initial_recurring_amount) AS initial_recurring_amount\n         FROM web_db.user_product_application upa_recur\n         WHERE nullif(initial_recurring_amount,0) IS NOT NULL\n           AND account_id IS NOT NULL\n           AND (product_id = 4 OR (product_id = 5 AND NOT exists(SELECT 1\n                                                                 FROM web_db.user_product_application upa_save\n                                                                 WHERE product_id = 4\n                                                                   AND upa_save.account_id = upa_recur.account_id)))\n         GROUP BY 1\n                , 2\n         ),\n      recurring_transfer AS (\n         SELECT rd.account_id\n              , rd.product_id\n              , sum(CASE WHEN rt.type = 'Deposit' THEN\n                               CASE rt.frequency WHEN 'weekly' THEN 4 WHEN 'biweekly' THEN 2 WHEN 'monthly' THEN 1 END *\n                               (rt.amount / 100.00)\n                         END) AS recurring_deposit\n              , sum(CASE WHEN rt.type = 'Withdrawal' THEN\n                               CASE rt.frequency WHEN 'weekly' THEN 4 WHEN 'biweekly' THEN 2 WHEN 'monthly' THEN 1 END *\n                               (rt.amount / 100.00)\n                         END) AS recurring_withdrawal\n         FROM web_db.recurring_transfer rt\n         JOIN web_db.depository rd ON rt.depository_id = rd.id\n         WHERE rt.enabled = TRUE\n         GROUP BY 1\n                , 2\n         ),\n      valid_joint_accounts AS (\n         SELECT ua.account_id\n              , count(1) cnt\n         FROM web_db.user_account ua\n         JOIN web_db.depository d ON ua.account_id = d.account_id\n         JOIN web_db.account a ON ua.account_id = a.id\n         WHERE product_id IN (4,5)\n           AND ua.user_account_type = 2\n         GROUP BY ua.account_id\n         HAVING cnt >= 2\n         ),\n      joint_account_secondary_holders AS (\n         SELECT d.id AS depository_id\n              , ua.account_id\n              , ua.user_id\n              , ga.pmt_ref_no AS spend_galileo_prn\n              , row_number() OVER (PARTITION BY ua.user_id ORDER BY ga.created_at ASC NULLS LAST) AS row_num\n         FROM web_db.depository d\n         JOIN web_db.user_account ua ON d.account_id = ua.account_id\n         JOIN aog_db.galileo_accounts ga ON ga.aspiration_user_id = ua.user_id\n         JOIN web_db.user_product_application upa ON upa.id = ga.aspiration_application_id\n         WHERE d.account_id IN (\n            SELECT account_id\n            FROM valid_joint_accounts\n            )\n           AND ua.user_account_type = 2\n           AND upa.account_type_id = 5\n           AND d.product_id = 4 --spend\n         ),\n      pp_subscribe AS (\n         SELECT account_id\n         FROM web_db.subscription\n         WHERE plan_id ILIKE 'planet%protection%'\n           AND status = 'active'\n         GROUP BY 1\n         ),\n      wallet_activation AS (\n         SELECT prn\n              , event_date\n              , mobile_payment_type\n              , row_number() OVER (PARTITION BY prn, mobile_payment_type ORDER BY event_date DESC NULLS LAST) AS rn\n         FROM rdl.galileo_mobile_payments\n         WHERE event_type = 'Activation'\n           AND mobile_payment_type IN ('Google Inc.','Samsung Corporation','Apple Inc.')\n         ),\n      digital_wallet_activation_data AS (\n         SELECT prn::varchar as prn\n              , event_date\n              , mobile_payment_type\n         FROM wallet_activation\n         WHERE rn = 1\n         ),\n      vcards AS (\n         SELECT vdc.account_id\n              , min(gpt.post_date) AS first_transaction_date\n         FROM bank_db.debit_card vdc\n         LEFT JOIN web_db.galileo_posted_transaction gpt ON gpt.prn = vdc.prn\n         WHERE vdc.virtual\n           AND vdc.current_status = 'activated'\n         GROUP BY vdc.account_id\n         ),\n      psh AS (\n        SELECT user_id, paused FROM (SELECT user_id,\n           paused,\n           row_number() OVER (PARTITION BY USER_ID ORDER BY UPDATED_AT DESC) AS row_num\n      FROM adw.bank_db.PYC_SETTING_HISTORY) WHERE row_num=1\n        ),\n      daw_last_rows as (\n        select\n            UNIQUE_ACCOUNT_ID,\n            max(date) as max_date\n        from rdl.DT_ACCOUNT_90_DAY_WINDOW_DATA dadd\n        group by UNIQUE_ACCOUNT_ID\n      ),\n      daw as (\n        select\n            daw.UNIQUE_ACCOUNT_ID,\n            daw.DATE,\n            daw.inactive_debit,\n            daw.INACTIVE_DEBIT_DEPOSIT,\n            daw.INACTIVE_NONINTEREST_REVENUE\n        from rdl.DT_ACCOUNT_90_DAY_WINDOW_DATA daw\n        join daw_last_rows lr on daw.UNIQUE_ACCOUNT_ID=lr.UNIQUE_ACCOUNT_ID and daw.DATE=lr.max_date\n      ),\n      consolidated_data AS (\n         SELECT am.unique_account_id\n              , am.user_id\n              , 'Checking' AS account_type\n              , coalesce(r.inception_date,am.galileo_inception_date) AS inception_date\n              , coalesce(r.account_approved_time, am.account_approved_time) as inception_date_time\n              , CASE WHEN am.radius_id IS NOT NULL THEN g.date_created END AS migration_date\n              , coalesce(upa_r.funding_amount,CASE WHEN upa_g.STRIPE_FUNDING_AMOUNT > 0 THEN upa_g.STRIPE_FUNDING_AMOUNT\n                                                   WHEN upa_g.funding_amount <= 250000.0 THEN upa_g.funding_amount\n                                                   ELSE 0.0\n                                                   END) AS funding_amount\n              , coalesce(upa_r.fee_amount,upa_g.fee_amount) AS opening_monthly_usd_fee_setting\n              , (coalesce(upa_r.fee_amount,upa_g.fee_amount) * 12) / (nullif(1.0 * coalesce(upa_r.funding_amount,CASE WHEN upa_g.STRIPE_FUNDING_AMOUNT > 0 THEN upa_g.STRIPE_FUNDING_AMOUNT\n                                                   WHEN upa_g.funding_amount <= 250000.0 THEN upa_g.funding_amount\n                                                   ELSE 0.0\n                                                   END),\n                                                                             0)) AS opening_yearly_percent_fee_setting\n              , coalesce(cf_g.fee_amount,cf_a.fee_amount,0) AS current_monthly_usd_fee_setting\n              , NULL AS current_yearly_percent_fee_setting\n              , coalesce(upa_r.user_bank_account_id,upa_g.user_bank_account_id) AS funding_bank_account_id\n              , coalesce(upa_r.ip_address,upa_g.ip_address) AS application_ip_address\n              , coalesce(upa_r.date_created,CASE WHEN g.product_id = 5\n                                                    THEN NULL -- temporary make it null to be able to find save only accounts\n                                                 ELSE upa_g.date_created\n                                                 END) AS application_created_datetime\n              , CASE WHEN g.id IS NOT NULL THEN gdclosed.termination_date::DATE\n                     ELSE r_a.termination_date::DATE\n                     END AS termination_date\n              , coalesce(gd.current_balance,g.current_balance,CASE\n            -- nullify balance when it is post termination date\n            WHEN CURRENT_DATE <= r_a.termination_date::DATE THEN r.current_balance\n            ELSE 0\n            END) AS current_balance\n              , gd.spend_current_balance\n              , gd.save_current_balance\n              , NULL AS initial_monthly_recurring_investment_amount\n              , NULL AS current_monthly_recurring_investment_amount\n              , radius_id\n              , galileo_id\n              , g.account_id AS galileo_account_id\n              , NULL AS investment_id\n              , CASE WHEN g.id IS NULL THEN CASE WHEN r_ua.account_id IS NOT NULL THEN TRUE ELSE FALSE END\n                     ELSE CASE WHEN jash.account_id IS NOT NULL THEN TRUE ELSE FALSE END\n                     END AS is_joint_account\n              , jash.user_id AS joint_account_secondary_user_id\n              , jash.spend_galileo_prn AS joint_account_secondary_spend_galileo_prn\n              , gd.save_galileo_prn AS joint_account_secondary_save_galileo_prn\n              , dwad_joint_account_apple.event_date AS joint_account_apple_pay_activation_date\n              , dwad_joint_account_google.event_date AS joint_account_google_pay_activation_date\n              , dwad_joint_account_samsung.event_date AS joint_account_samsung_pay_activation_date\n              , upa.account_number AS summit_account_number\n              , CASE WHEN b.account_number IS NULL THEN FALSE ELSE TRUE END AS is_charged_off\n              , NULL::VARCHAR(100) AS most_recent_charged_off_date\n              , b.chargeoff_reason\n              , b.total_amount_charged_off\n              , b.hard_loss_charge_off\n              , b.fees_charged_off\n              , CASE WHEN ex.depository_id IS NULL THEN FALSE ELSE TRUE END AS is_ineligible_for_migration\n              , coalesce(g_a.is_admin_disabled,r_a.is_admin_disabled) AS is_admin_disabled\n              , gd.spend_galileo_prn\n              , gd.save_galileo_prn\n              , gd_dbt_act.debit_card_activation_date\n              , gd_dbt_ship.debit_card_shipping_date\n              , CASE WHEN gd_dbt_act.debit_card_activation_date >= gd_dbt_ship.debit_card_shipping_date THEN datediff(\n                 DAY,gd_dbt_ship.debit_card_shipping_date,gd_dbt_act.debit_card_activation_date)\n                     ELSE NULL\n                     END AS debit_card_days_to_activation\n              , gd_vir_act.virtual_card_activation_date\n              , am.spend_enable_date AS spend_enable_date\n              , am.galileo_save_id\n              , init_recur_spend.initial_recurring_amount AS signup_scheduled_spend_monthly_recurring_deposit\n              , init_recur_save.initial_recurring_amount AS signup_scheduled_save_monthly_recurring_deposit\n              , recur_spend.recurring_deposit AS current_scheduled_spend_monthly_recurring_deposit\n              , recur_spend.recurring_withdrawal AS current_scheduled_spend_monthly_recurring_withdrawal\n              , recur_save.recurring_deposit AS current_scheduled_save_monthly_recurring_deposit\n              , recur_save.recurring_withdrawal AS current_scheduled_save_monthly_recurring_withdrawal\n              , COALESCE(ipa_radius.initial_transfer_posted_amount,\n                         ipa_galileo.initial_transfer_posted_amount) AS initial_transfer_posted_amount\n              , COALESCE(ipa_radius.initial_transfer_posted_date,\n                         ipa_galileo.initial_transfer_posted_date) AS initial_transfer_posted_date\n              , CASE WHEN pp_subscribe.account_id IS NULL THEN FALSE ELSE TRUE END AS current_planet_protection_subscription\n              , dwad_apple.event_date AS apple_pay_activation_date\n              , dwad_google.event_date AS google_pay_activation_date\n              , dwad_samsung.event_date AS samsung_pay_activation_date\n              , vcards.account_id IS NOT NULL AS virtual_card_activated\n              , vcards.first_transaction_date IS NOT NULL AS virtual_card_used\n              , psh.PAUSED AS is_pyc_paused\n              , daw.INACTIVE_DEBIT\n              , daw.INACTIVE_DEBIT_DEPOSIT\n              , daw.INACTIVE_NONINTEREST_REVENUE\n\n         FROM account_map am\n         LEFT JOIN (\n            select\n                r.id,\n                r.ACCOUNT_ID,\n                r.PRODUCT_ID,\n                r.CURRENT_BALANCE,\n                r.INCEPTION_DATE,\n                case\n                  when r.account_approved_time is null then r.INCEPTION_DATE\n                  when r.account_approved_time::date != r.INCEPTION_DATE then r.INCEPTION_DATE\n                  else r.account_approved_time\n                end as account_approved_time\n            from WEB_DB.DEPOSITORY r\n         ) r ON r.id = am.radius_id\n         LEFT JOIN web_db.depository g ON g.id = am.galileo_id\n         LEFT JOIN vcards ON vcards.account_id = g.account_id\n         LEFT JOIN web_db.user_product_application upa_r\n                   ON upa_r.user_id = am.user_id AND upa_r.product_id = r.product_id AND upa_r.status IN (3,4) AND\n                      r.account_id = upa_r.account_id\n         LEFT JOIN web_db.user_product_application upa_g\n                   ON upa_g.user_id = am.user_id AND upa_g.product_id = g.product_id AND upa_g.status IN (3,4) AND\n                      g.account_id = upa_g.account_id\n         LEFT JOIN web_db.account r_a ON r_a.id = r.account_id\n         LEFT JOIN web_db.account g_a ON g_a.id = g.account_id\n         LEFT JOIN current_fee cf_a ON cf_a.depository_id = am.radius_id\n         LEFT JOIN current_fee cf_g ON cf_g.depository_id = am.galileo_id\n         LEFT JOIN initial_posted_amount_galileo ipa_galileo ON g_a.ID = ipa_galileo.ACCOUNT_ID\n         LEFT JOIN initial_posted_amount_radius ipa_radius ON ipa_radius.depository_id = am.radius_id\n         LEFT JOIN (\n            SELECT p.user_id\n                 , SUM(rgcmd.current_balance) AS current_balance\n                 , MAX(CASE WHEN rgcmd.type_of_account = '6' THEN rgcmd.current_balance END) AS spend_current_balance\n                 , MAX(CASE WHEN rgcmd.type_of_account = '8' THEN rgcmd.current_balance END) AS save_current_balance\n                 , MAX(CASE WHEN rgcmd.type_of_account = '6' THEN p.prn END) AS spend_galileo_prn\n                 , MAX(CASE WHEN rgcmd.type_of_account = '8' THEN p.prn END) AS save_galileo_prn\n\n            FROM (\n               SELECT t.galileo_account_id\n                    , t.type_of_account\n                    , CONCAT(t.current_balance_sign,t.current_balance::decimal(13,2))::DEC(18,2) AS current_balance\n                    , ROW_NUMBER() OVER (PARTITION BY t.galileo_account_id ORDER BY t.file_date DESC) AS rn\n               FROM rdl.raw_galileo_customer_master_data t\n               ) AS rgcmd\n            INNER JOIN rdl.VW_USER_PRN p ON (p.galileo_account_id = rgcmd.galileo_account_id)\n            WHERE rgcmd.rn = 1\n            GROUP BY p.user_id\n            ) AS gd ON (gd.user_id = am.user_id)\n\n         LEFT JOIN (\n            WITH\n               cte_ship_date AS (\n                    SELECT acd.prn\n                         , acd.file_date\n                         , acd.card_id\n                         , case when card_active.CARD_ID is not null then 1 else 0 end as activation_flag\n                         , row_number()\n                            OVER (PARTITION BY acd.prn ORDER BY activation_flag desc nulls last,\n                                                                acd.file_date ASC NULLS LAST) AS row_num\n                    FROM rdl.raw_galileo_account_card_data acd\n                             INNER JOIN rdl.raw_galileo_customer_master_data cmd\n                                        ON (cmd.galileo_account_id = acd.galileo_account_id)\n                             left join (select CARD_ID\n                                        from rdl.raw_galileo_account_card_data\n                                        where status = 'N'\n                                        group by 1) card_active on acd.CARD_ID = card_active.CARD_ID\n                    WHERE cmd.type_of_account = '6'\n                      AND acd.status = 'Y'\n                      AND acd.TYPE_OF_CARD != '25' --not virtual\n                  )\n            SELECT prn\n                 , file_date AS debit_card_shipping_date\n                 , card_id\n            FROM cte_ship_date\n            WHERE row_num = 1\n            ) AS gd_dbt_ship ON (gd_dbt_ship.prn = gd.spend_galileo_prn)\n\n         LEFT JOIN digital_wallet_activation_data dwad_apple\n                   ON dwad_apple.prn = gd.spend_galileo_prn AND dwad_apple.mobile_payment_type = 'Apple Inc.'\n         LEFT JOIN digital_wallet_activation_data dwad_google\n                   ON dwad_google.prn = gd.spend_galileo_prn AND dwad_google.mobile_payment_type = 'Google Inc.'\n         LEFT JOIN digital_wallet_activation_data dwad_samsung ON dwad_samsung.prn = gd.spend_galileo_prn AND\n                                                                  dwad_samsung.mobile_payment_type = 'Samsung Corporation'\n\n         LEFT JOIN (\n            SELECT acd.prn\n                 , acd.card_id\n                 , min(acd.file_date) AS debit_card_activation_date\n            FROM rdl.raw_galileo_account_card_data acd\n            INNER JOIN rdl.raw_galileo_customer_master_data cmd ON (cmd.galileo_account_id = acd.galileo_account_id)\n            WHERE cmd.type_of_account = '6'\n              AND acd.status = 'N'\n              AND acd.TYPE_OF_CARD != '25' --not virtual\n            GROUP BY 1\n                   , 2\n            ) AS gd_dbt_act ON gd_dbt_ship.prn = gd_dbt_act.prn AND gd_dbt_ship.card_id = gd_dbt_act.card_id\n\n        LEFT JOIN (\n            SELECT ga.ASPIRATION_USER_ID\n                 , min(acd.file_date) AS virtual_card_activation_date\n            FROM rdl.raw_galileo_account_card_data acd\n            JOIN AOG_DB.GALILEO_ACCOUNTS ga ON ga.GALILEO_ACCOUNT_NUMBER = acd.galileo_account_id\n            WHERE acd.status = 'N'\n              AND acd.TYPE_OF_CARD = '25' --virtual\n            GROUP BY 1\n           ) as gd_vir_act ON gd_vir_act.ASPIRATION_USER_ID = am.user_id\n\n         LEFT JOIN tmp_galileo_termination gdclosed ON gdclosed.aspiration_account_number = g_a.account_number\n\n         LEFT JOIN (\n            SELECT DISTINCT account_id\n            FROM ua_sec_rem\n            WHERE user_account_type = 2\n            ) r_ua ON r_a.id = r_ua.account_id\n         LEFT JOIN (\n            SELECT DISTINCT account_id\n            FROM ua_sec_rem\n            WHERE user_account_type = 2\n            ) g_ua ON g_a.id = g_ua.account_id\n         LEFT JOIN web_db.user_payment_account upa ON upa.depository_id = r.id AND upa.user_id = am.user_id\n         LEFT JOIN joint_account_secondary_holders jash ON g.account_id = jash.account_id AND jash.row_num = 1\n         LEFT JOIN web_db.dt_input_fraud_users b ON upa.account_number = b.account_number :: TEXT\n         LEFT JOIN web_db.dt_input_radius_accounts ex ON ex.depository_id = am.radius_id\n         LEFT JOIN initial_recurring_transfer init_recur_spend\n                   ON init_recur_spend.account_id = g.account_id AND init_recur_spend.product_id = 4\n         LEFT JOIN initial_recurring_transfer init_recur_save\n                   ON init_recur_save.account_id = g.account_id AND init_recur_save.product_id = 5\n         LEFT JOIN recurring_transfer recur_spend\n                   ON recur_spend.account_id = g.account_id AND recur_spend.product_id = 4\n         LEFT JOIN recurring_transfer recur_save ON recur_save.account_id = g.account_id AND recur_save.product_id = 5\n         LEFT JOIN pp_subscribe ON pp_subscribe.account_id = g.account_id\n         LEFT JOIN digital_wallet_activation_data dwad_joint_account_apple\n                   ON dwad_joint_account_apple.prn = jash.spend_galileo_prn AND\n                      dwad_joint_account_apple.mobile_payment_type = 'Apple Inc.'\n         LEFT JOIN digital_wallet_activation_data dwad_joint_account_google\n                   ON dwad_joint_account_google.prn = jash.spend_galileo_prn AND\n                      dwad_joint_account_google.mobile_payment_type = 'Google Inc.'\n         LEFT JOIN digital_wallet_activation_data dwad_joint_account_samsung\n                   ON dwad_joint_account_samsung.prn = jash.spend_galileo_prn AND\n                      dwad_joint_account_samsung.mobile_payment_type = 'Samsung Corporation'\n         LEFT JOIN psh on psh.USER_ID=am.user_id\n         LEFT JOIN daw on daw.unique_account_id=am.unique_account_id\n\n         UNION ALL\n\n         SELECT 'i' || i.id AS unique_account_id\n              , ua.user_id\n              , CASE WHEN i.fund_id = 1 AND a.account_type_id = 2 THEN 'Flagship Individual'\n                     WHEN i.fund_id = 1 AND a.account_type_id = 3 THEN 'Flagship IRA'\n                     WHEN i.fund_id = 2 AND a.account_type_id = 2 THEN 'Redwood Individual'\n                     WHEN i.fund_id = 2 AND a.account_type_id = 3 THEN 'Redwood IRA'\n                     END AS account_type\n              , i.inception_date\n              , i.inception_date -- inception_date_time\n              , NULL AS migration_date\n              , upa.funding_amount\n              , (upa.fee_amount * upa.funding_amount) / 12.0 AS opening_monthly_usd_fee_setting\n              , upa.fee_amount AS opening_yearly_percent_fee_setting\n              , (i.current_value * i.fee_pct) / 12.0 AS current_monthly_usd_fee_setting\n              , NULL AS current_yearly_percent_fee_setting\n              , upa.user_bank_account_id AS funding_bank_id\n              , upa.ip_address AS application_ip_address\n              , upa.date_created AS application_created_datetime\n              , a.termination_date\n              , i.current_value::numeric(38,4) AS current_balance\n              , NULL::numeric(20,2) AS spend_current_balance\n              , NULL::numeric(20,2) AS save_current_balance\n              , COALESCE(CASE WHEN recurring_frequency = 1 THEN recurring_amount\n                              WHEN recurring_frequency = 2 THEN 4 * recurring_amount\n                              WHEN recurring_frequency = 3 THEN 2 * recurring_amount\n                              END,0) AS initial_monthly_recurring_investment_amount\n              , coalesce(CASE WHEN b.is_disabled = TRUE OR cancel_date IS NOT NULL THEN 0\n                              WHEN frequency = 1 THEN amount\n                              WHEN frequency = 2 THEN 4 * amount\n                              WHEN frequency = 3 THEN 2 * amount\n                              END,0.0) AS current_monthly_recurring_investment_amount\n              , NULL AS radius_id\n              , NULL AS galileo_id\n              , NULL AS galileo_account_id\n              , i.id AS investment_id\n              , NULL AS is_joint_account\n              , NULL AS joint_account_secondary_user_id\n              , NULL AS joint_account_secondary_spend_galileo_prn\n              , NULL AS joint_account_secondary_save_galileo_prn\n              , NULL AS joint_account_apple_pay_activation_date\n              , NULL AS joint_account_google_pay_activation_date\n              , NULL AS joint_account_samsung_pay_activation_date\n              , NULL AS summit_account_number\n              , NULL AS is_charged_off\n              , NULL AS most_recent_charged_off_date\n              , NULL AS chargeoff_reason\n              , NULL AS total_amount_charged_off\n              , NULL AS hard_loss_charge_off\n              , NULL AS fees_charged_off\n              , NULL AS is_ineligible_for_migration\n              , a.is_admin_disabled\n              , NULL AS spend_galileo_prn\n              , NULL AS save_galileo_prn\n              , NULL AS debit_card_activation_date\n              , NULL AS debit_card_shipping_date\n              , NULL AS debit_card_days_to_activation\n              , NULL AS virtual_card_activation_date\n              , NULL AS spend_enable_date\n              , NULL AS galileo_save_id\n              , NULL AS signup_scheduled_spend_monthly_recurring_deposit\n              , NULL AS signup_scheduled_save_monthly_recurring_deposit\n              , NULL AS current_scheduled_spend_monthly_recurring_deposit\n              , NULL AS current_scheduled_spend_monthly_recurring_withdrawal\n              , NULL AS current_scheduled_save_monthly_recurring_deposit\n              , NULL AS current_scheduled_save_monthly_recurring_withdrawal\n              , NULL AS initial_transfer_posted_amount\n              , NULL AS initial_transfer_posted_date\n              , NULL AS currrent_planet_protection_subscription\n              , NULL AS apple_wallet_activation_date\n              , NULL AS google_pay_activation_date\n              , NULL AS samsung_pay_activation_date\n              , NULL AS virtual_card_activated\n              , NULL AS virtual_card_used\n              , NULL AS is_pyc_paused\n              , NULL AS inactive_debit\n              , NULL AS inactive_debit_deposit\n              , NULL AS inactive_noninterest_revenue\n\n         FROM web_db.investment i\n         INNER JOIN web_db.user_account ua ON ua.account_id = i.account_id\n         INNER JOIN web_db.account a ON a.id = i.account_id\n         INNER JOIN web_db.user_product_application upa ON upa.user_id = ua.user_id AND\n                                                           CASE WHEN fund_id = 1 THEN 2 WHEN fund_id = 2 THEN 1 END = upa.product_id AND\n                                                           upa.account_type_id = a.account_type_id\n         LEFT JOIN (\n            SELECT investment_id\n                 , max(id) AS max_id\n            FROM web_db.recurring_order_txn\n            GROUP BY 1\n            ) ab ON ab.investment_id = i.id\n         LEFT JOIN web_db.recurring_order_txn b ON ab.investment_id = b.investment_id AND ab.max_id = b.id\n         WHERE i.inception_date IS NOT NULL\n         )\n\n   SELECT *\n        , CASE WHEN account_creation_order > 1 THEN TRUE ELSE FALSE END AS is_cross_sell_account\n   FROM (\n      SELECT *\n           , RANK()\n             OVER (PARTITION BY user_id ORDER BY inception_date, application_created_datetime) AS account_creation_order\n      FROM consolidated_data\n      ) a\n   WHERE galileo_id is null\n      OR galileo_id not in (select DEPOSITORY_ID from etl.DT_ACCOUNTS_DEPOSITORY_EXCLUSION)\n   );"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022964":{"id":3022964,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-432,"y":-336,"width":32,"height":32,"inputConnectorIDs":[3023048],"outputSuccessConnectorIDs":[3023036],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"no_balance_accounts"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"set timezone = 'America/Los_Angeles';\n\nDROP TABLE IF EXISTS rdl.no_balance_accounts;\nCREATE TABLE rdl.no_balance_accounts\nAS\nwith unfunded as (\n  select *,\n         row_number() over (partition by UNIQUE_ACCOUNT_ID order by GALILEO_SAVE_ID asc nulls last) as rn\n  from bi.DT_ACCOUNTS_WITH_UNFUNDED\n)\n,net_balance as (\n  select dta.UNIQUE_ACCOUNT_ID\n       ,ifnull(sum(dadd.daily_balance), 0) as net_balance\n       ,case when ifnull(sum(ach_deposit_count), 0) = 0 then 'no ach deposit' else 'has ach deposit' end as ach_deposit_boolean\n       ,case when ifnull(sum(ach_withdrawal_count), 0) = 0 then 'no ach withdrawal' else 'has ach withdrawal' end as ach_withdrawal_boolean\n       ,case when ifnull(sum(dbt_card_pin_count), 0) = 0 then 'no dbt card pin transactions' else 'has dbt card pin transaction' end as dbt_card_pin_boolean\n       ,case when ifnull(sum(dbt_card_no_pin_count), 0) = 0 then 'no dbt card no pin transactions' else 'has dbt card no pin transactions' end as dbt_Card_no_pin_boolean\n       ,case when ifnull(sum(check_withdrawal_count), 0) = 0 then 'no checks written' else 'wrote checks' end as check_withdrawal_count_boolean\n       ,case when ifnull(sum(check_deposit_count), 0) = 0 then 'no deposited checks' else 'checks deposited' end as check_deposit_boolean\n  from unfunded dta\n  left join bi.dt_account_daily_data dadd on dta.unique_account_id = dadd.unique_account_id and dadd.date between inception_date and dateadd(day,30,inception_date)\n  where dta.rn = 1\n  group by 1\n)\n,transactions as (\n  select dta.UNIQUE_ACCOUNT_ID\n        ,case when count(unique_transaction_id) = 0\n              then 'has no transactions' else 'has transactions' end as transactions_boolean\n  from unfunded dta\n  left join bi.DT_DEPOSITORY_TRANSACTIONS t on dta.UNIQUE_ACCOUNT_ID = t.UNIQUE_ACCOUNT_ID\n  where dta.rn = 1\n  and dta.INCEPTION_DATE is not null\n  group by 1\n)\n, active_upa_count AS (\n\tSELECT user_id,\n\t\tSUM(CASE\n  \t\t\t\tWHEN upa.is_admin_disabled != TRUE THEN 1\n\t  \t\t\tELSE 0\n\t\t  \tEND) AS active_upa_count\n\tFROM web_db.user_payment_account upa\n\tWHERE upa.depository_id IS NULL\n\tGROUP BY 1\n)\n, avg_plaid as (\n  select user_id,\n         AVG(plaid_identity_total_score * 1.00) as plaid_identity_total_score\n  from bi.DT_BANKS\n  where plaid_identity_total_score is not null\n  group by 1\n)\n, transfers AS (\n  SELECT dtt.unique_account_id,\n         COUNT(*) AS nr_of_transfers,\n         SUM(CASE WHEN dtt.transaction_status = 'Rejected' THEN 1 ELSE 0 END) AS rejected_transfers_count\n  FROM bi.dt_transfers dtt\n  WHERE dtt.category = 'ACH transfer'\n  GROUP BY 1\n)\n select dta.unique_account_id\n        ,case when dta.is_admin_disabled = true then 'admin disabled' else 'admin enabled' end as is_admin_disabled\n        ,case when dta.termination_date is null then 'not terminated' else 'terminated' end as termination_date_boolean\n       ,case when ifnull(current_balance, 0) = 0 then 'no balance' else 'has current balance' end as current_balance_boolean\n       ,case when ifnull(spend_current_balance, 0) = 0 then 'no spend balance' else 'has spend balance' end as spend_current_balance_boolean\n       ,case when ifnull(save_current_balance, 0) = 0 then 'no save balance' else 'has save balance' end as save_current_balance_boolean\n       ,nb.ach_deposit_boolean\n       ,nb.ach_withdrawal_boolean\n       ,nb.dbt_card_pin_boolean\n       ,nb.dbt_Card_no_pin_boolean\n       ,nb.check_withdrawal_count_boolean\n       ,nb.check_deposit_boolean\n      ,  case\n            when galileo_id is not Null then 'is galileo account'\n            when radius_id is not null then 'is radius only account'\n            else 'is investment account'\n          end as account_carrier_check\n       , t.transactions_boolean\n       , dta.is_joint_account\n       , dta.is_charged_off\n       , ifnull(auc.active_upa_count, 0) as active_upa_count\n       , ifnull(tr.nr_of_transfers, 0) as transfers_count\n       , ifnull(tr.rejected_transfers_count,0) AS rejected_transfers_count\n       , p.plaid_identity_total_score\n  from unfunded dta\n  join net_balance nb on dta.UNIQUE_ACCOUNT_ID = nb.UNIQUE_ACCOUNT_ID\n  left join transactions t on t.UNIQUE_ACCOUNT_ID = dta.UNIQUE_ACCOUNT_ID\n  left join active_upa_count auc on dta.user_id = auc.user_id\n  left join transfers tr on tr.unique_account_id = dta.unique_account_id\n  left join avg_plaid p on dta.user_id = p.user_id\n  where dta.rn = 1\n  and nb.net_balance = 0;"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022965":{"id":3022965,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":48,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023033],"outputSuccessConnectorIDs":[3023031],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"create adhoc views"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"-- who had DD in the last 3 months and Radius account is still not closed\ncreate or replace view rdl.migrated_customers_with_open_radius_dd_last_3_months\nas\nSELECT users.user_email  AS \"users.user_email\"\nFROM bi.dt_depository_transactions  AS depository_transactions\nLEFT JOIN bi.dt_accounts  AS accounts ON accounts.unique_account_id = depository_transactions.unique_account_id\ninner join web_db.depository d on (d.id = accounts.radius_id)\ninner join web_db.account a on (a.id = d.account_id)\nLEFT JOIN bi.dt_users  AS users ON accounts.user_id = users.user_id\n\nWHERE ((((depository_transactions.transaction_date ) >= ((DATEADD(month,-2, DATE_TRUNC('month', DATE_TRUNC('day',current_date)) )))\n\tAND (depository_transactions.transaction_date ) < ((DATEADD(month,3, DATEADD(month,-2, DATE_TRUNC('month', DATE_TRUNC('day',current_date)) ) ))))))\n\tAND depository_transactions.direct_deposit_ind\n\tAND (depository_transactions.unique_account_id LIKE '%g%')\n\tAND (((CASE WHEN accounts.account_type = 'Checking' THEN 'Depository' ElSE 'Investment' END) = 'Depository'))\n\tand a.account_status_type != 3\nGROUP BY 1\nORDER BY 1\n;\n\n-- drop view if exists rdl.nrt_new_cma_accounts_by_date;\ncreate or replace view rdl.nrt_new_cma_accounts_by_date\nas\nselect g.account_approved_time\nfrom web_db.depository g\nwhere 1=1\n\tand g.product_id = 5\n\tand g.account_approved_time is not null\n;\n\n--customers who had a Radius account who re-signed up to have a Galileo account\ncreate or replace view rdl.resigned_up_customers\nas\nwith cte_radius as (\n  select distinct upa.user_id\n  from web_db._user u\n  join web_db.user_product_application upa on u.id = upa.user_id\n  join web_db.depository d on upa.account_id = d.account_id\n  join web_db.product p on d.product_id = p.id and upa.product_id = p.id\n  where p.name = 'Summit'\n  ),\ncte_resigned_up as (\n  select dtu.user_id,\n         dtu.user_email,\n         p.name         as account,\n         up.name        as linked_funding_account,\n         upa.funding_amount,\n         upa.fee_amount as pwif,\n         d.inception_date,\n         dta.spend_current_balance,\n         dta.save_current_balance\n  from cte_radius r\n         join bi.dt_users dtu on r.user_id = dtu.user_id\n         join web_db.user_product_application upa on dtu.user_id = upa.user_id\n         join web_db.depository d on upa.account_id = d.account_id\n         join web_db.product p on d.product_id = p.id and upa.product_id = p.id\n         left join web_db.user_payment_account up on upa.user_bank_account_id = up.id\n         left join bi.dt_accounts dta on dtu.user_id = dta.user_id and dta.account_type = 'Checking'\n  where p.name = 'Summit CMA'\n),\ncte_linked as (\n  select cru.user_id,\n         listagg(distinct upa.name, ', ') within group (order by upa.name) as accounts_linked_since_inception\n  from cte_resigned_up cru\n  join web_db.user_payment_account upa on cru.user_id = upa.user_id\n  where upa.date_created::date >= cru.inception_date\n  group by 1\n)\nselect cru2.*,\n       cl.accounts_linked_since_inception\nfrom cte_resigned_up cru2\nleft join cte_linked cl on cru2.user_id = cl.user_id\n;\n\ncreate or replace view rdl.joint_account_invitation_overview\nas\nselect\n-- \ttop 1000\n-- \t*\n\tjai.primary_user_id, jai.secondary_user_email, jai.secondary_user_id, jai.notified_at, jai.accepted_at, jai.cancelled_at,\n\n\tcase\n\t\twhen jai.status = 0 then 'Pending'\n\t\twhen jai.status = 1 then 'Notified'\n\t\twhen jai.status = 2 then 'Accepted'\n\t\twhen jai.status = 3 then 'Cancelled'\n\t\twhen jai.status = 4 then 'Approved'\n\t\twhen jai.status = 5 then 'Declined'\n\t\telse 'Unknown'\n\tend as joint_account_invitation_status,\n\n\tcase\n\t\twhen upa.status = 0 then 'Undefined'\n\t\twhen upa.status = 1 then 'New Application'\n\t\twhen upa.status = 2 then 'Unconfirmed'\n\t\twhen upa.status = 3 then 'Submitted'\n\t\twhen upa.status = 4 then 'Approved'\n\t\twhen upa.status = 5 then 'Rejected'\n\t\twhen upa.status = 6 then 'Cancelled'\n\t\twhen upa.status = 7 then 'Pending'\n\t\twhen upa.status = 8 then 'Pending Error'\n\t\twhen upa.status = 9 then 'Pending Reconciliation'\n\t\twhen upa.status = 10 then 'Started Migration'\n\t\twhen upa.status = 11 then 'Migrating'\n\t\telse 'Unknown'\n\tend as joint_account_application_status,\n\n\tcase\n\t\twhen aef.\"alloy summary_outcome\" = 'Manual Review' then aef.\"alloy summary_outcome\" || ' - ' || IFNULL(aerf.outcome, 'Unknown Review Status')\n\t\twhen aef.\"alloy summary_outcome\" is not null then aef.\"alloy summary_outcome\"\n\t\telse 'Unknown'\n\tend as joint_account_application_alloy_outcome\n\n-- \tjai.*, upa.*\n-- \tjai.primary_user_id, count(*)\n-- \tjai.status, upa.status, aef.\"alloy summary_outcome\", aerf.outcome, count(*)\nfrom web_db.joint_account_invitation jai\nleft join web_db.user_product_application upa on (upa.id = jai.secondary_user_product_application_id)\nleft join aoa_db.alloy_evaluations ae on (ae.user_product_application_id = jai.secondary_user_product_application_id)\nleft join rdl.alloy_evaluations_flattened aef on (aef.evaluation_id = ae.id)\nleft join aoa_db.evaluation_reviews er on (er.alloy_evaluation_id = ae.id)\nleft join rdl.alloy_evaluation_reviews_flattened aerf on (aerf.evaluation_review_id = er.id)\nwhere 1=1\n\tand jai.date_created >= '2019-06-24'\n-- \tand jai.primary_user_id = 62658\n-- \tand jai.status = 2\n-- group by\n-- \tjai.primary_user_id\n-- \tjai.status, upa.status, aef.\"alloy summary_outcome\", aerf.outcome\n-- having count(*) > 1\n-- order by jai.id desc\n;\n\n\nDROP VIEW IF EXISTS rdl.vw_user_charity_payments;\ncreate view rdl.vw_user_charity_payments as\nSELECT ucfg.id                            AS unique_charity_id,\n       ucg.user_id,\n       (ucg.giving_date)::date            AS giving_date,\n       cf.name                            AS charity_name,\n       CASE ucg.payment_source\n         WHEN 1 THEN 'Liquidation'\n         WHEN 2 THEN 'ACH'\n         WHEN 3 THEN 'Stripe/CC'\n         WHEN 5 THEN 'Do Good Dollars'\n         ELSE null\n      END::character varying              AS charity_payment_type,\n       ucfg.amount                        AS charity_payment_amount,\n       CASE ucg.status\n         WHEN 0 THEN 'Undefined'\n         WHEN 1 THEN 'New'\n         WHEN 2 THEN 'Processing'\n         WHEN 3 THEN 'Processed'\n         WHEN 4 THEN 'Cancelled'\n         WHEN 5 THEN 'Rejected'\n         ELSE null\n      END::character varying as charity_payment_status\nFROM web_db.user_charity_fund_giving ucfg\nJOIN web_db.user_charity_fund ucf ON ucf.id = ucfg.user_charity_fund_id\nJOIN web_db.user_charity_giving ucg ON ucg.id = ucfg.user_charity_giving_id\nJOIN web_db.charity_fund cf ON cf.id = ucf.charity_fund_id;\n\n--view for operations to track multiple active spend accounts\nDROP VIEW IF EXISTS rdl.vw_multiple_spend_accounts;\ncreate view rdl.vw_multiple_spend_accounts as\nwith cust_master as (\n  select distinct\n    dtu.user_id,\n    dtu.user_email,\n    cm.primary_cardholder_last_name,\n    cm.primary_cardholder_first_name,\n    cm.galileo_account_id,\n    lkp.description as account_status,\n    lkp2.description as product_status,\n    dta.spend_galileo_prn,\n    dta.save_galileo_prn,\n    dta.galileo_id as spend_depository_id,\n    dta.galileo_save_id as save_depository_id ,\n    row_number() over (partition by dtu.user_id, cm.galileo_account_id\n                           order by file_date desc nulls last) as row_num\n  from rdl.raw_galileo_customer_master_data cm\n  join web_db.galileo_lookup lkp ON lkp.code = cm.status AND lkp.field_name = 'STATUS'\n                                and lkp.file = 'C'\n  left join aog_db.galileo_accounts ga ON cm.galileo_account_id = ga.galileo_account_number\n  left join web_db.galileo_lookup lkp2 ON lkp2.code = ga.product_id\n                                      AND lkp2.field_name = 'UNIQUE PRODUCT ID' and lkp2.file = 'C'\n  left join bi.dt_users dtu on ga.aspiration_user_id = dtu.user_id\n  left join bi.dt_accounts dta on dtu.user_id = dta.user_id\n                              and dta.account_type = 'Checking'\n  where cm.type_of_account = 6 --spend\n  and cm.primary_cardholder_last_name is not null\n)\nselect\n  user_email,\n  primary_cardholder_last_name,\n  primary_cardholder_first_name,\n  spend_galileo_prn,\n  save_galileo_prn,\n  spend_depository_id,\n  save_depository_id,\n  count(distinct galileo_account_id) as count_spend_accounts\nfrom cust_master\nwhere row_num = 1\nand account_status = 'Active'\nand lower(product_status) not like '%save%'\nand lower(product_status) not like '%unused%'\ngroup by 1,2,3,4,5,6,7\nhaving count(distinct galileo_account_id) > 1;\n\n--authorized transactions\nDROP VIEW IF EXISTS rdl.vw_authorized_transactions;\ncreate view rdl.vw_authorized_transactions as\n\nselect t.auth_tran_key,\n       t.file_name,\n       t.file_date,\n       t.unique_program_id,\n       t.galileo_account_id,\n       t.card_identifier,\n       t.transaction_date,\n       t.transaction_currency_code,\n       c1.currency_country,\n       c1.currency,\n       t.address_verification_response,\n       t.authorization_response,\n       r.auth_description as authorization_response_description,\n       t.transaction_amount,\n       t.authorization_code,\n       t.network_code,\n       nc.network_name,\n       t.merchant_number,\n       t.merchant_description,\n       t.merchant_category_code,\n       mcc.description    as merchant_category_code_description,\n       t.transaction_code,\n       gl.description     as transaction_code_description,\n       t.merchant_country_code,\n       c2.country         as merchant_country,\n       t.prn,\n       t.posted_transaction_id,\n       t.etl_load_date\nfrom rdl.authorized_transactions t\n         left join rdl.authorization_response r on t.authorization_response = r.auth_code\n         left join rdl.currency c1 on t.transaction_currency_code = c1.numeric_currency_code\n         left join rdl.country c2 on t.merchant_country_code = c2.numeric_code::varchar(100)\n         left join etl.merchant_category_codes mcc on t.merchant_category_code = mcc.merchant_category_code\n         left join rdl.galileo_network_code nc on t.network_code = nc.network_code\n         left join web_db.galileo_lookup gl on t.transaction_code = gl.code\n                                           and gl.field_name = 'TRANSACTION CODE';\n\ndrop view if exists rdl.vw_cached_balance; \ncreate view rdl.vw_cached_balance as \nwith plaid as (\n    select a.id,\n           a.DATE_CREATED,\n           a.USER_PAYMENT_ACCOUNT_ID,\n           a.BALANCE,\n           a.ORIGINAL_BALANCE_RESPONSE,\n           b.LAST_FOUR_DIGITS,\n           parse_json(a.ORIGINAL_BALANCE_RESPONSE) as plaid_source\n    from WEB_DB.cached_balance a\n    left join WEB_DB.USER_PAYMENT_ACCOUNT b on a.USER_PAYMENT_ACCOUNT_ID = b.ID\n)\nselect id as cached_balance_id,\n       USER_PAYMENT_ACCOUNT_ID,\n       case when LAST_FOUR_DIGITS = nullif(trim(value:mask::varchar(10)),'') then true else false end as is_upa_account,\n       DATE_CREATED,\n       nullif(trim(value:mask::varchar(10)),'') as account_mask,\n       nullif(trim(value:name::char(200)),'') as account_name,\n       nullif(trim(value:official_name::char(200)),'') as account_official_name,\n       value:type::varchar(50) as account_type,\n       value:subtype::varchar(50) as account_subtype,\n       value:balances:available::numeric(20,2) as available_balance,\n       value:balances:current::numeric(20,2) as current_balance,\n       value:balances:limit::numeric(20,2) as account_limit\nfrom plaid p, lateral flatten (input => p.plaid_source, path => 'accounts');"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022966":{"id":3022966,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-832,"y":-64,"width":32,"height":32,"inputConnectorIDs":[3023035],"outputSuccessConnectorIDs":[3023001,3023050],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_depository_transactions"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"DROP TABLE IF EXISTS bi_new.dt_depository_transactions CASCADE;\nCREATE TABLE bi_new.dt_depository_transactions\n    AS\n    WITH\nmiser_transactions AS (\n        SELECT depository_id\n            , CASE\n                WHEN upper(description) LIKE '%WIRE FEE%' THEN 'Wire Transfer - Fee'\n                WHEN upper(description) LIKE '%WIRE REV%|%WIRE RETURN%|%RETURN WIRE%' AND amount < 0 THEN 'Wire Transfer - Withdrawal - Reversal'\n                WHEN upper(description) LIKE '%WIRE REV%|%WIRE RETURN%|%RETURN WIRE%' AND amount > 0 THEN 'Wire Transfer - Deposit - Reversal'\n                WHEN upper(description) LIKE '%WIRE IN%|%WIRE OUT%|%INTERNATIONAL WIRE%|%WIRE TRANSFER%|%WIRE-IN%|%INTL WIRE%|%WIRE FEE%|%OUTGOING WIRE%|%INCOMING WIRE%' AND amount > 0 THEN 'Wire Transfer - Deposit'\n                WHEN upper(description) LIKE '%WIRE IN%|%WIRE OUT%|%INTERNATIONAL WIRE%|%WIRE TRANSFER%|%WIRE-IN%|%INTL WIRE%|%WIRE FEE%|%OUTGOING WIRE%|%INCOMING WIRE%' AND description ILIKE '%FEE%' THEN 'Wire Transfer - Fee'\n                WHEN upper(description) LIKE '%WIRE REV%|%WIRE RETURN%|%RETURN WIRE%' THEN 'Wire Transfer - Return'\n                WHEN upper(description) LIKE '%WIRE IN%|%WIRE OUT%|%INTERNATIONAL WIRE%|%WIRE TRANSFER%|%WIRE-IN%|%INTL WIRE%|%WIRE FEE%|%OUTGOING WIRE%|%INCOMING WIRE%' AND description NOT LIKE '%FEE%' AND amount < 0 THEN 'Wire Transfer - Withdrawal'\n                WHEN description = '95' THEN 'ATM Fee Refund'\n                WHEN (description LIKE 'POS %' OR description LIKE 'DBT %') AND amount < 0 AND substring(description, 76, 3) = 'YES' THEN 'Debit Card - PIN'\n                WHEN (description LIKE 'POS %' OR description LIKE 'DBT %') AND amount < 0 THEN 'Debit Card - No PIN'\n                WHEN (description LIKE 'POS %' OR description LIKE 'DBT %') AND amount > 0 THEN 'Debit Card Return'\n                WHEN description LIKE 'ATM%' AND amount > 0 THEN 'ATM Deposit'\n                WHEN description LIKE 'ATM%' AND amount < 0 THEN 'ATM Withdrawal'\n                WHEN (description LIKE '%SR=%') AND amount > 0 THEN 'Check Deposit'\n                WHEN (description LIKE '%SR=%') AND amount < 0 THEN 'Check Withdrawal'\n                WHEN ((upper(description) LIKE '%SUMMIT TIP%' AND amount > 0) OR upper(description) = 'PWIF REBATE' OR description LIKE 'Aspiration Partn ACH Credit%') AND amount < 100 THEN 'Fee Rebate'\n                WHEN upper(description) LIKE '%SUMMIT TIP%' OR description = 'ASPIRATION FEE' THEN 'PWIF Payment'\n                WHEN description LIKE 'YIELD%' THEN 'Interest Payment'\n                WHEN amount > 0 THEN 'ACH Deposit' ELSE 'ACH Withdrawal'\n                END AS transaction_type\n            , coalesce(display_line, description) AS description\n            , amount\n            , mt.id AS miser_transaction_id\n            , transaction_date::DATE as miser_transaction_date\n            , mt.posting_date::date AS post_date\n            , CASE WHEN company_aim_score_id IS NULL THEN FALSE ELSE TRUE END AS is_aim_scored\n            , CASE WHEN company_aim_score_id IS NOT NULL THEN c.display_name ELSE NULL END AS aim_company\n            , people AS aim_people_score\n            , planet AS aim_planet_score\n            , cp.conscience_coalition_merchant\n            , c.id as merchant_id\n            , c.name as merchant_name\n            , case when d.product_id in (3,4) then 'Spend'\n                   when d.product_id = 5 then 'Save'\n                   else null\n              end as account_product_type\n        FROM web_db.miser_transaction mt\n        LEFT JOIN web_db.transaction_meta tm ON mt.id = tm.transaction_id\n        LEFT JOIN web_db.company c ON tm.company_id = c.id\n        LEFT JOIN web_db.company_profile cp on cp.company_id = c.id\n        LEFT JOIN web_db.company_aim_score cas ON tm.company_aim_score_id = cas.id\n        LEFT JOIN web_db.depository d ON mt.depository_id = d.id\n        WHERE 1=1\n            AND (description NOT LIKE 'DBT % HOLD %' AND description NOT LIKE 'CK %')\n            AND amount IS NOT NULL\n            AND amount <> 0\n            AND mt.id NOT IN (13018983, 13018986, 5847766, 5847769)\n        ),\n    --get all depositories for an account - used for multiple depository issue:\n    --some users have more than 1 spend and 1 save account\n    cte_dt_accounts as (\n            select\n              dta.unique_account_id,\n              dep2.id as depository_id\n            from bi_new.dt_accounts dta\n            join web_db.depository dep on dta.galileo_id = dep.id\n            join web_db.depository dep2 on dep.account_id = dep2.account_id\n            group by 1,2\n          ),\n    cte_carbon_offset as (\n           select\n              posted_transaction_id,\n              subscribed,\n              emissions_amount,\n              row_number() over(partition by posted_transaction_id order by created_at desc nulls last) as row_num\n           from web_db.posted_transaction_carbon_offset\n    ),\n    cte_plant_your_change as (\n        select gat.child_posted_transaction_id,\n               'p' || gpt.posted_transaction_id as plant_your_change_transfer_id\n        from web_db.galileo_adjustment_transactions gat\n        join web_db.galileo_posted_transaction gpt on gpt.authorization_code = gat.galileo_adjustment_transaction_id::varchar(50)\n        where gat.type = 'plant-your-change'\n        and gpt.transaction_code_type = 'ADF'\n    ),\n    virtual_cards as (\n        SELECT DISTINCT\n               prn\n        FROM bank_db.debit_card\n        WHERE virtual\n    ),\n    posted_transactions AS (\n        SELECT pt.*\n        \t, gpt.interchange_fee_amount::numeric(8, 2) AS interchange_fee_amount\n            , COALESCE(NULLIF(gpt.merchant_name, ''), NULLIF(gpt.transaction_description, ''), NULLIF(pt.description, '')) AS description_override\n            , gl.description AS transaction_type\n            , CASE WHEN company_aim_score_id IS NULL THEN FALSE ELSE TRUE END AS is_aim_scored\n            , CASE WHEN company_aim_score_id IS NOT NULL THEN c.display_name ELSE NULL END AS aim_company\n            , people AS aim_people_score\n            , planet AS aim_planet_score\n            , CASE WHEN pt.amount >=1 THEN ROW_NUMBER() OVER(PARTITION BY pt.depository_id ORDER BY pt.transaction_date) ELSE NULL END AS rn\n            , cp.conscience_coalition_merchant\n            , c.id as merchant_id\n            , c.name as merchant_name\n            , cty.name as country\n            , cty.code as country_code\n            , carbon.subscribed as is_planet_protection_subscribed\n            , carbon.emissions_amount\n            , gpt.prn\n            , nvl2(crd.prn, 'Virtual Card', NULL) AS card_type\n            , pyc.plant_your_change_transfer_id\n            , cpt.amount as cashback_amount\n        FROM web_db.posted_transaction pt\n        JOIN web_db.galileo_posted_transaction gpt ON (gpt.posted_transaction_id = pt.id)\n        JOIN web_db.galileo_lookup gl ON (gl.code = gpt.transaction_code_type AND gl.file = 'P' AND gl.field_name = 'TRANSACTION CODE/TYPE')\n        LEFT JOIN virtual_cards crd ON crd.prn = gpt.prn\n        LEFT JOIN web_db.posted_transaction_meta ptm ON ptm.posted_transaction_id = pt.id\n        LEFT JOIN web_db.company c ON c.id = ptm.company_id\n        LEFT JOIN web_db.company_profile cp on cp.company_id = c.id\n        LEFT JOIN web_db.company_aim_score cas ON ptm.company_aim_score_id = cas.id\n        LEFT JOIN web_db.country cty ON LTRIM(gpt.merchant_country_code,'0') = LTRIM(cty.iso_code,'0')\n        LEFT JOIN cte_carbon_offset carbon ON pt.id = carbon.posted_transaction_id\n                                          AND carbon.row_num = 1\n        LEFT JOIN cte_plant_your_change pyc ON pt.id = pyc.child_posted_transaction_id\n        LEFT JOIN web_db.cashback_posted_transaction cpt ON pt.id = cpt.posted_transaction_id\n        ),\n    combined_src as (\n        SELECT a.unique_account_id\n            , 'm' || miser_transaction_id AS unique_transaction_id\n            , transaction_type\n            , miser_transaction_date as transaction_date\n            , mt.post_date\n            , description\n            , amount\n            , NULL::numeric(8, 2) AS interchange_fee_amount\n            , NULL AS initial_deposit_ind\n            , CASE\n                WHEN transaction_type = 'ACH Deposit'\n                    AND (description ILIKE '%ANNUITY%'\n                        OR description ILIKE '%CHILD SUP%'\n                        OR description ILIKE '%COMMON OF MASS%'\n                        OR description ILIKE '%DD PR%'\n                        OR description ILIKE '%DIRECT%'\n                        OR description ILIKE '%DIR%DEP%'\n                        OR description ILIKE '%DIR%PAY%'\n                        OR description ILIKE '%DISABILITY%'\n                        OR description ILIKE '%DFAS%'\n                        OR description ILIKE '%EMPLOYEE P%'\n                        OR description ILIKE '%FED SAL%'\n                        OR description ILIKE '%GUSTO%PAY%'\n                        OR description ILIKE '%P%YR%L%'\n                        OR description ILIKE '%PAY-ADP%'\n                        OR description ILIKE '%PAYDEPOSIT%'\n                        OR description ILIKE '%PEN%'\n                        OR description ILIKE '%PR DEP%'\n                        OR description ILIKE '%PR PAYMENT%'\n                        OR description ILIKE '%SALARY%'\n                        OR description ILIKE '%SOC%SEC%'\n                        OR description ILIKE '%SSI%'\n                        OR description ILIKE '%TREA%'\n                        OR description ILIKE '%UI%'\n                        OR description ILIKE '%U%EMPLOYMEN%') THEN TRUE\n                ELSE FALSE\n                END AS direct_deposit_ind\n            , is_aim_scored\n            , aim_company\n            , aim_people_score\n            , aim_planet_score\n            , miser_transaction_id\n            , NULL AS posted_transaction_id\n            , conscience_coalition_merchant\n            , merchant_name\n            , merchant_id\n            , null as country\n            , null as country_code\n            , null as merchant_category_code\n            , mt.depository_id\n            , mt.account_product_type\n            , null as is_planet_protection_subscribed\n            , null as emissions_amount\n            , null as prn\n            , null as card_type\n            , null as plant_your_change_transfer_id\n            , null as cashback_amount\n        FROM miser_transactions mt\n        JOIN bi_new.dt_accounts a ON mt.depository_id = a.radius_id\n\n        UNION ALL\n\n        SELECT dta.unique_account_id\n            , 'p' || pt.id AS unique_transaction_id\n            , transaction_type\n            , transaction_date\n            , pt.post_date\n            , pt.description_override AS description\n            , amount\n            , pt.interchange_fee_amount\n            , CASE WHEN pt.rn = 1 AND dta.unique_account_id LIKE 'g%' THEN true ELSE false END AS initial_deposit_ind\n            , CASE\n                WHEN transaction_type in ('Coastal ACH Deposit', 'ACH Deposit') and amount > 0\n                    AND (pt.description_override ILIKE '%ANNUITY%'\n                        OR pt.description_override ILIKE '%CHILD SUP%'\n                        OR pt.description_override ILIKE '%COMMON OF MASS%'\n                        OR pt.description_override ILIKE '%DD PR%'\n                        OR pt.description_override ILIKE '%DIRECT%'\n                        OR pt.description_override ILIKE '%DIR%DEP%'\n                        OR pt.description_override ILIKE '%DIR%PAY%'\n                        OR pt.description_override ILIKE '%DISABILITY%'\n                        OR pt.description_override ILIKE '%DFAS%'\n                        OR pt.description_override ILIKE '%EMPLOYEE P%'\n                        OR pt.description_override ILIKE '%FED SAL%'\n                        OR pt.description_override ILIKE '%GUSTO%PAY%'\n                        OR pt.description_override ILIKE '%P%YR%L%'\n                        OR pt.description_override ILIKE '%PAY-ADP%'\n                        OR pt.description_override ILIKE '%PAYDEPOSIT%'\n                        OR pt.description_override ILIKE '%PEN%'\n                        OR pt.description_override ILIKE '%PR DEP%'\n                        OR pt.description_override ILIKE '%PR PAYMENT%'\n                        OR pt.description_override ILIKE '%SALARY%'\n                        OR pt.description_override ILIKE '%SOC%SEC%'\n                        OR pt.description_override ILIKE '%SSI%'\n                        OR pt.description_override ILIKE '%TREA%'\n                        OR pt.description_override ILIKE '%UI%'\n                        OR pt.description_override ILIKE '%U%EMPLOYMEN%'\n                        OR pt.description_override ilike '%BIWEEKLY'\n                        OR pt.description_override ilike '%PPD'\n                        OR pt.description_override ilike '%NET=PAY'\n                        OR pt.description_override ilike '%DIRECT PAY'\n                        OR pt.description_override ilike '%NET PAY'\n                        OR pt.description_override ilike '%RETIRE%') THEN TRUE\n                \tELSE FALSE\n                END AS direct_deposit_ind\n\n            , pt.is_aim_scored\n            , pt.aim_company\n            , pt.aim_people_score\n            , pt.aim_planet_score\n            , NULL AS miser_transaction_id\n            , pt.id AS posted_transaction_id\n            , pt.conscience_coalition_merchant\n            , pt.merchant_name\n            , pt.merchant_id\n            , pt.country\n            , pt.country_code\n            , case when pt.merchant_category_code != '0' then lpad(pt.merchant_category_code,4,'0') else null end as merchant_category_code\n            , depo.id as depository_id\n            , case when depo.product_id in (3,4) then 'Spend'\n                   when depo.product_id = 5 then 'Save'\n                   else null\n              end as account_product_type\n            , pt.is_planet_protection_subscribed\n            , pt.emissions_amount\n            , pt.prn\n            , pt.card_type\n            , pt.plant_your_change_transfer_id\n            , pt.cashback_amount\n        FROM posted_transactions pt\n        JOIN web_db.depository depo ON depo.id = pt.depository_id\n        JOIN cte_dt_accounts dta ON pt.depository_id = dta.depository_id\n      ),\n    missing_merchants as (\n      select\n        cs.unique_transaction_id,\n        dta.company_id as merchant_id,\n        c.name as merchant_name,\n        cp.conscience_coalition_merchant,\n        row_number() over (partition by cs.unique_transaction_id order by unique_transaction_id) rn\n      from combined_src cs\n      join etl.depository_transaction_merchant dta on cs.description ilike dta.transaction_description\n      join web_db.company c on dta.company_id = c.id\n      join web_db.company_profile cp on c.id = cp.company_id\n      left join etl.DEPOSITORY_TRANSACTION_MERCHANT_EXCLUDE dtme on c.ID = dtme.COMPANY_ID\n                                                                and cs.DESCRIPTION ilike dtme.TRANSACTION_DESCRIPTION        \n      where cs.merchant_id is null\n      and dtme.TRANSACTION_DESCRIPTION is null\n      )\n    SELECT\n        cs.unique_account_id,\n        cs.unique_transaction_id,\n        cs.transaction_type,\n        cs.transaction_date,\n        cs.post_date,\n        cs.description,\n        cs.amount,\n        cs.interchange_fee_amount,\n        cs.initial_deposit_ind,\n        cs.direct_deposit_ind,\n        cs.is_aim_scored,\n        cs.aim_company,\n        cs.aim_people_score,\n        cs.aim_planet_score,\n        cs.miser_transaction_id,\n        cs.posted_transaction_id,\n        nvl(cs.conscience_coalition_merchant, mm.conscience_coalition_merchant) as conscience_coalition_merchant,\n        nvl(cs.merchant_name, mm.merchant_name) as merchant_name,\n        nvl(cs.merchant_id, mm.merchant_id) as merchant_id,\n        cs.country,\n        cs.country_code,\n        cs.merchant_category_code,\n        cs.depository_id,\n        cs.account_product_type,\n        cs.is_planet_protection_subscribed,\n        cs.emissions_amount,\n        cs.prn,\n        cs.card_type,\n        cs.plant_your_change_transfer_id,\n        cs.cashback_amount,\n        CASE WHEN sum(1) OVER(PARTITION BY cs.unique_account_id, trim(regexp_replace(regexp_replace(cs.description,'[^A-Za-z\\\\s]', ''),'[\\\\s]+',' '))) > 1\n             THEN first_value(cs.unique_transaction_id) OVER(PARTITION BY cs.unique_account_id, trim(regexp_replace(regexp_replace(cs.description,'[^A-Za-z\\\\s]', ''),'[\\\\s]+',' ')) ORDER BY cs.transaction_date ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)\n             END AS transaction_recurrence_id,\n        CASE WHEN sum(1) OVER(PARTITION BY cs.unique_account_id, trim(regexp_replace(regexp_replace(cs.description,'[^A-Za-z\\\\s]', ''),'[\\\\s]+',' '))) > 1\n             THEN row_number() OVER(PARTITION BY cs.unique_account_id, trim(regexp_replace(regexp_replace(cs.description,'[^A-Za-z\\\\s]', ''),'[\\\\s]+',' ')) ORDER BY cs.transaction_date ASC)\n             END AS transaction_recurrence_number\n        ,CASE WHEN (description ilike '%crypto%' or description ilike '%bitcoin%') THEN TRUE ELSE FALSE END AS is_crypto_transaction       \n    FROM combined_src cs\n    LEFT JOIN missing_merchants mm ON cs.unique_transaction_id = mm.unique_transaction_id\n                                  AND mm.rn = 1\n    ;\n\nupdate bi_new.dt_accounts\nset is_charged_off = TRUE,\n    total_amount_charged_off = src.total_amount_charged_off,\n    most_recent_charged_off_date = src.most_recent_charged_off_date\nfrom (\n      SELECT d.unique_account_id,\n             MAX(transaction_date) AS most_recent_charged_off_date,\n             SUM(amount)           AS total_amount_charged_off\n      FROM bi_new.dt_depository_transactions d\n      WHERE transaction_type = 'Charge Off'\n      GROUP BY 1\n     ) src\nwhere bi_new.dt_accounts.unique_account_id = src.unique_account_id\n;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022967":{"id":3022967,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-560,"y":-160,"width":32,"height":32,"inputConnectorIDs":[3023046],"outputSuccessConnectorIDs":[3023049],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_banks"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\ndrop table if exists tmp_plaid_balance;\ncreate temp table tmp_plaid_balance as\nwith plaid_data as (\n    select pii.id,\n           pii.USER_PAYMENT_ACCOUNT_ID,\n           upa.last_four_digits as upa_last_four,\n           upa.account_type,\n           case upa.account_type\n              when 1 then 'checking'\n              when 2 then 'savings'\n              else 'unknown'\n           end as upa_account_type,\n           parse_json(ORIGINAL_PLAID_DATA) as plaid_source\n    from web_db.bank_account_plaid_identity_info pii\n    left join web_db.user_payment_account upa on pii.user_payment_account_id = upa.id\n    where pii.original_plaid_data is not null\n    and pii.original_plaid_data not ilike '{\"error\"%'\n)\nselect id,\n       USER_PAYMENT_ACCOUNT_ID,\n       upa_last_four,\n       upa_account_type,\n       value:mask::string as plaid_last_four,\n       lower(value:subtype::string) as plaid_account_type,\n       value:balances:available::numeric(30,2) as plaid_available_balance,\n       value:balances:current::numeric(30,2) as plaid_current_balance,\n       value:balances:limit::numeric(30,2) as plaid_account_limit,\n       case when upa_last_four = plaid_last_four and upa_account_type = plaid_account_type then 1\n            when upa_last_four = plaid_last_four and upa_account_type <> plaid_account_type then 2\n            when upa_last_four <> plaid_last_four and upa_account_type = plaid_account_type then 3\n            else 4\n       end as plaid_upa_match_rank,\n       case when plaid_upa_match_rank = 1 then 'last 4 and account type both match'\n            when plaid_upa_match_rank = 2 then 'last 4 match only'\n            when plaid_upa_match_rank = 3 then 'account type match only'\n            when plaid_upa_match_rank = 4 then 'no match on either last 4 or account type'\n       end as plaid_balance_match_type,\n       row_number() over (partition by id\n                              order by plaid_upa_match_rank asc nulls last,\n                                       plaid_available_balance desc nulls last,\n                                       plaid_current_balance desc nulls last) as plaid_choice_rank\nfrom plaid_data jd, lateral flatten (input => jd.plaid_source, path => 'accounts');\n\nDROP TABLE IF EXISTS bi_new.dt_banks;\nCREATE TABLE bi_new.dt_banks\nAS \n(\nwith bapii_max_ids as (\n\tSELECT\n\t  user_payment_account_id,\n\t  max(id) as max_id\n\tFROM web_db.bank_account_plaid_identity_info\n\tWHERE 1=1\n\t--  AND user_payment_account_id=528507\n\tGROUP BY user_payment_account_id\n),\n\nbapii as (\n\tselect * from web_db.bank_account_plaid_identity_info\n\twhere bank_account_plaid_identity_info.id in (\n\t  select max_id from bapii_max_ids\n\t)\n)\n\nSELECT user_id,\n\tupa.id AS user_payment_account_id,\n    null as STRIPE_PAYMENT_METHOD_ID,\n\tRTRIM(REGEXP_REPLACE(\n\tCASE \n\t    WHEN UPPER(upa.name) LIKE '%CHASE%' THEN 'Chase Bank'\n\t    WHEN UPPER(upa.name) LIKE 'COMPASS BANK%' THEN 'Compass Bank'\n\t    WHEN UPPER(upa.name) LIKE 'PNC BANK%' THEN 'PNC Bank'\n\t    WHEN UPPER(upa.name) LIKE '%GREEN DOT%' THEN 'Green Dot'\n\t    WHEN UPPER(upa.name) LIKE '%BANCORP.COM%' THEN 'Bancorp Bank'\n\t    ELSE upa.name \n\tEND, '\\(x[0-9]{4}\\)', '')) AS bank_name,\n    NULL as card_brand,\n\n\tis_verified,\n\n\tCASE \n\t\tWHEN depository_id IS NULL THEN FALSE\n\t\tELSE TRUE \n\tEND AS is_checking_account,\n\t\t\n        upa.is_deleted,\n        upa.is_admin_disabled,\n\t\t\n\tCOALESCE(deposited_from_amount, 0) AS transferred_from_amount,\n\tCOALESCE(withdrawn_to_amount, 0) AS transferred_to_amount,\n\taccount_number,\n\tlast_four_digits,\t\t\n\trouting_number,\n  \n\tCASE \n\t\tWHEN is_micro_deposit_send THEN 'Micro-Deposit'\n\t\tWHEN depository_id IS NOT NULL THEN NULL\n\t\tELSE 'Plaid' \n\tEND AS verification_type,\n\t\n\tupa.date_created AS payment_account_linked_date,\n\n\t-- plaid identity\n\tbapii.name_score    as plaid_identity_name_score,\n\tbapii.email_score   as plaid_identity_email_score,\n\tbapii.phone_score   as plaid_identity_phone_score,\n\tbapii.address_score as plaid_identity_address_score,\n\tbapii.total_score   as plaid_identity_total_score,\n\n\tbapii.is_name_matched    as plaid_identity_is_name_match,\n\tbapii.is_email_matched   as plaid_identity_is_email_match,\n\tbapii.is_phone_matched   as plaid_identity_is_phone_match,\n\tbapii.is_address_matched as plaid_identity_is_address_match,\n\n\tbapii.is_ops_approved     as plaid_identity_is_ops_approved,\n\tbapii.ops_approved_reason as plaid_identity_ops_approved_reason,\n\tbapii.ops_agent           as plaid_identity_ops_agent,\n\n\tbapii.plaid_data_date_retrieved as plaid_identity_date_retrieved,\n\n\tbapii.is_fraud as plaid_identity_is_fraud,\n\t\t\n        tpb.plaid_balance_match_type,\n        tpb.plaid_current_balance,\n        tpb.plaid_available_balance,\n        tpb.plaid_account_limit,\n        bapii.original_plaid_data\n\nFROM web_db.user_payment_account upa\nLEFT JOIN bapii\n\tON upa.id = bapii.user_payment_account_id\nLEFT JOIN tmp_plaid_balance tpb\n       ON bapii.id = tpb.id\n      AND tpb.plaid_choice_rank = 1\t\t\nLEFT JOIN \n(\n\tSELECT user_payment_account_id,\n\t\tSUM(deposited_from_amount) AS deposited_from_amount,\n\t\tSUM(withdrawn_to_amount) AS withdrawn_to_amount\n\tFROM\n\t(\n\t\tSELECT user_payment_account_id,\n\t\t\tCASE \n\t\t\t\tWHEN amount > 0 THEN amount\n\t\t\t\tELSE 0 \n\t\t\tEND AS deposited_from_amount,\n\n\t\t\tCASE \n\t\t\t\tWHEN amount < 0 THEN amount\n\t\t\t\tELSE 0 \n\t\t\tEND AS withdrawn_to_amount\n\n\tFROM bi_new.dt_transfers\n\tWHERE transaction_status = 'Processed'\n\t) a\n\tGROUP BY 1\n) pay ON (upa.id = pay.user_payment_account_id)\n)\n\nunion all\n\nselect\n    spm.USER_ID,\n    null,\n    spm.PAYMENT_METHOD_ID as STRIPE_PAYMENT_METHOD_ID,\n    'Stripe Payment',\n    replace(parse_json(RAW_PAYMENT_METHOD):card:brand, '\"', '') as card_brand,\n    case\n        when sl.PAYMENT_METHOD_ID is not null then true\n        else 0\n    end as is_verified,  -- is_verified, stripe account is verified when customer can initialized a funding transaction\n    false, -- is_checking_account\n    spm.IS_DELETED,\n    false,\n    COALESCE(deposited_from_amount, 0), -- transferred_from_amount\n    COALESCE(withdrawn_to_amount, 0), -- transferred_to_amount\n    null,\n    replace(parse_json(RAW_PAYMENT_METHOD):card:last4, '\"', '') as last_four_digits, -- last_four_digits\n    null,\n    'Stripe',\n    spm.CREATED_AT,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null\nfrom BANK_DB.STRIPE_PAYMENT_METHOD spm\nleft join (\n    select\n        PAYMENT_METHOD_ID,\n        sum(\n            case\n                when STATUS='galileo_paid' then AMOUNT / 100.0\n                else 0\n            end\n        ) as deposited_from_amount,\n        0 as withdrawn_to_amount\n    from BANK_DB.STRIPE_LEDGER\n    where 1=1\n      and STRIPE_ACCOUNT_ID='aspiration-cma'\n    group by 1\n) sl on spm.PAYMENT_METHOD_ID=sl.PAYMENT_METHOD_ID\nwhere 1=1\n  and spm.STRIPE_ACCOUNT_ID='aspiration-cma'\n\n;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022968":{"id":3022968,"inputCardinality":"ZERO","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":444132438,"x":-912,"y":-496,"width":32,"height":32,"inputConnectorIDs":[],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023086],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Start 0"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022969":{"id":3022969,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-960,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023044],"outputSuccessConnectorIDs":[3023028],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_account_daily_data"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"--new\n\nset timezone = 'America/Los_Angeles';\n\n--Business rule for charge offs: look for credits where tran type = charge off\n--or charge off recovery.  Sometimes the latter is used mistakenly as a charge off.\n--So we look for charge off recoveries in positive amounts.\ndrop table if exists etl.tmp_charge_off;\ncreate table etl.tmp_charge_off as\nselect UNIQUE_ACCOUNT_ID,\n       min(TRANSACTION_DATE::date) as charge_off_date\nfrom bi_new.DT_DEPOSITORY_TRANSACTIONS\nwhere transaction_type in ('Charge Off','Charge Off Recovery')\nand AMOUNT > 0\ngroup by 1;\n\nDROP TABLE IF EXISTS bi_new.dt_summit_daily_fee_settings_tmp;\nCREATE TABLE bi_new.dt_summit_daily_fee_settings_tmp\nAS (\n  WITH\n  dates AS (\n    SELECT '2014-10-01'::DATE + i - 1 AS date\n    FROM (\n            select row_number() over(order by seq4()) as i\n            from table (\n                    generator(\n                            rowcount => 3000\n                        )\n                )\n           )\n    WHERE i <= CURRENT_DATE - '2014-10-01'::DATE + 1\n    ),\n  all_dep_dates AS (\n    SELECT a.unique_account_id\n      , COALESCE(a.galileo_id, a.radius_id) AS depository_id\n      , a.termination_date\n      , b.date\n    FROM bi_new.dt_accounts a\n    JOIN dates b ON b.date >= a.inception_date\n    WHERE a.inception_date IS NOT NULL\n    AND a.account_type = 'Checking'\n    ),\n  depository_fee_histories AS (\n    SELECT dta.unique_account_id\n      , dfh_g.fee_date\n      , dfh_g.fee_amount\n      , dfh_g.id\n    FROM web_db.depository_fee_history dfh_g\n    JOIN bi_new.dt_accounts dta ON (dta.galileo_id = dfh_g.depository_id)\n    UNION ALL\n    SELECT dta.unique_account_id\n      , dfh_r.fee_date as fee_date\n      , dfh_r.fee_amount\n      , dfh_r.id\n    FROM web_db.depository_fee_history dfh_r\n    JOIN bi_new.dt_accounts dta ON (dta.radius_id = dfh_r.depository_id)\n    ),\n  fee_history AS (\n    SELECT dfh.unique_account_id\n      , dfh.fee_date\n      , dfh.fee_amount\n    FROM (\n      SELECT dfh.unique_account_id\n        , dfh.fee_date\n        , MAX(dfh.id) AS max_id\n      FROM depository_fee_histories dfh\n      GROUP BY dfh.unique_account_id, dfh.fee_date\n      ) a\n    JOIN depository_fee_histories dfh ON a.max_id = dfh.id\n    ),\n  initial_fees AS (\n    SELECT b.unique_account_id\n      , min_date\n      , b.fee_amount AS initial_fee\n    FROM (\n      SELECT unique_account_id\n        , MIN(fee_date) AS min_date\n      FROM fee_history\n      GROUP BY 1\n      ) a\n    JOIN fee_history b ON (a.unique_account_id = b.unique_account_id AND a.min_date = b.fee_date)\n    )\n  SELECT foo.unique_account_id\n    , foo.date\n    , CASE WHEN foo.termination_date IS NULL OR foo.termination_date > foo.date\n      THEN COALESCE(CASE WHEN foo.date < min_date THEN initial_fee ELSE b.fee_amount END, 0)\n      ELSE 0 END AS fee_amount\n  FROM all_dep_dates foo\n  LEFT JOIN (\n    SELECT a.unique_account_id\n      , a.date\n      , MAX(b.fee_date) AS max_date\n    FROM all_dep_dates a\n    LEFT JOIN fee_history b ON a.unique_account_id = b.unique_account_id AND a.date >= b.fee_date\n    GROUP BY 1, 2\n    ) a ON foo.unique_account_id = a.unique_account_id AND foo.date = a.date\n  LEFT JOIN fee_history b ON a.unique_account_id = b.unique_account_id AND a.max_date = b.fee_date\n  LEFT JOIN initial_fees md ON md.unique_account_id = foo.unique_account_id\n);\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_fee_settings_tmp;\nCREATE TABLE bi_new.dt_investment_daily_fee_settings_tmp\nAS (\n  WITH\n  dates AS (\n    SELECT '2014-10-01'::DATE + i - 1 AS date\n    FROM (\n            select row_number() over(order by seq4()) as i\n            from table (\n                    generator(\n                            rowcount => 3000\n                        )\n                )\n           )\n    WHERE i <= CURRENT_DATE - '2014-10-01'::DATE + 1\n    ),\n  all_inv_dates AS (\n    SELECT id AS investment_id\n      , date\n    FROM web_db.investment a\n    JOIN dates b ON b.date >= a.inception_date\n    WHERE inception_date IS NOT NULL\n    ),\n  fee_history AS (\n    SELECT ifh.investment_id\n      , ifh.fee_date::DATE as fee_date\n      , ifh.fee_pct\n    FROM (\n      SELECT investment_id\n        , fee_date::DATE as investment_fee_date\n\n        , max(id) AS max_id\n      FROM web_db.investment_fee_history\n      GROUP BY 1, 2\n      ) a\n    JOIN web_db.investment_fee_history ifh ON a.max_id = ifh.id AND ifh.investment_id = a.investment_id AND ifh.fee_date :: DATE = a.investment_fee_date :: DATE\n    ),\n  initial_fees AS (\n    SELECT b.investment_id\n      , min_date\n      , b.fee_pct AS initial_fee\n    FROM (\n      SELECT investment_id\n        , MIN(fee_date) AS min_date\n      FROM fee_history\n      GROUP BY 1) a\n    JOIN fee_history b ON a.investment_id = b.investment_id AND a.min_date = b.fee_date\n    )\n  SELECT 'i' || aid.investment_id AS unique_account_id\n    , aid.date\n    , CASE WHEN acc.termination_date IS NULL OR acc.termination_date > aid.date\n      THEN coalesce(CASE WHEN aid.date < min_date THEN initial_fee ELSE b.fee_pct END, 0)\n      ELSE 0 END AS fee_pct\n  FROM all_inv_dates aid\n  LEFT JOIN (\n    SELECT a.investment_id\n      , a.date\n      , max(b.fee_date) AS max_date\n    FROM all_inv_dates a\n    LEFT JOIN fee_history b ON a.investment_id = b.investment_id AND a.date >= b.fee_date\n    GROUP BY 1, 2\n    ) a ON a.investment_id = aid.investment_id AND a.date = aid.date\n  LEFT JOIN fee_history b ON aid.investment_id = b.investment_id AND a.max_date = b.fee_date\n  LEFT JOIN initial_fees md ON md.investment_id = a.investment_id\n  LEFT JOIN web_db.investment i ON i.id = b.investment_id\n  LEFT JOIN web_db.account acc ON acc.id = i.account_id\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_account_daily_fee_settings_tmp;\nCREATE TABLE bi_new.dt_account_daily_fee_settings_tmp\nAS (\n  SELECT a.unique_account_id\n    , a.date\n    , a.fee_amount AS monthly_fee_setting\n    , b.fee_amount AS previous_day_monthly_fee_setting\n    , NULL AS yearly_percent_setting\n    , NULL AS previous_day_yearly_percent_setting\n  FROM bi_new.dt_summit_daily_fee_settings_tmp a\n  LEFT JOIN bi_new.dt_summit_daily_fee_settings_tmp b ON a.unique_account_id = b.unique_account_id AND a.date = b.date + 1\n  UNION ALL\n  SELECT a.unique_account_id\n    , a.date\n    , NULL AS monthly_fee_setting\n    , NULL AS previous_day_monthly_fee_setting\n    , a.fee_pct AS yearly_percent_setting\n    , b.fee_pct AS previous_day_yearly_percent_setting\n  FROM bi_new.dt_investment_daily_fee_settings_tmp a\n  LEFT JOIN bi_new.dt_investment_daily_fee_settings_tmp b ON a.unique_account_id = b.unique_account_id AND a.date = b.date + 1\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_summit_daily_fee_settings_tmp;\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_fee_settings_tmp;\n\n--insert any brand new accounts into etl.daily balances so they will be included in the table\ninsert into etl.DAILY_BALANCES\n(UNIQUE_ACCOUNT_ID, DATE, DAILY_BALANCE, ORIGINAL_BALANCE, SPEND_DAILY_BALANCE, SAVE_DAILY_BALANCE, HAS_SET_RECURRING_DEPOSIT)\nselect a.UNIQUE_ACCOUNT_ID,\n       INCEPTION_DATE::date as date,\n       0 as daily_balance,\n       0 as original_balance,\n       0 as spend_daily_balance,\n       0 as save_daily_balance,\n       false as has_set_recurring_deposit\nfrom bi_new.DT_ACCOUNTS a\nleft join etl.DAILY_BALANCES b on a.UNIQUE_ACCOUNT_ID = b.UNIQUE_ACCOUNT_ID\nwhere b.UNIQUE_ACCOUNT_ID is null\nand a.INCEPTION_DATE is not null\nand a.ACCOUNT_TYPE = 'Checking';\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp;\nCREATE TABLE bi_new.dt_investment_daily_balances_tmp\nAS (\n  WITH\n  dates AS (\n    SELECT '2014-10-01'::DATE + i - 1 AS date\n    FROM (\n            select row_number() over(order by seq4()) as i\n            from table (\n                    generator(\n                            rowcount => 3000\n                        )\n                )\n           )\n    WHERE i <= CURRENT_DATE - '2014-10-01'::DATE + 1\n    ),\n  investment_dates AS (\n    SELECT 'i' || i.id AS unique_account_id\n      , date\n    FROM web_db.investment i\n    JOIN dates ON dates.date >= inception_date\n    WHERE inception_date IS NOT NULL\n    )\n  SELECT ad.unique_account_id\n    , ad.date\n    , COALESCE(ip.current_value, LAG(ip.current_value) IGNORE NULLS OVER (PARTITION BY ad.unique_account_id ORDER BY ad.date)) AS current_value\n  FROM investment_dates ad\n  LEFT JOIN web_db.investment_position ip ON ad.unique_account_id = 'i' || ip.investment_id AND ad.date = DATEADD('hour', 10, convert_timezone('America/Los_Angeles',ip.position_date))::date\n);\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_2;\n\nCREATE TABLE bi_new.dt_investment_daily_balances_tmp_2\nAS (\n  WITH\n  min_posted_investment_dates AS (\n    SELECT unique_account_id\n      , MIN(date) AS min_date\n    FROM bi_new.dt_investment_daily_balances_tmp\n    WHERE current_value > 0\n    GROUP BY 1\n    ),\n  initial_investment_balances AS (\n    SELECT db.unique_account_id\n      , db.current_value AS initial_balance\n      , min_date\n    FROM min_posted_investment_dates a\n    JOIN bi_new.dt_investment_daily_balances_tmp db ON a.unique_account_id = db.unique_account_id AND a.min_date = db.date\n    )\n  SELECT a.unique_account_id\n    , a.date\n    , greatest(0, CASE WHEN date < min_date THEN initial_balance ELSE current_value END) AS daily_balance\n    , current_value AS original_balance\n  FROM bi_new.dt_investment_daily_balances_tmp a\n  LEFT JOIN initial_investment_balances b ON a.unique_account_id = b.unique_account_id\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp;\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_3;\nCREATE TABLE bi_new.dt_investment_daily_balances_tmp_3\nAS (\n  SELECT unique_account_id\n    , date\n    , daily_balance\n    , original_balance\n    , null::dec(18,2) AS spend_daily_balance\n    , null::dec(18,2) AS save_daily_balance\n    , max(flag::int)\n    OVER(PARTITION BY unique_account_id)::BOOLEAN AS has_set_recurring_deposit\n    FROM (\n      SELECT a.*\n        , CASE when b.unique_account_id IS NULL THEN FALSE ELSE TRUE END AS flag\n      FROM bi_new.dt_investment_daily_balances_tmp_2 a\n      LEFT JOIN (\n        SELECT 'i' || investment_id AS unique_account_id\n          , date_created :: date AS sb_setting_dt\n        FROM web_db.recurring_order_txn\n        GROUP BY 1, 2\n        ) b on a.unique_account_id = b.unique_account_id AND a.date = b.sb_setting_dt\n      ) a\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_2;\n\nDROP TABLE IF EXISTS bi_new.dt_account_daily_data;\nCREATE TABLE bi_new.dt_account_daily_data\nAS (\n  WITH\n  billpay AS (\n    SELECT cp.date_created::DATE AS check_creation_date,\n      dta.unique_account_id,\n      SUM(cp.amount) AS daily_bill_pay_amount,\n      COUNT(*) AS daily_bill_pay_count\n    FROM web_db.check_payment cp\n    JOIN bi_new.dt_accounts dta ON (cp.user_id = dta.user_id)\n    WHERE cp.status = 6\n    GROUP BY 1, 2\n    ),\n  planet_protection_subscription as (\n    select pp.unique_account_id,\n           pp.date\n    from etl.DAILY_BALANCES pp\n    where exists(\n          select 1\n          from web_db.subscription s\n          join bi_new.dt_accounts a on s.account_id = a.galileo_account_id\n          join WEB_DB.SUBSCRIPTION_INVOICE si on s.SUBSCRIPTION_ID = si.SUBSCRIPTION_ID\n          where s.plan_group ilike '%planet%protection%'\n            and pp.unique_account_id = a.unique_account_id\n            and pp.date between si.PERIOD_START::date and si.PERIOD_END::date\n            and si.STATUS = 'paid'\n        )\n    ),\n   psh AS (\n   SELECT USER_ID, PAUSED AS is_pyc_paused, all_dates.date AS date\n        FROM (\n                 SELECT '2020-10-01'::DATE + i - 1 AS date  -- Generates dates till 2034, needs to be replaced with date dimension in future\n                 FROM (\n                          SELECT ROW_NUMBER() OVER (ORDER BY SEQ4()) AS i\n                          FROM TABLE (\n                              GENERATOR(\n                                      ROWCOUNT => 4000\n                                  )\n                              )\n                      )\n                 WHERE i <= CURRENT_DATE - '2020-10-01'::DATE + 1\n             ) all_dates\n                 JOIN (\n            SELECT user_id,\n                   paused,\n                   last_updated,\n                   COALESCE(LEAD(last_updated, 1) OVER (PARTITION BY USER_ID ORDER BY last_updated), CURRENT_DATE + 1)::date AS last_updated_next\n            FROM (SELECT user_id,\n                         paused,\n                         UPDATED_AT::date                                                                    AS last_updated,\n                         ROW_NUMBER() OVER (PARTITION BY USER_ID, UPDATED_AT::date ORDER BY UPDATED_AT DESC) AS row_num\n                  FROM adw.bank_db.PYC_SETTING_HISTORY)\n            WHERE row_num = 1 ) psh_history ON all_dates.date >= psh_history.last_updated\n            AND all_dates.date < psh_history.last_updated_next\n    ),\n  transactions AS (\n    SELECT unique_account_id\n      , post_date\n      , sum(CASE WHEN transaction_type IN ('ACH Withdrawal', 'Coastal ACH Debit', 'Money Transfer') AND amount < 0 THEN amount ELSE 0 END) AS ach_withdrawal_amount\n      , min(CASE WHEN transaction_type IN ('ACH Withdrawal', 'Coastal ACH Debit', 'Money Transfer') AND amount < 0 THEN amount ELSE 0 END) AS largest_ach_withdrawal_amount\n      , sum(CASE WHEN transaction_type IN ('ACH Withdrawal', 'Coastal ACH Debit', 'Money Transfer') AND amount < 0 THEN 1 ELSE 0 END) AS ach_withdrawal_count\n      , sum(CASE WHEN transaction_type IN ('Debit Card - No PIN', 'Purchase', 'Unique Transactions', 'Retail Sale')  THEN amount ELSE 0 END) AS dbt_card_no_pin_amount\n      , min(CASE WHEN transaction_type IN ('Debit Card - No PIN', 'Purchase', 'Unique Transactions', 'Retail Sale') THEN amount ELSE 0 END) AS largest_dbt_card_no_pin_amount\n      , sum(CASE WHEN transaction_type IN ('Debit Card - No PIN', 'Purchase', 'Unique Transactions', 'Retail Sale')  THEN 1 ELSE 0 END) AS dbt_card_no_pin_count\n      , sum(CASE WHEN transaction_type IN ('Interest','Interest Payment', 'Interest Posting', 'Interest Paid') THEN amount ELSE 0 END) AS interest_amount\n      , sum(CASE WHEN transaction_type IN ('Check Withdrawal', 'Bill Pay Check Payment', 'Bill Payment - Check', 'Convenience Check') THEN amount ELSE 0 END) AS check_withdrawal_amount\n      , min(CASE WHEN transaction_type IN ('Check Withdrawal', 'Bill Pay Check Payment', 'Bill Payment - Check', 'Convenience Check') THEN amount ELSE 0 END) AS largest_check_withdrawal_amount\n      , sum(CASE WHEN transaction_type IN ('Check Withdrawal', 'Bill Pay Check Payment', 'Bill Payment - Check', 'Convenience Check') THEN 1 ELSE 0 END) AS check_withdrawal_count\n      , sum(CASE WHEN transaction_type IN('Wire Transfer - Withdrawal', 'API funds transfer') AND amount < 0 THEN amount ELSE 0 END) AS wire_withdrawal_amount\n      , min(CASE WHEN transaction_type IN ('Wire Transfer - Withdrawal', 'API funds transfer') AND amount < 0 THEN amount ELSE 0 END) AS largest_wire_withdrawal_amount\n      , sum(CASE WHEN transaction_type IN ('Wire Transfer - Withdrawal', 'API funds transfer') AND amount < 0 THEN 1 ELSE 0 END) AS wire_withdrawal_count\n      , sum(CASE WHEN transaction_type IN ('Card to Card') THEN amount ELSE 0 END) as internal_transfer_deposit\n      , sum(CASE WHEN transaction_type in ('C2C - Customer Initiated') THEN amount ELSE 0 END) as internal_transfer_withdrawal\n      , sum(CASE WHEN transaction_type IN ('ATM Deposit', 'Money Transfer') AND amount > 0 THEN amount ELSE 0 END) AS atm_deposit_amount\n      , max(CASE WHEN transaction_type IN ('ATM Deposit', 'Money Transfer') AND amount > 0 THEN amount ELSE 0 END) AS largest_atm_deposit_amount\n      , sum(CASE WHEN transaction_type IN ('ATM Deposit', 'Money Transfer') AND amount > 0 THEN 1 ELSE 0 END) AS atm_deposit_count\n      , sum(CASE transaction_type WHEN 'ATM Withdrawal' THEN amount ELSE 0 END) AS atm_withdrawal_amount\n      , min(CASE transaction_type WHEN 'ATM Withdrawal' THEN amount ELSE 0 END) AS largest_atm_withdrawal_amount\n      , sum(CASE transaction_type WHEN 'ATM Withdrawal' THEN 1 ELSE 0 END) AS atm_withdrawal_count\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Pre-auth completion') THEN amount ELSE 0 END) AS dbt_card_pin_amount\n      , min(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Pre-auth completion') THEN amount ELSE 0 END) AS largest_dbt_card_pin_amount\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Pre-auth completion') THEN 1 ELSE 0 END) AS dbt_card_pin_count\n      , sum(CASE WHEN transaction_type IN ('Wire Transfer - Deposit', 'API funds transfer offset') THEN amount ELSE 0 END) AS wire_deposit_amount\n      , max(CASE WHEN transaction_type IN ('Wire Transfer - Deposit', 'API funds transfer offset') THEN amount ELSE 0 END) AS largest_wire_deposit_amount\n      , sum(CASE WHEN transaction_type IN ('Wire Transfer - Deposit', 'API funds transfer offset') THEN 1 ELSE 0 END) AS wire_deposit_count\n      , sum(CASE WHEN transaction_type IN ('ATM Fee Refund', 'Domestic ATM Fee Rebate', 'Int''l ATM Fee Rebate', 'Academy Credit', 'Fee Rebate') THEN amount ELSE 0 END) AS atm_fee_refund_amount\n      , sum(CASE WHEN transaction_type in ('ACH Deposit', 'Coastal ACH Deposit', 'E-Check') THEN amount ELSE 0 END) AS ach_deposit_amount\n      , max(CASE WHEN transaction_type in ('ACH Deposit', 'Coastal ACH Deposit', 'E-Check') THEN amount ELSE 0 END) AS largest_ach_deposit_amount\n      , sum(CASE WHEN transaction_type in ('ACH Deposit', 'Coastal ACH Deposit', 'E-Check') THEN 1 ELSE 0 END) AS ach_deposit_count\n      , sum(CASE WHEN transaction_type IN ('Check Deposit', 'RDC Other Check Deposit', 'Other Check Deposit') THEN amount ELSE 0 END) AS check_deposit_amount\n      , max(CASE WHEN transaction_type IN ('Check Deposit', 'RDC Other Check Deposit', 'Other Check Deposit') THEN amount ELSE 0 END) AS largest_check_deposit_amount\n      , sum(CASE WHEN transaction_type IN ('Check Deposit', 'RDC Other Check Deposit', 'Other Check Deposit') THEN 1 ELSE 0 END) AS check_deposit_count\n      , sum(CASE WHEN transaction_type in ('PWIF Monthly Summit Tip Fee', 'PWIF Payment', 'Aspiration Pay What is Fair') THEN amount ELSE 0 END) AS actual_pwif_paid\n      , sum(CASE WHEN transaction_type in ('Promotional Credit') THEN amount ELSE 0 END) as promo\n      , sum(CASE WHEN transaction_type in ('Cashback Rewards') THEN amount ELSE 0 END) as cashback\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN amount ELSE 0 END) AS aim_debit_amount\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN 1 ELSE 0 END) AS aim_debit_count\n      , avg(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN aim_planet_score ELSE NULL END)::decimal(38,6) AS aim_planet_transaction_average\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -aim_planet_score * amount ELSE NULL END)\n        /nullif(sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -amount ELSE NULL END)::decimal(38,6),0) AS aim_planet_dollar_weighted_average\n      , avg(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN aim_people_score ELSE NULL END) AS aim_people_transaction_average\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -aim_people_score * amount ELSE NULL END)\n        /nullif(sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -amount ELSE NULL END)::decimal(38,6),0) AS aim_people_dollar_weighted_average\n      , sum(CASE WHEN transaction_type IN('Reversal-Credit Account', 'Merchant Credit', 'Temp Provisional Credit', 'Cashback Rewards', 'Chargeback', 'Arbitration Chargeback', 'STAR Chargeback', 'Charge Off',\n                                         'Returned ACH Items', 'Debit Chargeback', 'Final Dispute', 'Visa Chargeback', 'Admin Adjustment',\n                                         'RDC Other Check Dep Ret', 'Debit or Credit Adjustment', 'Maestro Load', 'UNKNOWN',\n                                          'Debit Card Return', 'Deposit Verification', 'Balance Transfer', 'Paypal Deposit', 'Radius ACH transfer adj', 'Convenience Check Adjustment',\n                                         'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment', 'Foreign Transaction Fee', 'Domestic Wire Out Fee',\n                                         'International Wire Out Fee', 'Domestic Wire In Fee', 'International Wire In Fee', 'Cancelled acct or failedid refund adjustment', 'Repayment of Overdraft Funds',\n                                         'Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees', 'Closing Transfer to Card', 'MasterCard Load',\n                                         'Refund', 'Wire Transfer - Deposit - Reversal', 'Debit Card Load') AND amount > 0 THEN 1 ELSE 0 END)::decimal(38,6) as other_deposit_count\n      , sum(CASE WHEN transaction_type IN('Reversal-Credit Account',  'Merchant Credit', 'Temp Provisional Credit', 'Cashback Rewards', 'Chargeback', 'Arbitration Chargeback', 'STAR Chargeback', 'Charge Off',\n                                         'Returned ACH Items', 'Debit Chargeback', 'Final Dispute', 'Visa Chargeback', 'Admin Adjustment',\n                                         'RDC Other Check Dep Ret', 'Debit or Credit Adjustment', 'Maestro Load', 'UNKNOWN',\n                                          'Debit Card Return', 'Deposit Verification', 'Balance Transfer', 'Paypal Deposit', 'Radius ACH transfer adj.', 'Convenience Check Adjustment',\n                                         'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment', 'Foreign Transaction Fee', 'Domestic Wire Out Fee',\n                                         'International Wire Out Fee', 'Domestic Wire In Fee', 'International Wire In Fee', 'Cancelled acct or failedid refund adjustment', 'Repayment of Overdraft Funds',\n                                         'Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees', 'Closing Transfer to Card', 'MasterCard Load',\n                                         'Refund', 'Wire Transfer - Deposit - Reversal', 'Debit Card Load') AND amount > 0 THEN amount ELSE 0 END)::decimal(38,6) as other_deposit_amount\n      , sum(CASE WHEN transaction_type IN('Repayment of Overdraft Funds', 'Settlement Reversals', 'Domestic Wire In Fee', 'Domestic Wire Out Fee', 'International Wire In Fee', 'International Wire Out Fee',\n                                          'C2C - Customer Initiated', 'Charge Off Recovery', 'ATM Intl. Fee', 'Express mail fee', 'Foreign Transaction Fee','Over the Counter Cash Access Fee (International)', '2nd Presentment',\n                                         'Returned ACH Items', 'Charge Off Recovery', 'Debit 2nd Presentment', 'Final Dispute',\n                                         'Visa Chargeback', 'Admin Adjustment', 'Visa Second Presentment', 'RDC Other Check Dep Ret', 'ACH Debit Adjustment', 'Temp Provisional Credit',\n                                          'Radius ACH transfer adj.', 'Convenience Check Adjustment', 'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment',\n                                         'Cancelled acct or failedid refund adjustment','Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees',\n                                          'Arbitration Chargeback', 'Reversal-Credit Account', 'Cash Disbursements', 'Wire Transfer - Withdrawal - Reversal', 'Coastal ACH Reversal',\n                                          'Charge Off Recovery', 'Express mail fee', 'Closing Transfer from Savings', 'Force Post Settle-Could not match to an Auth', 'Reversal-Debiting Account',\n                                          'Auth', 'Over the Counter Cash Access Fee (International)') AND amount < 0 THEN 1 ELSE 0 END)::decimal(38,6) as other_withdrawal_count\n      , sum(CASE WHEN transaction_type IN('Repayment of Overdraft Funds', 'Settlement Reversals', 'Domestic Wire In Fee', 'Domestic Wire Out Fee', 'International Wire In Fee', 'International Wire Out Fee',\n                                          'C2C - Customer Initiated', 'Charge Off Recovery', 'ATM Intl. Fee', 'Express mail fee', 'Foreign Transaction Fee','Over the Counter Cash Access Fee (International)', '2nd Presentment',\n                                         'Returned ACH Items', 'Charge Off Recovery', 'Debit 2nd Presentment', 'Final Dispute',\n                                         'Visa Chargeback', 'Admin Adjustment', 'Visa Second Presentment', 'RDC Other Check Dep Ret', 'ACH Debit Adjustment', 'Temp Provisional Credit',\n                                          'Radius ACH transfer adj.', 'Convenience Check Adjustment', 'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment',\n                                         'Cancelled acct or failedid refund adjustment','Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees',\n                                          'Arbitration Chargeback', 'Reversal-Credit Account', 'Cash Disbursements', 'Wire Transfer - Withdrawal - Reversal', 'Coastal ACH Reversal',\n                                          'Charge Off Recovery', 'Express mail fee', 'Closing Transfer from Savings', 'Force Post Settle-Could not match to an Auth', 'Reversal-Debiting Account',\n                                          'Auth', 'Over the Counter Cash Access Fee (International)') AND amount < 0 THEN amount ELSE 0 END)::decimal(38,6) as other_withdrawal_amount\n      , sum(CASE WHEN DESCRIPTION in ('Monthly Planet Protection Charge', 'Annual Planet Protection Charge', 'Planet Protection Refund',\n                                      'Monthly Aspiration Plus Charge', 'Annual Aspiration Plus Charge', 'Aspiration Plus Refund') THEN amount ELSE 0 END) as aplus_fee_paid\n      , sum(CASE WHEN TRANSACTION_TYPE in ('Web Service Adjustment')\n                  and (DESCRIPTION like 'Planted%Tree%' or DESCRIPTION = 'Plant Your Change Transfer') THEN amount ELSE 0 END) as pyc_revenue_amount\n      , sum(CASE WHEN TRANSACTION_TYPE in ('Purchase', 'Purchase with PIN', 'Debit Card - No PIN',\n                                           'Debit Card - PIN', 'Retail Sale', 'Unique Transactions', 'Pre-auth completion')\n                  THEN INTERCHANGE_FEE_AMOUNT ELSE 0 END) as interchange_fee_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = true THEN 1 ELSE 0 END) AS planet_protection_subscribed_debit_count\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = false THEN 1 ELSE 0 END) AS planet_protection_unsubscribed_debit_count\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = true THEN amount ELSE 0 END) AS planet_protection_subscribed_debit_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = false THEN amount ELSE 0 END) AS planet_protection_unsubscribed_debit_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = true THEN emissions_amount ELSE 0 END) AS planet_protection_subscribed_debit_emissions_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = false THEN emissions_amount ELSE 0 END) AS planet_protection_unsubscribed_debit_emissions_amount\n    FROM bi_new.dt_depository_transactions\n    --where post_date >= (current_date - 70)\n    GROUP BY 1, 2\n    )\n     , final_txn as (\n  SELECT a.unique_account_id\n    , account_type\n    , a.date\n    , a.daily_balance\n    , a.original_balance\n    , a.spend_daily_balance\n    , a.save_daily_balance\n    , a.has_set_recurring_deposit\n    , CASE WHEN acc.initial_transfer_posted_date IS NULL OR acc.initial_transfer_posted_date > a.date THEN FALSE ELSE TRUE END AS is_funded\n    , CASE WHEN account_type = 'Checking' THEN coalesce(daily_bill_pay_amount, 0) ELSE NULL END AS daily_bill_pay_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(daily_bill_pay_count, 0) ELSE NULL END AS daily_bill_pay_count\n    , CASE WHEN termination_date IS NULL OR termination_date > a.date THEN FALSE ELSE TRUE END AS is_terminated\n    , CASE WHEN tco.charge_off_date IS NULL OR tco.charge_off_date > a.date THEN FALSE ELSE TRUE END AS is_charged_off   \n    , coalesce(monthly_fee_setting, daily_balance * yearly_percent_setting / 12) AS monthly_usd_fee_setting\n    , coalesce(yearly_percent_setting, CASE WHEN daily_balance = 0 THEN 0 ELSE monthly_fee_setting * 12 / (1.0 * daily_balance) END) AS yearly_percent_fee_setting\n    , coalesce(previous_day_monthly_fee_setting, daily_balance * previous_day_yearly_percent_setting / 12) AS previous_day_monthly_usd_fee_setting\n    , coalesce(previous_day_yearly_percent_setting, CASE WHEN daily_balance = 0 THEN 0 ELSE previous_day_monthly_fee_setting * 12 / (1.0 * daily_balance) END) AS previous_day_yearly_percent_fee_setting\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_withdrawal_amount, 0) ELSE NULL END AS ach_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_withdrawal_count, 0) ELSE NULL END AS ach_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_ach_withdrawal_amount, 0) ELSE NULL END AS largest_ach_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_deposit_amount, 0) ELSE NULL END AS ach_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_deposit_count, 0) ELSE NULL END AS ach_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_ach_deposit_amount, 0) ELSE NULL END AS largest_ach_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_no_pin_amount, 0) ELSE NULL END AS dbt_card_no_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_no_pin_count, 0) ELSE NULL END AS dbt_card_no_pin_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_dbt_card_no_pin_amount, 0) ELSE NULL END AS largest_dbt_card_no_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_pin_amount, 0) ELSE NULL END AS dbt_card_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_pin_count, 0) ELSE NULL END AS dbt_card_pin_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_dbt_card_pin_amount, 0) ELSE NULL END AS largest_dbt_card_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(interest_amount, 0) ELSE NULL END AS interest_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_withdrawal_amount, 0) ELSE NULL END AS check_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_withdrawal_count, 0) ELSE NULL END AS check_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_check_withdrawal_amount, 0) ELSE NULL END AS largest_check_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_deposit_amount, 0) ELSE NULL END AS check_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_deposit_count, 0) ELSE NULL END AS check_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(actual_pwif_paid, 0) ELSE NULL END AS actual_pwif_paid\n    , CASE WHEN account_type = 'Checking' THEN coalesce(cashback, 0) ELSE NULL END AS cashback\n    , CASE WHEN account_type = 'Checking' THEN coalesce(promo, 0) ELSE NULL END AS promo\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_check_deposit_amount, 0) ELSE NULL END AS largest_check_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_withdrawal_amount, 0) ELSE NULL END AS wire_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_withdrawal_count, 0) ELSE NULL END AS wire_withdrawal_count\n    , CASE when account_type = 'Checking' THEN coalesce(internal_transfer_deposit, 0) ELSE NULL END AS internal_transfer_deposit\n    , CASE when account_type = 'Checking' THEN coalesce(internal_transfer_withdrawal, 0) ELSE NULL END AS internal_transfer_withdrawal\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_wire_withdrawal_amount, 0) ELSE NULL END AS largest_wire_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_deposit_amount, 0) ELSE NULL END AS wire_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_deposit_count, 0) ELSE NULL END AS wire_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_wire_deposit_amount, 0) ELSE NULL END AS largest_wire_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_deposit_amount, 0) ELSE NULL END AS atm_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_deposit_count, 0) ELSE NULL END AS atm_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_atm_deposit_amount, 0) ELSE NULL END AS largest_atm_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_withdrawal_amount, 0) ELSE NULL END AS atm_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_withdrawal_count, 0) ELSE NULL END AS atm_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_atm_withdrawal_amount, 0) ELSE NULL END AS largest_atm_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_fee_refund_amount, 0) ELSE NULL END AS atm_fee_refund_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_debit_amount, 0) ELSE NULL END AS aim_debit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_debit_count, 0) ELSE NULL END AS aim_debit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_people_transaction_average, 0) ELSE NULL END AS aim_people_transaction_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_people_dollar_weighted_average, 0) ELSE NULL END AS aim_people_dollar_weighted_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(0.5 * aim_people_transaction_average + 0.5 * aim_people_dollar_weighted_average, 0) ELSE NULL END AS daily_aim_people_score\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_planet_transaction_average, 0) ELSE NULL END AS aim_planet_transaction_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_planet_transaction_average, 0) ELSE NULL END AS aim_planet_dollar_weighted_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(0 / 5 * aim_planet_transaction_average + 0.5 * aim_planet_dollar_weighted_average, 0) ELSE NULL END AS daily_aim_planet_score\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_deposit_count, 0) ELSE NULL END AS other_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_deposit_amount, 0) ELSE NULL END AS other_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_withdrawal_count, 0) ELSE NULL END AS other_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_withdrawal_amount, 0) ELSE NULL END AS other_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aplus_fee_paid, 0) ELSE NULL END AS aplus_fee_paid\n    , CASE WHEN account_type = 'Checking' THEN coalesce(pyc_revenue_amount, 0) ELSE NULL END AS pyc_revenue_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(interchange_fee_amount, 0) ELSE NULL END AS interchange_fee_amount\n    , CASE WHEN account_type = 'Checking' AND pps.unique_account_id IS NOT NULL THEN TRUE ELSE FALSE END AS planet_protection_subscription_active\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_subscribed_debit_count, 0) ELSE NULL END AS planet_protection_subscribed_debit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_unsubscribed_debit_count, 0) ELSE NULL END AS planet_protection_unsubscribed_debit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_subscribed_debit_amount, 0) ELSE NULL END AS planet_protection_subscribed_debit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_unsubscribed_debit_amount, 0) ELSE NULL END AS planet_protection_unsubscribed_debit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_subscribed_debit_emissions_amount, 0) ELSE NULL END AS planet_protection_subscribed_debit_emissions_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_unsubscribed_debit_emissions_amount, 0) ELSE NULL END AS planet_protection_unsubscribed_debit_emissions_amount\n    , csh.SEGMENTS as RFM_SCORE\n    , CASE WHEN account_type = 'Checking' THEN psh.is_pyc_paused ELSE NULL END AS is_pyc_paused\n  FROM (\n    SELECT *\n    FROM etl.DAILY_BALANCES\n    --WHERE DATE >= (current_date - 70)\n    UNION ALL\n    SELECT *\n    FROM bi_new.dt_investment_daily_balances_tmp_3\n    --WHERE DATE >= (current_date - 70)\n    ) a\n  JOIN bi_new.dt_accounts acc ON a.unique_account_id = acc.unique_account_id\n  LEFT JOIN billpay pay ON a.unique_account_id = pay.unique_account_id AND a.date = pay.check_creation_date\n  LEFT JOIN bi_new.dt_account_daily_fee_settings_tmp dfs ON a.unique_account_id = dfs.unique_account_id AND a.date = dfs.date\n  LEFT JOIN transactions b ON a.unique_account_id = b.unique_account_id AND a.date = b.post_date\n  LEFT JOIN planet_protection_subscription pps ON a.unique_account_id = pps.unique_account_id AND a.date = pps.date\n  LEFT JOIN etl.tmp_charge_off tco on acc.UNIQUE_ACCOUNT_ID = tco.UNIQUE_ACCOUNT_ID     \n  LEFT JOIN rdl.cma_segments_history csh on a.unique_account_id = csh.unique_account_id AND a.date = csh.file_date\n  LEFT JOIN psh ON acc.USER_ID = psh.USER_ID AND a.date = psh.date\n\n         )\n  SELECT a.*\n    , a.monthly_usd_fee_setting - a.previous_day_monthly_usd_fee_setting AS day_over_day_monthly_fee_setting_change\n    , a.yearly_percent_fee_setting - a.previous_day_yearly_percent_fee_setting AS day_over_day_yearly_fee_setting_change\n    , a.unique_account_id || '-' || to_varchar(a.date,'yyyymmdd') AS unique_id\n  FROM final_txn a\n  order by a.unique_account_id, a.date\n);\n\n\n\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_2;\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_3;\nDROP TABLE IF EXISTS bi_new.dt_account_daily_fee_settings_tmp;\nDROP TABLE IF EXISTS bi_new.dt_summit_daily_balances_tmp_2;\nDROP TABLE IF EXISTS etl.tmp_charge_off;\n/*\n--append new data to daily table\ndrop table if exists bi_new.dt_account_daily_data;\ncreate table bi_new.dt_account_daily_data clone bi.dt_account_daily_data;\n\ndelete from bi_new.dt_account_daily_data\nwhere date >= (select min(date) from bi_new.dt_account_daily_data_new);\n\ninsert into bi_new.dt_account_daily_data\nselect *\nfrom bi_new.dt_account_daily_data_new;\n\ndrop table if exists bi_new.dt_account_daily_data_new;\n*/\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022970":{"id":3022970,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-560,"y":-256,"width":32,"height":32,"inputConnectorIDs":[3023040],"outputSuccessConnectorIDs":[3023046],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_transfers"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\nDROP TABLE IF EXISTS bi_new.dt_transfers;\nCREATE TABLE bi_new.dt_transfers\nAS\n(\n  WITH investment_transfers AS (\n    WITH orders AS (\n        --cte's below used to remove duplicates\n        WITH cte_investment_txn AS (\n            SELECT order_txn_id,\n                   settled_date::DATE AS settled_date,\n                   row_number() over (partition by order_txn_id\n                                          order by id desc) AS rn\n            FROM web_db.investment_txn\n          ),\n        cte_investment AS (\n            SELECT id,\n                   account_id,\n                   fund_id,\n                   row_number() over (partition by account_id, fund_id\n                                          order by last_updated desc) AS rn\n            FROM web_db.investment\n          )\n        SELECT\n          'it' || ot.id        AS unique_order_transaction_id,\n          ot.user_id,\n          ot.is_rollover,\n          i.id                 AS investment_id,\n          ot.fund_id,\n          ot.txn_type_id,\n          CASE status\n          WHEN 1\n            THEN 'New'\n          WHEN 2\n            THEN 'Processing'\n          WHEN 3\n            THEN 'Processed'\n          WHEN 4\n            THEN 'Cancelled'\n          WHEN 5\n            THEN 'Rejected'\n          WHEN 6\n            THEN 'Pending' END AS transaction_status,\n          CASE WHEN ot.liquidation_type_id IS NOT NULL\n            THEN -ot.amount\n          ELSE ot.amount END   AS transaction_amount,\n          ot.id                AS order_transaction_id,\n          ot.date_created,\n          ot.user_payment_account_id,\n          ot.txn_date,\n          CASE WHEN ot.status = 3 THEN it.settled_date::date\n            ELSE NULL END AS post_date,\n          CASE WHEN recurring_order_txn_id IS NOT NULL\n            THEN TRUE\n          ELSE FALSE END       AS is_recurring_transfer,\n\n          CASE rot.frequency\n            WHEN 0 THEN 'undefined'\n            WHEN 1 THEN 'monthly'\n            WHEN 2 THEN 'weekly'\n            WHEN 3 THEN 'biweekly'\n          END AS recurring_frequency\n\n        FROM web_db.order_txn ot\n          INNER JOIN web_db.account a ON ot.account_id = a.id\n          INNER JOIN cte_investment i ON a.id = i.account_id\n                                           AND ot.fund_id = i.fund_id\n                                           AND i.rn = 1\n          LEFT JOIN cte_investment_txn it ON ot.id::VARCHAR = it.order_txn_id\n                                                AND it.rn = 1\n          LEFT JOIN web_db.recurring_order_txn rot ON ot.recurring_order_txn_id = rot.id\n        WHERE ot.amount IS NOT NULL\n          AND ot.amount <> 0\n    )\n    SELECT\n      unique_order_transaction_id    AS unique_transfer_id,\n      o.user_id                      AS user_id,\n      'i' || o.investment_id :: TEXT AS unique_account_id,\n      o.user_payment_account_id,\n      transaction_status,\n      o.txn_date::DATE               AS transaction_date,\n      o.post_date::DATE              AS post_date,\n      'Investment transfer'          AS category,\n      o.transaction_amount           AS amount,\n      CASE\n      WHEN o.is_rollover = TRUE\n        THEN 'Rollover'\n      WHEN o.transaction_amount > 0\n        THEN 'Buy/Deposit'\n      WHEN o.transaction_amount < 0\n        THEN 'Sell/Withdrawal'\n      END                            AS transfer_type,\n      CASE WHEN o.transaction_amount > 0 THEN upper(NVL(p.name, upa.name))\n           WHEN o.transaction_amount < 0 THEN upper(f.name)\n           ELSE 'Unknown'\n      END AS from_account,\n      CASE WHEN o.transaction_amount > 0 THEN upper(f.name)\n           WHEN o.transaction_amount < 0 THEN upper(NVL(p.name, upa.name))\n           ELSE 'Unknown'\n      END AS to_account,\n      NULL AS originating_account,                                                        \n      o.is_recurring_transfer        AS is_recurring_transfer,\n      o.recurring_frequency,\n      NULL AS return_reason_code,\n      NULL AS return_reason_code_description\n    FROM orders o\n    LEFT JOIN web_db.user_payment_account upa ON o.user_payment_account_id = upa.id\n    LEFT JOIN web_db.depository d ON upa.depository_id = d.id\n    LEFT JOIN web_db.product p ON d.product_id = p.id\n    LEFT JOIN web_db.fund f ON o.fund_id = f.id\n    LEFT JOIN web_db.txn_type tt ON o.txn_type_id = tt.id\n  )\n    ,\nchecking_transfers\nAS\n           (\n               --cte's below used to fuzzy match radius transfers to miser posted transactions\n               --based on amount and date\n               with cte_dt as (\n                   select *,\n                          CASE\n                              WHEN type = 1 THEN amount\n                              WHEN type = 2 THEN -amount\n                              END                     AS amount_with_sign,\n                          row_number() over (partition by depository_id, amount_with_sign\n                              order by transfer_date) as rn\n                   from web_db.depository_transfer\n                   where status = 3 --'Processed'\n               )\n\n                  , cte_miser\n                   as\n                   (\n                       select *,\n                              row_number() over (partition by depository_id, amount\n                                  order by transaction_date) as rn\n                       from web_db.miser_transaction\n                       where ach_seq_number is not null\n                   )\n                  ,\n--get all depositories for an account\ncte_dt_accounts as (\n    select\n      dta.unique_account_id,\n      dep2.id as depository_id\n    from bi_new.dt_accounts dta\n    join web_db.depository dep on dta.galileo_id = dep.id\n    join web_db.depository dep2 on dep.account_id = dep2.account_id\n    group by 1,2\n  )\n  ,\n             \ngalileo_transfers\nAS\n(\n    SELECT \n        'gt' || gat.id AS unique_transfer_id,\n          upa.user_id,\n          dta.unique_account_id,\n          gat.user_payment_account_id,\n\n          CASE WHEN rad.return_code is not null THEN 'Returned' ELSE\n              CASE gat.status\n                WHEN 1 THEN 'New'\n                WHEN 2 THEN 'Processing'\n                WHEN 3 THEN 'Processed'\n                WHEN 4 THEN 'Cancelled'\n                WHEN 5 THEN 'Rejected'\n                WHEN 6 THEN 'Initial Funding'\n                WHEN 7 THEN 'Returned'\n               END\n           END AS transaction_status,\n\n          gat.transfer_date::DATE AS transaction_date,\n          txn.post_date,\n          gat.category,\n\n          CASE\n            WHEN gat.type = 'Deposit' THEN gat.amount\n            WHEN gat.type = 'Withdrawal' THEN -gat.amount\n          END AS amount,\n\n          CASE\n            WHEN gat.type = 'Deposit' THEN 'Buy/Deposit'\n            WHEN gat.type = 'Withdrawal' THEN 'Sell/Withdrawal'\n          END AS transfer_type,\n\n          CASE WHEN gat.type = 'Deposit' THEN upper(NVL(p2.name,upa.name))\n               WHEN gat.type = 'Withdrawal' THEN upper(p.name)\n               ELSE 'Unknown'\n          END AS from_account,\n\n          CASE WHEN gat.type = 'Deposit' THEN upper(p.name)\n               WHEN gat.type = 'Withdrawal' THEN upper(NVL(p2.name,upa.name))\n               ELSE 'Unknown'\n          END AS to_account,\n          upper(p.name) AS originating_account,                                                           \n\n          CASE WHEN gat.recurring_transfer_id IS NOT NULL\n               THEN TRUE ELSE FALSE END AS is_recurring_transfer,\n\n          lower(rt.frequency) AS recurring_frequency,\n          rad.return_code as return_reason_code,\n          larrc.return_reason_code_description\n\n        FROM web_db.galileo_ach_transaction gat\n        INNER JOIN web_db.user_payment_account upa ON (upa.id = gat.user_payment_account_id)\n\n        LEFT JOIN rdl.ach_galileo_detail rad ON gat.transaction_id = rad.transaction_id\n\n        LEFT JOIN dw.lkp_ach_return_reason_codes larrc ON (larrc.return_reason_code = rad.return_code)\n\n        INNER JOIN cte_dt_accounts dta ON (dta.depository_id = gat.depository_id)\n        LEFT JOIN web_db.depository d ON gat.depository_id = d.id\n        LEFT JOIN web_db.product p ON d.product_id = p.id\n        LEFT JOIN web_db.depository d2 ON upa.depository_id = d2.id\n        LEFT JOIN web_db.product p2 ON d2.product_id = p2.id\n        LEFT JOIN\n        (\n            SELECT external_transaction_id,\n                          depository_id,\n                          (LEFT(t.post_date,2) || '/' || SUBSTRING(t.post_date,3,2) || '/'\n                             || RIGHT(t.post_date,4))::date as post_date,\n                          --added below due to the Sept 2019 duplicate ACH issue\n                          row_number() over (partition by t.external_transaction_id order by t.id desc) as rn\n           FROM web_db.galileo_posted_transaction t\n           JOIN web_db.posted_transaction pt ON (t.posted_transaction_id = pt.id)\n        ) txn ON (gat.transaction_id = txn.external_transaction_id AND gat.depository_id = txn.depository_id AND txn.rn = 1)\n\n        LEFT JOIN web_db.recurring_transfer rt on gat.recurring_transfer_id = rt.recurring_transfer_id\n)\n\n        SELECT\n          'rt' || dt.id AS unique_transfer_id,\n          dt.user_id,\n          dta.unique_account_id,\n          dt.user_bank_account_id AS user_payment_account_id,\n\n          CASE dt.status\n            WHEN 1 THEN 'New'\n            WHEN 2 THEN 'Processing'\n            WHEN 3 THEN 'Processed'\n            WHEN 4 THEN 'Cancelled'\n            WHEN 5 THEN 'Rejected'\n            WHEN 6 THEN 'Pending'\n          END AS transaction_status,\n\n          dt.transfer_date::DATE AS transaction_date,\n          pd.posting_date::DATE  AS post_date,\n          'ACH transfer'         AS category,\n          CASE\n            WHEN dt.type = 1 THEN dt.amount\n            WHEN dt.type = 2 THEN -dt.amount\n          END AS amount,\n\n          CASE\n            WHEN dt.type = 1 THEN 'Buy/Deposit'\n            WHEN dt.type = 2 THEN 'Sell/Withdrawal'\n          END AS transfer_type,\n\n          CASE WHEN dt.type = 1 THEN upper(NVL(p2.name,upa.name))\n               WHEN dt.type = 2 THEN upper(p.name)\n               ELSE 'Unknown'\n          END AS from_account,\n          CASE WHEN dt.type = 1 THEN upper(p.name)\n               WHEN dt.type = 2 THEN upper(NVL(p2.name,upa.name))\n               ELSE 'Unknown'\n          END AS to_account,\n          upper(p.name) AS originating_account,\n\n          CAST(NULL AS BOOLEAN) AS is_recurring_transfer,\n          NULL AS recurring_frequency,\n          NULL AS return_reason_code,\n          NULL AS return_reason_code_description\n        FROM web_db.depository_transfer dt\n        INNER JOIN bi_new.dt_accounts dta ON (dta.radius_id = dt.depository_id)\n        INNER JOIN web_db.user_payment_account upa ON (upa.id = dt.user_bank_account_id)\n\n        LEFT JOIN\n        (\n            SELECT dt2.id,\n                          m.posting_date\n           FROM cte_dt dt2\n           INNER JOIN cte_miser m ON dt2.depository_id = m.depository_id\n                                 AND dt2.amount_with_sign = m.amount\n                                 AND dt2.rn = m.rn\n        ) pd ON dt.id = pd.id\n              --adding date restriction since this is\n              --fuzzy matching\n              AND pd.posting_date::date >= dt.transfer_date::date\n\n        LEFT JOIN web_db.depository d ON dt.depository_id = d.id\n        LEFT JOIN web_db.product p ON d.product_id = p.id\n        LEFT JOIN web_db.depository d2 ON upa.depository_id = d2.id\n        LEFT JOIN web_db.product p2 ON d2.product_id = p2.id\n        WHERE 1=1\n          AND dt.amount <> 0\n          AND dt.amount IS NOT NULL\n\n        UNION ALL\n\n        SELECT unique_transfer_id,\n               user_id,\n               unique_account_id,\n               user_payment_account_id,\n               transaction_status,\n               transaction_date,\n               post_date,\n               category,\n               amount,\n               transfer_type,\n               from_account,\n               to_account,\n               originating_account,                                               \n               is_recurring_transfer,\n               recurring_frequency,\n               return_reason_code,\n               return_reason_code_description\n        FROM galileo_transfers gt\n\n),\n\n      combined_data AS (\n        SELECT *\n        FROM investment_transfers\n        UNION ALL\n        SELECT *\n        FROM checking_transfers\n    )\n  SELECT a.*,\n    CASE\n        WHEN b.unique_account_id IS NOT NULL AND is_recurring_transfer = FALSE THEN TRUE\n        ELSE FALSE\n    END AS is_first_day_transfer\n  FROM combined_data a\n  LEFT JOIN\n  (\n    SELECT unique_account_id,\n        min(transaction_date) AS min_date\n    FROM combined_data\n    GROUP BY 1\n  ) b ON a.unique_account_id = b.unique_account_id AND a.transaction_date = b.min_date\n)\n;"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022971":{"id":3022971,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-560,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023038],"outputSuccessConnectorIDs":[3023007],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_ace_tickets"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\n--complaint data\ndrop table if exists tmp_complaint;\ncreate temp table tmp_complaint as\nwith complaint as (\nselect\n    TICKET_ID,\n    FIELD_NAME,\n    nullif(trim(replace(replace(replace(replace(replace(FIELD_VALUE,\n            ',',', '),'\"',''),'_',' '),'[',''),']','')),'') as FIELD_VALUE_CLEAN\nfrom rdl.ZENDESK_TICKET_CUSTOM_FIELDS\nwhere FIELD_NAME in ('360012081972','360048866551','360048816192','360048802811',\n       '1900002470667','1900002470767','360048798992','1900002487727',\n       '6347258712205','6519489634189')\nand FIELD_VALUE_CLEAN is not null\n)\n, ticket as (\n    select TICKET_ID\n    from complaint\n    group by 1\n)\nselect zt.TICKET_ID,\n    c1.FIELD_VALUE_CLEAN as customer_uuid,\n    c2.FIELD_VALUE_CLEAN as complaint_received_date,\n    c3.FIELD_VALUE_CLEAN as complaint_response_date,\n    c4.FIELD_VALUE_CLEAN as complaint_products_affected,\n    c5.FIELD_VALUE_CLEAN as complaint_investment_customer,\n    c6.FIELD_VALUE_CLEAN as complaint_locked_status,\n    c7.FIELD_VALUE_CLEAN as complaint_allegation,\n    c8.FIELD_VALUE_CLEAN as complaint_format,\n    split_part(c9.FIELD_VALUE_CLEAN,'  ',1) as complaint_category,\n    replace(replace(split_part(c9.FIELD_VALUE_CLEAN,'  ',2) || ' '\n        || split_part(c9.FIELD_VALUE_CLEAN,'  ',3),' s ', '''s '), ' t ','''t ') as complaint_subcategory,\n    c10.FIELD_VALUE_CLEAN as complaint_tier\nfrom ticket zt\nleft join complaint c1 on zt.TICKET_ID = c1.TICKET_ID and c1.FIELD_NAME = '360012081972'\nleft join complaint c2 on zt.TICKET_ID = c2.TICKET_ID and c2.FIELD_NAME = '360048866551'\nleft join complaint c3 on zt.TICKET_ID = c3.TICKET_ID and c3.FIELD_NAME = '360048816192'\nleft join complaint c4 on zt.TICKET_ID = c4.TICKET_ID and c4.FIELD_NAME = '360048802811'\nleft join complaint c5 on zt.TICKET_ID = c5.TICKET_ID and c5.FIELD_NAME = '1900002470667'\nleft join complaint c6 on zt.TICKET_ID = c6.TICKET_ID and c6.FIELD_NAME = '1900002470767'\nleft join complaint c7 on zt.TICKET_ID = c7.TICKET_ID and c7.FIELD_NAME = '360048798992'\nleft join complaint c8 on zt.TICKET_ID = c8.TICKET_ID and c8.FIELD_NAME = '1900002487727'\nleft join complaint c9 on zt.TICKET_ID = c9.TICKET_ID and c9.FIELD_NAME = '6347258712205'\nleft join complaint c10 on zt.TICKET_ID = c10.TICKET_ID and c10.FIELD_NAME = '6519489634189'\n;\n\n--ticket data\ndrop table if exists tmp_ticket;\ncreate temporary table tmp_ticket\nas\nselect zt.id as ticket_id,\n       case\n          --defaulting to 'Ticket Form' for nulls because they stopped before 'Ops Ticket' started\n          when zt.ticket_form_id = 44594 or (zt.ticket_form_id is null and zt.created_at::date <= '2017-06-16')\n            then 'Ticket Form'\n          when zt.ticket_form_id = 360000144692 then 'Ops Ticket'\n          when zt.ticket_form_id = 360003458271 then 'Compliance Complaint Ticket'\n          when zt.ticket_form_id = 360001004551 then 'Data Subject Access Request Form'\n          when zt.ticket_form_id = 1900000406407 then 'Bug Form'\n          when zt.ticket_form_id = 4416845638925 then 'Report of Dispute' \n          else 'Unknown'\n        end as form,\n\tzt.requester_id as crm_user_id,\n\tzu.email as crm_user_email,\n\tcase\n\t  when zu.phone like '%@%' and zu.phone = zu.email then null\n          when zu.phone LIKE '+%' and len(zu.phone) = 11 then replace(zu.phone, '+', '')\n          else regexp_replace(replace(zu.phone,'+1',''),'[[:punct:][:space:][:alpha:]]','')\n\tend as crm_phone_number,\n\tzt.channel,\n\tzt.created_at,\n\tzt.updated_at,\n\tzt.subject,\n\tzt.description,\n\tzt.priority,\n        zt.status,\n        zu.role as requester_role,\n    zt.assignee_id,\n    zt.tags,\n  \t\t\tzui.name as assignee_name,\n\t\t\tzui.role as assignee_role,\n    zt.group_id,\n    zt.EXTERNAL_ID,\n    c.customer_uuid,\n    c.complaint_received_date,\n    c.complaint_response_date,\n    c.complaint_products_affected,\n    c.complaint_investment_customer,\n    c.complaint_locked_status,\n    c.complaint_allegation,\n    c.complaint_format,\n    c.complaint_category,\n    c.complaint_subcategory,\n    c.complaint_tier\nfrom prod_zendesk.zendesk_tickets_incremental zt\nleft join prod_zendesk.zendesk_users_incremental zu on zu.id = zt.requester_id\nleft join prod_zendesk.zendesk_users_incremental zui on zui.id = zt.assignee_id\nleft join tmp_complaint c on zt.ID = c.TICKET_ID\n;\n\n--distinct email list\ndrop table if exists tmp_email;\ncreate temporary table tmp_email\nas\nwith cte_email_dtu as (\n  select dtu.user_id,\n         dtu.user_email,\n         --prioritizing non-deleted, enabled accounts\n         row_number() over (partition by dtu.user_email\n                                order by u.account_expired asc nulls last,\n                                         u.enabled desc nulls last,\n                                         u.id asc nulls last) as email_rank\n\tfrom bi_new.dt_users dtu\n\tjoin web_db._user u on dtu.user_id = u.id\n),\ncte_email_webdb as (\n  select ue.user_id,\n\t ue.email as user_email,\n\t --prioritizing non-deleted, enabled accounts\n         row_number() over (partition by ue.email\n                                order by u.account_expired asc nulls last,\n                                         u.enabled desc nulls last,\n                                         u.id asc nulls last) as email_rank\n  from web_db.user_email ue\n  join web_db._user u on ue.user_id = u.id\n  left join cte_email_dtu edtu on ue.email = edtu.user_email\n  where edtu.user_email is null\n)\nselect user_id,\n       user_email\nfrom cte_email_dtu\nwhere email_rank = 1\n\nunion all\n\nselect user_id,\n       user_email\nfrom cte_email_webdb\nwhere email_rank = 1\n;\n\n--distinct phone list\ndrop table if exists tmp_phone;\ncreate temporary table tmp_phone\nas\nwith cte_phone as (\n    select up.user_id,\n       case\n         when up.phone_number LIKE '1%' and len(up.phone_number) = 11\n\t then substring(up.phone_number, 2, 15)\n         else regexp_replace(replace(up.phone_number,'+1',''),'[[:punct:][:space:][:alpha:]]','')\n       end as phone,\n       u.account_expired, u.enabled,\n       --prioritizing non-deleted, enabled accounts\n       row_number() over (partition by phone\n                              order by u.account_expired asc nulls last,\n                                       u.enabled desc nulls last,\n                                       u.id asc nulls last) as phone_rank\n    from web_db.user_profile up\n    join web_db._user u on up.user_id = u.id\n    where up.phone_number is not null\n)\nselect user_id,\n       nullif(trim(phone),'') as phone_number\nfrom cte_phone\nwhere phone_rank = 1\n;\n\n--request topic list\ndrop table if exists tmp_request_topic;\ncreate temporary table tmp_request_topic\nas\nwith topic as (\n    select\n      p.ticket_id,\n      nvl(tp.product_display,nullif(trim(p.field_value),'')) as product,\n      nullif(t.field_value,'') as topic_full,\n      initcap(\n          replace(\n              case when charindex('__',t.field_value) = 0 and right(t.field_value,length(tp.CATEGORY)) = tp.CATEGORY\n                   then left(t.field_value, length(t.field_value) - ifnull(length(tp.CATEGORY),0))\n                   else nullif(split_part(t.field_value,'__',1),'')\n              end\n          , '_',' ')) as request_topic,\n       split_part(t.field_value,'__',2) as request_subtopic_split,\n       initcap(\n         replace(\n             case when charindex('__',t.field_value) = 0\n                 then null\n                 else case when right(t.field_value,length(tp.CATEGORY)) = tp.CATEGORY\n                           then left(request_subtopic_split, length(request_subtopic_split) - ifnull(length(tp.CATEGORY),0))\n                           else request_subtopic_split end\n             end\n         , '_',' ')) as request_subtopic\n    from rdl.zendesk_ticket_custom_fields p\n    left join etl.zendesk_topics tp on p.field_value = tp.product\n    left join rdl.zendesk_ticket_custom_fields t on p.ticket_id = t.ticket_id\n                                                and trim(t.field_name) = tp.TOPIC_ID\n    join tmp_ticket tt on p.TICKET_ID = tt.ticket_id\n    where p.field_name = '34437827' --main products code\n    and nullif(trim(p.FIELD_VALUE),'') is not null\n    and p.FIELD_VALUE != 'X'\n)\nselect\n    TICKET_ID,\n    product,\n    topic_full,\n    replace(replace(replace(replace(replace(replace(replace(replace(request_topic,\n       'Ach ','ACH '),'Cma ','CMA '),'Aim','AIM'),'Atm ','ATM '),'Ira','IRA'),\n       'Ios','IOS'),'Ssn','SSN'),'Fdic','FDIC') as request_topic,\n    replace(replace(replace(replace(replace(replace(replace(replace(request_subtopic,\n       'Ach ','ACH '),'Cma ','CMA '),'Aim','AIM'),'Atm ','ATM '),'Ira','IRA'),\n       'Ios','IOS'),'Ssn','SSN'),'Fdic','FDIC') as request_subtopic\nfrom topic;\n\n--final ace tickets table\ndrop table if exists bi_new.dt_ace_tickets;\ncreate table bi_new.dt_ace_tickets\nas\nwith tickets as (\n  select row_number() over(order by zt.ticket_id) as unique_id,\n          nvl(e.user_id,p.user_id) as user_id,\n          zt.*,\n          rt.product,\n          rt.request_topic,\n          rt.request_subtopic\n  from tmp_ticket zt\n  left join tmp_email e on zt.crm_user_email = e.user_email\n  left join tmp_phone p on zt.crm_phone_number = p.phone_number\n  left join tmp_request_topic rt on zt.ticket_id = rt.ticket_id\n),\nlogin as (\n  select\n    t.ticket_id,\n    max(uat.date_created) as most_recent_prior_login\n  from web_db.user_audit_trail uat\n  join tickets t on uat.user_id = t.user_id\n  where uat.audit_trail ilike 'Logged In'\n  and t.created_at > uat.date_created\n  --excluding logins from Intuit software\n  --this is also done in user_daily_data login count code\n  and ip_address not like '206.108.41.10%'\n  and t.user_id is not null\n  group by 1\n)\nselect\n  t.*,\n  l.most_recent_prior_login\nfrom tickets t\nleft join login l on t.ticket_id = l.ticket_id\n;\n\n\n--ace ticket tags\ndrop table if exists bi_new.dt_ace_ticket_tags;\ncreate table bi_new.dt_ace_ticket_tags\nas\nwith cte_tag as (\n\tselect distinct\n\t       dat.ticket_id,\n\t       lztt.tag_name\n\tfrom bi_new.dt_ace_tickets dat\n\tinner join rdl.zendesk_ticket_tags_incremental ztt on (ztt.zendesk_tickets_id = dat.ticket_id)\n\tinner join rdl.lkp_zendesk_ticket_tags lztt on (lztt.lkp_zendesk_ticket_tags_id = ztt.lkp_zendesk_ticket_tags_id)\n)\nselect row_number() over(order by t.ticket_id) as unique_id,\n       t.ticket_id,\n       t.tag_name\nfrom cte_tag t\n;"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022972":{"id":3022972,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-736,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023041],"outputSuccessConnectorIDs":[3023025,3023027],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_account_monthly_data"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\ndrop table if exists bi_new.dt_account_monthly_data_tmp;\n\nCREATE TABLE bi_new.dt_account_monthly_data_tmp\nAS (\n    SELECT unique_account_id\n      , date_trunc('month', date)::DATE AS month\n      , avg(daily_balance) AS average_balance\n      , min(daily_balance) AS lowest_monthly_balance\n      , max(daily_balance) AS peak_monthly_balance\n      , avg(original_balance) AS average_balance_actual\n      , min(original_balance) AS lowest_monthly_balance_actual\n      , max(original_balance) AS peak_monthly_balance_actual\n      , avg(spend_daily_balance) AS average_spend_balance_actual\n      , min(spend_daily_balance) AS lowest_monthly_spend_balance_actual\n      , max(spend_daily_balance) AS peak_monthly_spend_balance_actual\n      , avg(save_daily_balance) AS average_save_balance_actual\n      , min(save_daily_balance) AS lowest_monthly_save_balance_actual\n      , max(save_daily_balance) AS peak_monthly_save_balance_actual\n      , sum(dbt_card_no_pin_amount) AS monthly_debit_card_no_pin_amount\n      , sum(dbt_card_pin_amount) AS monthly_debit_card_pin_amount\n      , sum(aim_debit_count)::decimal(38,6) AS monthly_aim_scored_transactions\n      , sum(aim_debit_amount)::decimal(38,6) AS monthly_aim_scored_transactions_amount\n      , sum(dbt_card_no_pin_count) AS monthly_debit_card_no_pin_transactions\n      , sum(dbt_card_pin_count) AS monthly_debit_card_pin_transactions\n      , sum(daily_bill_pay_amount) AS monthly_bill_pay_amount\n      , sum(daily_bill_pay_count) AS monthly_bill_pay_count\n      , sum(ach_withdrawal_amount) AS ach_withdrawal_amount\n      , sum(ach_deposit_amount) AS ach_deposit_amount\n      , sum(atm_deposit_amount) AS atm_deposit_amount\n      , sum(atm_withdrawal_amount) AS atm_withdrawal_amount\n      , sum(wire_withdrawal_amount) AS wire_withdrawal_amount\n      , sum(wire_deposit_amount) AS wire_deposit_amount\n      , sum(check_withdrawal_amount) AS check_withdrawal_amount\n      , sum(check_deposit_amount) AS check_deposit_amount\n      , sum(actual_pwif_paid) as actual_pwif_paid\n      , sum(promo) as promo\n      , sum(cashback) as cashback\n      , sum(a.atm_fee_refund_amount) AS atm_fee_refund_amount\n      , sum(interest_amount) AS interest_amount\n      , sum(wire_withdrawal_count) AS wire_withdrawal_count\n      , sum(internal_transfer_deposit) as internal_transfer_deposit\n      , sum(internal_transfer_withdrawal) as internal_transfer_withdrawal\n      , sum(wire_deposit_count) AS wire_deposit_count\n      , sum(ach_deposit_count) AS ach_deposit_count\n      , sum(ach_withdrawal_count) AS ach_withdrawal_count\n      , sum(atm_deposit_count) AS atm_deposit_count\n      , sum(atm_withdrawal_count) AS atm_withdrawal_count\n      , sum(check_withdrawal_count) AS check_withdrawal_count\n      , sum(check_deposit_count) AS check_deposit_count\n      , max(largest_ach_deposit_amount) AS largest_ach_deposit_amount\n      , min(largest_ach_withdrawal_amount) AS largest_ach_withdrawal_amount\n      , min(largest_dbt_card_no_pin_amount) AS largest_dbt_card_no_pin_amount\n      , min(largest_dbt_card_pin_amount) AS largest_dbt_card_pin_amount\n      , max(largest_check_deposit_amount) AS largest_check_deposit_amount\n      , min(largest_check_withdrawal_amount) AS largest_check_withdrawal_amount\n      , max(largest_wire_deposit_amount) AS largest_wire_deposit_amount\n      , min(largest_wire_withdrawal_amount) AS largest_wire_withdrawal_amount\n      , max(largest_atm_deposit_amount) AS largest_atm_deposit_amount\n      , min(largest_atm_withdrawal_amount) AS largest_atm_withdrawal_amount\n      , CASE WHEN sum(aim_debit_count)= 0 THEN NULL\n        ELSE 0.5 * sum(aim_people_transaction_average  * aim_debit_count )/sum(aim_debit_count ) + 0.5 * sum(aim_people_dollar_weighted_average::decimal(38,6)   * aim_debit_amount::decimal(38,6) )/sum(aim_debit_amount::decimal(38,6)) END AS monthly_aim_people_score\n      , CASE WHEN sum(aim_debit_count) = 0 THEN NULL\n        ELSE (0.5 * sum(aim_planet_transaction_average * aim_debit_count)/sum(aim_debit_count) + 0.5 * sum(aim_planet_dollar_weighted_average::decimal(38,6)  * aim_debit_amount::decimal(38,6) )/sum(aim_debit_amount::decimal(38,6) )) END AS monthly_aim_planet_score\n      , sum(other_deposit_count) as other_deposit_count\n      , sum(other_deposit_amount) as other_deposit_amount\n      , sum(other_withdrawal_count) as other_withdrawal_count\n      , sum(other_withdrawal_amount) as other_withdrawal_amount\n      , case when sum(planet_protection_subscription_active::smallint) > 0 then TRUE else FALSE end as planet_protection_subscription_active\n      , sum(planet_protection_subscribed_debit_count) as planet_protection_subscribed_debit_count\n      , sum(planet_protection_unsubscribed_debit_count) as planet_protection_unsubscribed_debit_count\n      , sum(planet_protection_subscribed_debit_amount) as planet_protection_subscribed_debit_amount\n      , sum(planet_protection_unsubscribed_debit_amount) as planet_protection_unsubscribed_debit_amount\n      , sum(planet_protection_subscribed_debit_emissions_amount) as planet_protection_subscribed_debit_emissions_amount\n      , sum(planet_protection_unsubscribed_debit_emissions_amount) as planet_protection_unsubscribed_debit_emissions_amount\n    FROM bi_new.dt_account_daily_data a\n    GROUP BY 1, 2\n    );\n\ndrop table if exists bi_new.last_dates;\n\ncreate table bi_new.last_dates as (\n    SELECT unique_account_id\n      , date_trunc('month', date)::DATE AS month\n      , max(date) AS last_day_of_month\n    FROM bi_new.dt_account_daily_data\n    GROUP BY 1, 2\n);\n\ndrop table if exists  bi_new.end_of_month_data;\n\ncreate table bi_new.end_of_month_data as (\n    SELECT b.unique_account_id\n      , a.month\n      , b.yearly_percent_fee_setting\n      , b.monthly_usd_fee_setting\n      , daily_balance AS end_of_month_balance\n      , original_balance AS end_of_month_balance_actual\n      , spend_daily_balance AS end_of_month_spend_balance_actual\n      , save_daily_balance AS end_of_month_save_balance_actual\n      , is_terminated\n      , is_funded\n      , is_charged_off\n    FROM bi_new.last_dates a\n    JOIN bi_new.dt_account_daily_data b ON a.unique_account_id = b.unique_account_id AND a.last_day_of_month = b.date\n);\n\ndrop table if exists bi_new.dt_account_monthly_data_tmp1;\ncreate table bi_new.dt_account_monthly_data_tmp1 as (\n SELECT a.unique_account_id\n    , a.month\n    , a.peak_monthly_balance\n    , a.average_balance\n    , a.lowest_monthly_balance\n    , a.peak_monthly_balance_actual\n    , a.average_balance_actual\n    , a.lowest_monthly_balance_actual\n    , a.average_spend_balance_actual\n    , a.lowest_monthly_spend_balance_actual\n    , a.peak_monthly_spend_balance_actual\n    , a.average_save_balance_actual\n    , a.lowest_monthly_save_balance_actual\n    , a.peak_monthly_save_balance_actual\n    , a.monthly_aim_scored_transactions\n    , a.monthly_debit_card_pin_amount\n    , a.monthly_debit_card_no_pin_amount\n    , a.monthly_debit_card_pin_transactions\n    , a.monthly_debit_card_no_pin_transactions\n    , a.monthly_bill_pay_amount\n    , a.monthly_bill_pay_count\n    , b.end_of_month_balance\n    , b.end_of_month_balance_actual\n    , b.end_of_month_spend_balance_actual\n    , b.end_of_month_save_balance_actual\n    , b.yearly_percent_fee_setting\n    , CASE WHEN account_type = 'Checking' THEN b.monthly_usd_fee_setting ELSE b.yearly_percent_fee_setting * average_balance / 12 END AS monthly_usd_fee_setting\n    , b.is_terminated\n    , b.is_funded\n    , b.is_charged_off\n    , a.ach_deposit_amount\n    , a.ach_withdrawal_amount\n    , a.check_deposit_amount\n    , a.check_withdrawal_amount\n    , a.wire_deposit_amount\n    , a.wire_withdrawal_amount\n    , a.atm_deposit_amount\n    , a.atm_withdrawal_amount\n    , a.atm_fee_refund_amount\n    , a.interest_amount\n    , a.monthly_aim_people_score\n    , a.monthly_aim_planet_score\n    , a.wire_withdrawal_count\n    , a.wire_deposit_count\n    , a.internal_transfer_deposit\n    , a.internal_transfer_withdrawal\n    , a.ach_deposit_count\n    , a.ach_withdrawal_count\n    , a.atm_deposit_count\n    , a.atm_withdrawal_count\n    , a.check_withdrawal_count\n    , a.check_deposit_count\n    , a.actual_pwif_paid\n    , a.promo\n    , a.cashback\n    , a.largest_ach_deposit_amount\n    , a.largest_dbt_card_no_pin_amount\n    , a.largest_dbt_card_pin_amount\n    , a.largest_check_deposit_amount\n    , a.largest_check_withdrawal_amount\n    , a.largest_wire_deposit_amount\n    , a.largest_wire_withdrawal_amount\n    , a.largest_atm_deposit_amount\n    , a.largest_atm_withdrawal_amount\n    , a.other_deposit_count\n    , a.other_deposit_amount\n    , a.other_withdrawal_count\n    , a.other_withdrawal_amount\n    , a.planet_protection_subscription_active\n    , a.planet_protection_subscribed_debit_count\n    , a.planet_protection_unsubscribed_debit_count\n    , a.planet_protection_subscribed_debit_amount\n    , a.planet_protection_unsubscribed_debit_amount\n    , a.planet_protection_subscribed_debit_emissions_amount\n    , a.planet_protection_unsubscribed_debit_emissions_amount\n    , c.INACTIVE_DEBIT\n    , c.INACTIVE_DEBIT_DEPOSIT\n    , c.INACTIVE_NONINTEREST_REVENUE\n  FROM bi_new.dt_account_monthly_data_tmp a\n  JOIN bi_new.end_of_month_data b ON a.unique_account_id = b.unique_account_id AND a.month = b.month\n  LEFT JOIN (\n    select\n        daw.UNIQUE_ACCOUNT_ID\n        , daw.date\n        , daw.INACTIVE_DEBIT\n        , daw.INACTIVE_DEBIT_DEPOSIT\n        , daw.INACTIVE_NONINTEREST_REVENUE\n    from rdl.dt_account_90_day_window_data daw\n  ) c ON a.unique_account_id = c.unique_account_id AND a.month = c.date\n  JOIN bi_new.dt_accounts acc ON a.unique_account_id = acc.unique_account_id );\n\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp_2;\n\nCREATE TABLE bi_new.dt_account_monthly_data_tmp_2\nAS (\n  SELECT unique_account_id\n    , a.month\n    , a.monthly_debit_card_pin_amount\n    , a.monthly_debit_card_no_pin_amount\n    , a.monthly_debit_card_pin_transactions\n    , a.monthly_debit_card_no_pin_transactions\n    , a.monthly_aim_scored_transactions\n    , a.lowest_monthly_balance\n    , a.average_balance\n    , a.peak_monthly_balance\n    , a.end_of_month_balance\n    , a.lowest_monthly_balance_actual\n    , a.average_balance_actual\n    , a.peak_monthly_balance_actual\n    , a.end_of_month_balance_actual\n    , a.lowest_monthly_spend_balance_actual\n    , a.average_spend_balance_actual\n    , a.peak_monthly_spend_balance_actual\n    , a.end_of_month_spend_balance_actual\n    , a.lowest_monthly_save_balance_actual\n    , a.average_save_balance_actual\n    , a.peak_monthly_save_balance_actual\n    , a.end_of_month_save_balance_actual\n    , a.ach_withdrawal_amount\n    , a.ach_deposit_amount\n    , a.check_withdrawal_amount\n    , a.check_deposit_amount\n    , a.wire_withdrawal_amount\n    , a.wire_deposit_amount\n    , a.atm_withdrawal_amount\n    , a.atm_deposit_amount\n    , a.atm_fee_refund_amount\n    , a.interest_amount\n    , a.monthly_usd_fee_setting\n    , a.yearly_percent_fee_setting\n    , a.monthly_aim_people_score\n    , a.monthly_aim_planet_score\n    , is_terminated\n    , is_funded\n    , is_charged_off\n    , previous_monthly_ach_deposit_amount\n    , previous_monthly_ach_withdrawal_amount\n    , previous_monthly_debit_card_pin_amount\n    , previous_monthly_debit_card_no_pin_amount\n    , a.wire_withdrawal_count\n    , a.wire_deposit_count\n    , a.internal_transfer_deposit\n    , a.internal_transfer_withdrawal\n    , a.ach_deposit_count\n    , a.ach_withdrawal_count\n    , a.atm_deposit_count\n    , a.atm_withdrawal_count\n    , a.check_withdrawal_count\n    , a.check_deposit_count\n    , a.actual_pwif_paid\n    , a.promo\n    , a.cashback\n    , a.largest_ach_deposit_amount\n    , a.largest_dbt_card_no_pin_amount\n    , a.largest_dbt_card_pin_amount\n    , a.largest_check_deposit_amount\n    , a.largest_check_withdrawal_amount\n    , a.largest_wire_deposit_amount\n    , a.largest_wire_withdrawal_amount\n    , a.largest_atm_deposit_amount\n    , a.largest_atm_withdrawal_amount\n    , a.monthly_bill_pay_amount\n    , a.monthly_bill_pay_count\n    , a.other_deposit_count\n    , a.other_deposit_amount\n    , a.other_withdrawal_count\n    , a.other_withdrawal_amount\n    , a.planet_protection_subscription_active\n    , a.planet_protection_subscribed_debit_count\n    , a.planet_protection_unsubscribed_debit_count\n    , a.planet_protection_subscribed_debit_amount\n    , a.planet_protection_unsubscribed_debit_amount\n    , a.planet_protection_subscribed_debit_emissions_amount\n    , a.planet_protection_unsubscribed_debit_emissions_amount\n    , a.INACTIVE_DEBIT\n    , a.INACTIVE_DEBIT_DEPOSIT\n    , a.INACTIVE_NONINTEREST_REVENUE\n  FROM (\n    SELECT a.*\n      , b.ach_withdrawal_amount AS previous_monthly_ach_withdrawal_amount\n      , b.ach_deposit_amount AS previous_monthly_ach_deposit_amount\n      , b.monthly_debit_card_pin_amount AS previous_monthly_debit_card_pin_amount\n      , b.monthly_debit_card_no_pin_amount AS previous_monthly_debit_card_no_pin_amount\n    FROM bi_new.dt_account_monthly_data_tmp1 a\n    LEFT JOIN bi_new.dt_account_monthly_data_tmp b ON a.unique_account_id = b.unique_account_id AND a.month = DATEADD('month', 1, b.month)\n    ) a\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp;\n\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp_3_1;\nCREATE TABLE bi_new.dt_account_monthly_data_tmp_3_1\nAS (\n  WITH\n  position_counts AS (\n    SELECT date_trunc('quarter', position_date) :: DATE AS quarter\n      , count(*) AS quarter_count\n    FROM (\n      SELECT DATEADD('hour', 10, convert_timezone('America/Los_Angeles',position_date))::date AS position_date\n      FROM web_db.investment_position\n      GROUP BY 1\n      ) possible_position_dates\n    GROUP BY 1\n    ),\n  average_monthly_positions AS (\n    SELECT a.investment_id\n      , user_id\n      , ua.account_id\n      , i.fund_id\n      , a.month\n      , a.ttl / b.quarter_count AS avg_monthly_position\n    FROM (\n      SELECT investment_id\n        , date_trunc('quarter', DATEADD('hour', 10, convert_timezone('America/Los_Angeles',position_date))) :: DATE AS quarter\n        , date_trunc('month', DATEADD('hour', 10, convert_timezone('America/Los_Angeles',position_date))) :: DATE AS month\n        , sum(current_value) AS ttl\n      FROM web_db.investment_position\n      GROUP BY 1, 2, 3\n      ) a\n    JOIN position_counts b ON b.quarter = a.quarter\n    JOIN web_db.investment i ON a.investment_id = i.id\n    JOIN web_db.user_account ua ON i.account_id = ua.account_id\n    ),\n  payment_fractions AS (\n    SELECT a.investment_id\n      , a.user_id\n      , a.account_id\n      , a.fund_id\n      , a.month\n      , a.avg_monthly_position\n      , a.avg_monthly_position/ttl AS payment_fraction\n    FROM average_monthly_positions a\n    JOIN (\n      SELECT user_id\n        , fund_id\n        , date_trunc('quarter', month)::DATE AS quarter\n        , sum(avg_monthly_position) AS ttl\n      FROM average_monthly_positions\n      GROUP BY 1, 2, 3\n      HAVING sum(avg_monthly_position) > 0\n      ) b ON date_trunc('quarter', a.month) = b.quarter AND a.user_id = b.user_id AND a.fund_id = b.fund_id\n    ),\n  actual_investment_payments AS (\n    SELECT user_id\n      , CASE WHEN p.description = 'REDWX Fee Pmt' THEN 2 WHEN p.description = 'ASPFX Fee Pmt' THEN 1 END AS fund_id\n      , date_trunc('month', txn_date - INTERVAL '80 days')::DATE AS quarter\n      , sum(amount) AS amount\n    FROM web_db.payment p\n    JOIN web_db.user_payment_account upa ON p.user_payment_account_id = upa.id\n    WHERE p.description IN ('REDWX Fee Pmt', 'ASPFX Fee Pmt')\n    GROUP BY 1, 2, 3\n    ),\n  disaggregated_investment_payments AS (\n    SELECT b.investment_id\n      , b.month\n      , b.payment_fraction * a.amount AS monthly_payment\n    FROM actual_investment_payments a\n    JOIN payment_fractions b ON a.user_id = b.user_id AND a.fund_id = b.fund_id AND a.quarter = date_trunc('quarter', b.month)\n    ),\n  all_investment_payments AS (\n    SELECT *\n    FROM disaggregated_investment_payments\n    ),\n  depository_payments AS (\n    SELECT d.id AS depository_id\n      , DATE_TRUNC('month', txn_date :: DATE - 12)::DATE AS month\n      , amount\n    FROM web_db.payment p\n    JOIN web_db.user_payment_account upa ON upa.id = p.user_payment_account_id\n    JOIN web_db.user_account ua ON ua.user_id = upa.user_id\n    JOIN web_db.depository d ON ua.account_id = d.account_id\n    WHERE p.description = 'Fee Pmt'\n      AND txn_date::date NOT IN ('2016-12-31', '2017-02-06', '2017-10-05', '2017-10-06')\n      AND d.inception_date IS NOT NULL\n    ),\n  all_depository_payments AS (\n    SELECT dta.unique_account_id\n      , dp.month\n      , dp.amount\n    FROM depository_payments dp\n    JOIN bi_new.dt_accounts dta ON (dta.radius_id = dp.depository_id)\n    UNION ALL\n    SELECT dta.unique_account_id\n      , dp.month\n      , dp.amount\n    FROM depository_payments dp\n    JOIN bi_new.dt_accounts dta ON (dta.galileo_id = dp.depository_id)\n    ),\n  all_payment_data AS (\n    SELECT unique_account_id\n      , month\n      , amount AS fee_paid\n    FROM all_depository_payments\n    UNION ALL\n    SELECT 'i' || investment_id AS unique_account_id\n      , month\n      , monthly_payment AS fee_paid\n    FROM all_investment_payments\n    )\n  SELECT unique_account_id\n    , month\n    , sum(fee_paid) AS fee_paid\n  FROM all_payment_data\n  GROUP BY unique_account_id, month\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp_3;\nCREATE TABLE bi_new.dt_account_monthly_data_tmp_3\nAS (\n  SELECT a.*\n    , coalesce(fee_paid, 0) AS billed_pwif_this_month\n    , a.monthly_usd_fee_setting - b.monthly_usd_fee_setting AS month_over_month_monthly_fee_setting_change\n    , a.yearly_percent_fee_setting - b.yearly_percent_fee_setting AS month_over_month_yearly_fee_setting_change\n    , CASE WHEN acc.account_type = 'Checking' AND a.average_balance >= 2500 THEN -0.01/12 * a.average_balance\n        WHEN account_type = 'Checking' AND a.average_balance < 2500 THEN -0.0025 / 12 * a.average_balance\n        ELSE 0 END AS interest_paid_out\n    , CASE WHEN acc.account_type = 'Checking' THEN a.average_balance * 0.016/12\n        ELSE 0 END AS interest_income\n    , CASE WHEN account_type = 'Checking' THEN 2.5\n        ELSE 0 END AS card_issue_fee\n  FROM bi_new.dt_account_monthly_data_tmp_2 a\n  LEFT JOIN bi_new.dt_account_monthly_data_tmp_2 b ON a.unique_account_id = b.unique_account_id AND a.month = DATEADD('month', 1, b.month)\n  JOIN bi_new.dt_accounts acc ON a.unique_account_id = acc.unique_account_id\n  LEFT JOIN bi_new.dt_account_monthly_data_tmp_3_1 c ON a.unique_account_id = c.unique_account_id AND a.month = c.month\n);\n\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp_2;\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data;\n\nCREATE TABLE bi_new.dt_account_monthly_data\nAS (\n  SELECT a.*\n    , sum(b.billed_pwif_this_month) AS pwif_paid_to_date\n    , sum(b.interest_paid_out)      AS interest_paid_to_date\n    , sum(b.interest_income)        AS interest_income_to_dat\n    , a.unique_account_id || '-' || to_varchar(a.month,'yyyymmdd') AS unique_id\n    --, ROW_NUMBER() OVER(order by a.unique_account_id) AS unique_id\n  FROM bi_new.dt_account_monthly_data_tmp_3 a\n  JOIN bi_new.dt_account_monthly_data_tmp_3 b ON a.unique_account_id = b.unique_account_id AND a.month >= b.month\n  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n           31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,\n           59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, \n           86, 87, 88\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp_3;\n\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp_4;\nDROP TABLE IF EXISTS bi_new.dt_account_monthly_data_tmp_3_1;\ndrop table if exists bi_new.DT_ACCOUNT_MONTHLY_DATA_TMP1;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022973":{"id":3022973,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-688,"y":-496,"width":32,"height":32,"inputConnectorIDs":[3023002],"outputSuccessConnectorIDs":[3023024],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Create schema"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"USE WAREHOUSE ${WH_ETL};\nUSE DATABASE ${DB_ADW};\ndrop schema if exists ${DB_ADW}.${schema_bi_new} cascade;\ncreate schema ${DB_ADW}.${schema_bi_new};\n\n\n\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022974":{"id":3022974,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-592,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023027],"outputSuccessConnectorIDs":[3023029],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_account_period_data"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\nDROP TABLE IF EXISTS bi_new.dt_account_period_data_tmp;\nCREATE TABLE bi_new.dt_account_period_data_tmp\nAS\n(\n      SELECT\n        a.unique_account_id,\n\t\t\t\tfloor((date - inception_date::date) / 30.0) AS thirty_day_periods_since_inception,\n        (floor((date - inception_date::date) / 30.0) * 30)::decimal || '-' || ((floor((date - inception_date::date) / 30.0) + 1) * 30 - 1)::decimal || ' Days' AS day_buckets_since_inception,\n        avg(daily_balance)                    AS average_balance,\n        min(daily_balance)                    AS lowest_balance,\n        max(daily_balance)                    AS peak_balance,\n        avg(original_balance)                 AS average_balance_actual,\n        min(original_balance)                 AS lowest_balance_actual,\n        max(original_balance)                 AS peak_balance_actual,\n        avg(spend_daily_balance)              AS average_spend_balance_actual,\n        min(spend_daily_balance)              AS lowest_spend_balance_actual,\n        max(spend_daily_balance)              AS peak_spend_balance_actual,\n        avg(save_daily_balance)               AS average_save_balance_actual,\n        min(save_daily_balance)               AS lowest_save_balance_actual,\n        max(save_daily_balance)               AS peak_save_balance_actual,\n        sum(dbt_card_no_pin_amount)           AS debit_card_no_pin_amount,\n        sum(dbt_card_pin_amount)              AS debit_card_pin_amount,\n        sum(aim_debit_count)                  AS aim_scored_transactions,\n        sum(aim_debit_amount)                 AS aim_scored_transactions_amount,\n        sum(dbt_card_no_pin_count)            AS debit_card_no_pin_transactions,\n        sum(dbt_card_pin_count)               AS debit_card_pin_transactions,\n        sum(daily_bill_pay_amount)            AS bill_pay_amount,\n        sum(ach_withdrawal_amount)            AS ach_withdrawal_amount,\n        sum(ach_deposit_amount)               AS ach_deposit_amount,\n        sum(atm_deposit_amount)               AS atm_deposit_amount,\n        sum(atm_withdrawal_amount)            AS atm_withdrawal_amount,\n        sum(wire_withdrawal_amount)           AS wire_withdrawal_amount,\n        sum(wire_deposit_amount)              AS wire_deposit_amount,\n        sum(internal_transfer_deposit)        AS internal_transfer_deposit,\n        sum(internal_transfer_withdrawal)     AS internal_transfer_withdrawal,\n        sum(check_withdrawal_amount)          AS check_withdrawal_amount,\n        sum(check_deposit_amount)             AS check_deposit_amount,\n        sum(actual_pwif_paid)                 AS actual_pwif_paid,\n        sum(promo)                            AS promo,\n        sum(cashback)                         AS cashback,\n        sum(a.atm_fee_refund_amount)          AS atm_fee_refund_amount,\n        sum(interest_amount)                  AS interest_amount,\n        sum(wire_withdrawal_count)            AS wire_withdrawal_count,\n        sum(wire_deposit_count)               AS wire_deposit_count,\n        sum(ach_deposit_count)                AS ach_deposit_count,\n        sum(ach_withdrawal_count)             AS ach_withdrawal_count,\n        sum(atm_deposit_count)                AS atm_deposit_count,\n        sum(atm_withdrawal_count)             AS atm_withdrawal_count,\n        sum(check_withdrawal_count)           AS check_withdrawal_count,\n        sum(check_deposit_count)              AS check_deposit_count,\n        max(largest_ach_deposit_amount)       AS largest_ach_deposit_amount,\n        min(largest_ach_withdrawal_amount)    AS largest_ach_withdrawal_amount,\n        min(largest_dbt_card_no_pin_amount)   AS largest_dbt_card_no_pin_amount,\n        min(largest_dbt_card_pin_amount)      AS largest_dbt_card_pin_amount,\n        max(largest_check_deposit_amount)     AS largest_check_deposit_amount,\n        min(largest_check_withdrawal_amount)  AS largest_check_withdrawal_amount,\n        max(largest_wire_deposit_amount)      AS largest_wire_deposit_amount,\n        min(largest_wire_withdrawal_amount)   AS largest_wire_withdrawal_amount,\n        max(largest_atm_deposit_amount)       AS largest_atm_deposit_amount,\n        min(largest_atm_withdrawal_amount)    AS largest_atm_withdrawal_amount,\n        sum(other_deposit_count)              AS other_deposit_count,\n        sum(other_deposit_amount)             AS other_deposit_amount,\n        sum(other_withdrawal_count)           AS other_withdrawal_count,\n        sum(other_withdrawal_amount)          AS other_withdrawal_amount\n      FROM bi_new.dt_account_daily_data a inner JOIN bi_new.dt_accounts b\n          on a.unique_account_id = b.unique_account_id\n      GROUP BY 1, 2, 3\n  );\n\ndrop table if exists bi_new.last_dates;\ncreate table bi_new.last_dates as (\n      SELECT\n        a.unique_account_id,\n        floor((date - inception_date::date) / 30.0) as thirty_day_periods_since_inception,\n        (floor((date - inception_date::date) / 30.0) * 30)::decimal || '-' || ((floor((date - inception_date::date) / 30.0) + 1) * 30 - 1)::decimal || ' Days' as day_buckets_since_inception,\n        max(date)                             AS last_day_of_period\n      FROM bi_new.dt_account_daily_data a inner JOIN bi_new.dt_accounts b\n          on a.unique_account_id = b.unique_account_id\n      GROUP BY 1, 2);\n\ndrop table if exists bi_new.end_of_period_data;\ncreate table bi_new.end_of_period_data AS (\n      SELECT\n        b.unique_account_id,\n        a.thirty_day_periods_since_inception,\n        a.day_buckets_since_inception,\n        b.yearly_percent_fee_setting,\n        b.monthly_usd_fee_setting,\n        daily_balance AS end_of_period_balance,\n        original_balance AS end_of_period_balance_actual,\n        spend_daily_balance AS end_of_period_spend_balance_actual,\n        save_daily_balance AS end_of_period_save_balance_actual,\n        is_terminated,\n        is_funded\n      FROM bi_new.last_dates a INNER JOIN bi_new.dt_account_daily_data b\n          ON a.unique_account_id = b.unique_account_id AND a.last_day_of_period = b.date);\n\ndrop table if exists bi_new.dt_account_period_data;\n\ncreate table bi_new.dt_account_period_data as (\nSELECT\n    a.unique_account_id,\n    a.thirty_day_periods_since_inception,\n    a.day_buckets_since_inception,\n    a.peak_balance,\n    a.average_balance,\n    a.lowest_balance,\n    a.peak_balance_actual,\n    a.average_balance_actual,\n    a.lowest_balance_actual,\n    a.peak_spend_balance_actual,\n    a.average_spend_balance_actual,\n    a.lowest_spend_balance_actual,\n    b.end_of_period_spend_balance_actual,\n    a.peak_save_balance_actual ,\n    a.average_save_balance_actual,\n    a.lowest_save_balance_actual,\n    b.end_of_period_save_balance_actual,\n    a.aim_scored_transactions,\n    a.debit_card_pin_amount,\n    a.debit_card_no_pin_amount,\n    a.debit_card_pin_transactions,\n    a.debit_card_no_pin_transactions,\n    a.bill_pay_amount,\n    b.end_of_period_balance,\n    b.end_of_period_balance_actual,\n    b.yearly_percent_fee_setting,\n    CASE WHEN account_type = 'Checking'\n      THEN b.monthly_usd_fee_setting\n    ELSE b.yearly_percent_fee_setting * average_balance / 12 END AS monthly_usd_fee_setting,\n    b.is_terminated,\n    b.is_funded,\n    a.ach_deposit_amount,\n    a.ach_withdrawal_amount,\n    a.check_deposit_amount,\n    a.actual_pwif_paid,\n    a.promo,\n    a.cashback,\n    a.check_withdrawal_amount,\n    a.wire_deposit_amount,\n    a.wire_withdrawal_amount,\n    a.atm_deposit_amount,\n    a.atm_withdrawal_amount,\n    a.atm_fee_refund_amount,\n    a.interest_amount,\n    a.wire_withdrawal_count,\n    a.wire_deposit_count,\n    a.internal_transfer_deposit,\n    a.internal_transfer_withdrawal,\n    a.ach_deposit_count,\n    a.ach_withdrawal_count,\n    a.atm_deposit_count,\n    a.atm_withdrawal_count,\n    a.check_withdrawal_count,\n    a.check_deposit_count,\n    a.largest_ach_deposit_amount,\n    a.largest_ach_withdrawal_amount,\n    a.largest_dbt_card_no_pin_amount,\n    a.largest_dbt_card_pin_amount,\n    a.largest_check_deposit_amount,\n    a.largest_check_withdrawal_amount,\n    a.largest_wire_deposit_amount,\n    a.largest_wire_withdrawal_amount,\n    a.largest_atm_deposit_amount,\n    a.largest_atm_withdrawal_amount,\n    a.other_deposit_count,\n    a.other_deposit_amount,\n    a.other_withdrawal_count,\n    a.other_withdrawal_amount,\n    ROW_NUMBER() OVER(order by a.unique_account_id) AS unique_id\n  FROM bi_new.dt_account_period_data_tmp a INNER JOIN bi_new.end_of_period_data b\n      ON a.unique_account_id = b.unique_account_id AND\n         a.thirty_day_periods_since_inception = b.thirty_day_periods_since_inception\n    INNER JOIN bi_new.dt_accounts acc\n      ON a.unique_account_id = acc.unique_account_id\n);\n\n/*\nDROP TABLE IF EXISTS bi_new.dt_account_period_data;\n\nCREATE TABLE bi_new.dt_account_period_data\nAS\n(\n  select\n    *,\n\n    ROW_NUMBER() OVER(order by unique_account_id) AS unique_id\n  FROM bi_new.dt_account_period_data_tmp1)\n;\n*/\n\ndrop table if exists bi_new.DT_ACCOUNT_PERIOD_DATA_TMP;\ndrop table if exists bi_new.DT_ACCOUNT_PERIOD_DATA_TMP1;"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3022975":{"id":3022975,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-1773186960,"x":-800,"y":-496,"width":32,"height":32,"inputConnectorIDs":[3023086],"outputSuccessConnectorIDs":[3023002],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"set job_hour variable"}}}},"visible":true},"2":{"slot":2,"name":"Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"###\n# Variables are directly accessible: \n#   print myvar\n# Updating a variable:\n#   context.updateVariable('myvar', 'new-value')\n# Grid Variables are accessible via the context:\n#   print context.getGridVariable('mygridvar')\n# Updating a grid variable:\n#   context.updateGridVariable('mygridvar', [['list','of'],['lists','!']])\n# A database cursor can be accessed from the context (Jython only):\n#   cursor = context.cursor()\n#   cursor.execute('select count(*) from mytable')\n#   rowcount = cursor.fetchone()[0]\n###\n\n# get hour job starts in\n\nimport uuid\nfrom datetime import datetime,timezone\nfrom dateutil import tz\nfrom_zone = tz.gettz('America/Los_Angeles')\ndateTimeObj = datetime.now()\ndateTimeObj = dateTimeObj.replace(tzinfo=timezone.utc).astimezone(tz=from_zone)\ntimestampStr = dateTimeObj.strftime(\"%H\")\ncontext.updateVariable('job_hour', timestampStr)\nprint (timestampStr)\n\n"}}}},"visible":true},"3":{"slot":3,"name":"Interpreter","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Python 3"}}}},"visible":true},"4":{"slot":4,"name":"Timeout","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"INTEGER","value":"360"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023008":{"id":3023008,"inputCardinality":"MANY","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":235671163,"x":-480,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023029,3023030],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023087],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"And 0"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023009":{"id":3023009,"inputCardinality":"MANY","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":235671163,"x":-432,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023007,3023085],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023082],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"And 1"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023010":{"id":3023010,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-1859466705,"x":-352,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023087],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023084],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"WH - xsmall, min 1 cluster"}}}},"visible":true},"2":{"slot":2,"name":"Warehouse","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"[Environment Default]"}}}},"visible":true},"3":{"slot":3,"name":"Command Type","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Set"}}}},"visible":true},"4":{"slot":4,"name":"New name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":""}}}},"visible":false},"5":{"slot":5,"name":"Properties","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"WAREHOUSE_SIZE"},"2":{"slot":2,"type":"STRING","value":"XSMALL"}}},"2":{"slot":2,"values":{"1":{"slot":1,"type":"STRING","value":"MIN_CLUSTER_COUNT"},"2":{"slot":2,"type":"STRING","value":"1"}}},"3":{"slot":3,"values":{"1":{"slot":1,"type":"STRING","value":"AUTO_SUSPEND"},"2":{"slot":2,"type":"STRING","value":"60"}}}},"visible":true},"6":{"slot":6,"name":"Properties","elements":{},"visible":false}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023011":{"id":3023011,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-704,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023045],"outputSuccessConnectorIDs":[3023026],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_account_daily_data_incremental"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"set timezone = 'America/Los_Angeles';\n\n--Business rule for charge offs: look for credits where tran type = charge off\n--or charge off recovery.  Sometimes the latter is used mistakenly as a charge off.\n--So we look for charge off recoveries in positive amounts.\ndrop table if exists etl.tmp_charge_off;\ncreate table etl.tmp_charge_off as\nselect UNIQUE_ACCOUNT_ID,\n       min(TRANSACTION_DATE::date) as charge_off_date\nfrom bi_new.DT_DEPOSITORY_TRANSACTIONS\nwhere transaction_type in ('Charge Off','Charge Off Recovery')\nand AMOUNT > 0\ngroup by 1;\n\nDROP TABLE IF EXISTS bi_new.dt_summit_daily_fee_settings_tmp;\nCREATE TABLE bi_new.dt_summit_daily_fee_settings_tmp\nAS (\n  WITH\n  dates AS (\n    SELECT '2014-10-01'::DATE + i - 1 AS date\n    FROM (\n            select row_number() over(order by seq4()) as i\n            from table (\n                    generator(\n                            rowcount => 3000\n                        )\n                )\n           )\n    WHERE i <= CURRENT_DATE - '2014-10-01'::DATE + 1\n    ),\n  all_dep_dates AS (\n    SELECT a.unique_account_id\n      , COALESCE(a.galileo_id, a.radius_id) AS depository_id\n      , a.termination_date\n      , b.date\n    FROM bi_new.dt_accounts a\n    JOIN dates b ON b.date >= a.inception_date\n    WHERE a.inception_date IS NOT NULL\n    AND a.account_type = 'Checking'\n    ),\n  depository_fee_histories AS (\n    SELECT dta.unique_account_id\n      , dfh_g.fee_date\n      , dfh_g.fee_amount\n      , dfh_g.id\n    FROM web_db.depository_fee_history dfh_g\n    JOIN bi_new.dt_accounts dta ON (dta.galileo_id = dfh_g.depository_id)\n    UNION ALL\n    SELECT dta.unique_account_id\n      , dfh_r.fee_date as fee_date\n      , dfh_r.fee_amount\n      , dfh_r.id\n    FROM web_db.depository_fee_history dfh_r\n    JOIN bi_new.dt_accounts dta ON (dta.radius_id = dfh_r.depository_id)\n    ),\n  fee_history AS (\n    SELECT dfh.unique_account_id\n      , dfh.fee_date\n      , dfh.fee_amount\n    FROM (\n      SELECT dfh.unique_account_id\n        , dfh.fee_date\n        , MAX(dfh.id) AS max_id\n      FROM depository_fee_histories dfh\n      GROUP BY dfh.unique_account_id, dfh.fee_date\n      ) a\n    JOIN depository_fee_histories dfh ON a.max_id = dfh.id\n    ),\n  initial_fees AS (\n    SELECT b.unique_account_id\n      , min_date\n      , b.fee_amount AS initial_fee\n    FROM (\n      SELECT unique_account_id\n        , MIN(fee_date) AS min_date\n      FROM fee_history\n      GROUP BY 1\n      ) a\n    JOIN fee_history b ON (a.unique_account_id = b.unique_account_id AND a.min_date = b.fee_date)\n    )\n  SELECT foo.unique_account_id\n    , foo.date\n    , CASE WHEN foo.termination_date IS NULL OR foo.termination_date > foo.date\n      THEN COALESCE(CASE WHEN foo.date < min_date THEN initial_fee ELSE b.fee_amount END, 0)\n      ELSE 0 END AS fee_amount\n  FROM all_dep_dates foo\n  LEFT JOIN (\n    SELECT a.unique_account_id\n      , a.date\n      , MAX(b.fee_date) AS max_date\n    FROM all_dep_dates a\n    LEFT JOIN fee_history b ON a.unique_account_id = b.unique_account_id AND a.date >= b.fee_date\n    GROUP BY 1, 2\n    ) a ON foo.unique_account_id = a.unique_account_id AND foo.date = a.date\n  LEFT JOIN fee_history b ON a.unique_account_id = b.unique_account_id AND a.max_date = b.fee_date\n  LEFT JOIN initial_fees md ON md.unique_account_id = foo.unique_account_id\n);\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_fee_settings_tmp;\nCREATE TABLE bi_new.dt_investment_daily_fee_settings_tmp\nAS (\n  WITH\n  dates AS (\n    SELECT '2014-10-01'::DATE + i - 1 AS date\n    FROM (\n            select row_number() over(order by seq4()) as i\n            from table (\n                    generator(\n                            rowcount => 3000\n                        )\n                )\n           )\n    WHERE i <= CURRENT_DATE - '2014-10-01'::DATE + 1\n    ),\n  all_inv_dates AS (\n    SELECT id AS investment_id\n      , date\n    FROM web_db.investment a\n    JOIN dates b ON b.date >= a.inception_date\n    WHERE inception_date IS NOT NULL\n    ),\n  fee_history AS (\n    SELECT ifh.investment_id\n      , ifh.fee_date::DATE as fee_date\n      , ifh.fee_pct\n    FROM (\n      SELECT investment_id\n        , fee_date::DATE as investment_fee_date\n\n        , max(id) AS max_id\n      FROM web_db.investment_fee_history\n      GROUP BY 1, 2\n      ) a\n    JOIN web_db.investment_fee_history ifh ON a.max_id = ifh.id AND ifh.investment_id = a.investment_id AND ifh.fee_date :: DATE = a.investment_fee_date :: DATE\n    ),\n  initial_fees AS (\n    SELECT b.investment_id\n      , min_date\n      , b.fee_pct AS initial_fee\n    FROM (\n      SELECT investment_id\n        , MIN(fee_date) AS min_date\n      FROM fee_history\n      GROUP BY 1) a\n    JOIN fee_history b ON a.investment_id = b.investment_id AND a.min_date = b.fee_date\n    )\n  SELECT 'i' || aid.investment_id AS unique_account_id\n    , aid.date\n    , CASE WHEN acc.termination_date IS NULL OR acc.termination_date > aid.date\n      THEN coalesce(CASE WHEN aid.date < min_date THEN initial_fee ELSE b.fee_pct END, 0)\n      ELSE 0 END AS fee_pct\n  FROM all_inv_dates aid\n  LEFT JOIN (\n    SELECT a.investment_id\n      , a.date\n      , max(b.fee_date) AS max_date\n    FROM all_inv_dates a\n    LEFT JOIN fee_history b ON a.investment_id = b.investment_id AND a.date >= b.fee_date\n    GROUP BY 1, 2\n    ) a ON a.investment_id = aid.investment_id AND a.date = aid.date\n  LEFT JOIN fee_history b ON aid.investment_id = b.investment_id AND a.max_date = b.fee_date\n  LEFT JOIN initial_fees md ON md.investment_id = a.investment_id\n  LEFT JOIN web_db.investment i ON i.id = b.investment_id\n  LEFT JOIN web_db.account acc ON acc.id = i.account_id\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_account_daily_fee_settings_tmp;\nCREATE TABLE bi_new.dt_account_daily_fee_settings_tmp\nAS (\n  SELECT a.unique_account_id\n    , a.date\n    , a.fee_amount AS monthly_fee_setting\n    , b.fee_amount AS previous_day_monthly_fee_setting\n    , NULL AS yearly_percent_setting\n    , NULL AS previous_day_yearly_percent_setting\n  FROM bi_new.dt_summit_daily_fee_settings_tmp a\n  LEFT JOIN bi_new.dt_summit_daily_fee_settings_tmp b ON a.unique_account_id = b.unique_account_id AND a.date = b.date + 1\n  UNION ALL\n  SELECT a.unique_account_id\n    , a.date\n    , NULL AS monthly_fee_setting\n    , NULL AS previous_day_monthly_fee_setting\n    , a.fee_pct AS yearly_percent_setting\n    , b.fee_pct AS previous_day_yearly_percent_setting\n  FROM bi_new.dt_investment_daily_fee_settings_tmp a\n  LEFT JOIN bi_new.dt_investment_daily_fee_settings_tmp b ON a.unique_account_id = b.unique_account_id AND a.date = b.date + 1\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_summit_daily_fee_settings_tmp;\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_fee_settings_tmp;\n\n--insert any brand new accounts into etl.daily balances so they will be included in the table\ninsert into etl.DAILY_BALANCES\n(UNIQUE_ACCOUNT_ID, DATE, DAILY_BALANCE, ORIGINAL_BALANCE, SPEND_DAILY_BALANCE, SAVE_DAILY_BALANCE, HAS_SET_RECURRING_DEPOSIT)\nselect a.UNIQUE_ACCOUNT_ID,\n       INCEPTION_DATE::date as date,\n       0 as daily_balance,\n       0 as original_balance,\n       0 as spend_daily_balance,\n       0 as save_daily_balance,\n       false as has_set_recurring_deposit\nfrom bi_new.DT_ACCOUNTS a\nleft join etl.DAILY_BALANCES b on a.UNIQUE_ACCOUNT_ID = b.UNIQUE_ACCOUNT_ID\nwhere b.UNIQUE_ACCOUNT_ID is null\nand a.INCEPTION_DATE is not null\nand a.ACCOUNT_TYPE = 'Checking';\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp;\nCREATE TABLE bi_new.dt_investment_daily_balances_tmp\nAS (\n  WITH\n  dates AS (\n    SELECT '2014-10-01'::DATE + i - 1 AS date\n    FROM (\n            select row_number() over(order by seq4()) as i\n            from table (\n                    generator(\n                            rowcount => 3000\n                        )\n                )\n           )\n    WHERE i <= CURRENT_DATE - '2014-10-01'::DATE + 1\n    ),\n  investment_dates AS (\n    SELECT 'i' || i.id AS unique_account_id\n      , date\n    FROM web_db.investment i\n    JOIN dates ON dates.date >= inception_date\n    WHERE inception_date IS NOT NULL\n    )\n  SELECT ad.unique_account_id\n    , ad.date\n    , COALESCE(ip.current_value, LAG(ip.current_value) IGNORE NULLS OVER (PARTITION BY ad.unique_account_id ORDER BY ad.date)) AS current_value\n  FROM investment_dates ad\n  LEFT JOIN web_db.investment_position ip ON ad.unique_account_id = 'i' || ip.investment_id AND ad.date = DATEADD('hour', 10, convert_timezone('America/Los_Angeles',ip.position_date))::date\n);\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_2;\n\nCREATE TABLE bi_new.dt_investment_daily_balances_tmp_2\nAS (\n  WITH\n  min_posted_investment_dates AS (\n    SELECT unique_account_id\n      , MIN(date) AS min_date\n    FROM bi_new.dt_investment_daily_balances_tmp\n    WHERE current_value > 0\n    GROUP BY 1\n    ),\n  initial_investment_balances AS (\n    SELECT db.unique_account_id\n      , db.current_value AS initial_balance\n      , min_date\n    FROM min_posted_investment_dates a\n    JOIN bi_new.dt_investment_daily_balances_tmp db ON a.unique_account_id = db.unique_account_id AND a.min_date = db.date\n    )\n  SELECT a.unique_account_id\n    , a.date\n    , greatest(0, CASE WHEN date < min_date THEN initial_balance ELSE current_value END) AS daily_balance\n    , current_value AS original_balance\n  FROM bi_new.dt_investment_daily_balances_tmp a\n  LEFT JOIN initial_investment_balances b ON a.unique_account_id = b.unique_account_id\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp;\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_3;\nCREATE TABLE bi_new.dt_investment_daily_balances_tmp_3\nAS (\n  SELECT unique_account_id\n    , date\n    , daily_balance\n    , original_balance\n    , null::dec(18,2) AS spend_daily_balance\n    , null::dec(18,2) AS save_daily_balance\n    , max(flag::int)\n    OVER(PARTITION BY unique_account_id)::BOOLEAN AS has_set_recurring_deposit\n    FROM (\n      SELECT a.*\n        , CASE when b.unique_account_id IS NULL THEN FALSE ELSE TRUE END AS flag\n      FROM bi_new.dt_investment_daily_balances_tmp_2 a\n      LEFT JOIN (\n        SELECT 'i' || investment_id AS unique_account_id\n          , date_created :: date AS sb_setting_dt\n        FROM web_db.recurring_order_txn\n        GROUP BY 1, 2\n        ) b on a.unique_account_id = b.unique_account_id AND a.date = b.sb_setting_dt\n      ) a\n);\n\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_2;\n\nDROP TABLE IF EXISTS bi_new.dt_account_daily_data_new;\nCREATE TABLE bi_new.dt_account_daily_data_new\nAS (\n  WITH\n  billpay AS (\n    SELECT cp.date_created::DATE AS check_creation_date,\n      dta.unique_account_id,\n      SUM(cp.amount) AS daily_bill_pay_amount,\n      COUNT(*) AS daily_bill_pay_count\n    FROM web_db.check_payment cp\n    JOIN bi_new.dt_accounts dta ON (cp.user_id = dta.user_id)\n    WHERE cp.status = 6\n    GROUP BY 1, 2\n    ),\n  planet_protection_subscription as (\n    select pp.unique_account_id,\n           pp.date\n    from etl.DAILY_BALANCES pp\n    where exists(\n          select 1\n          from web_db.subscription s\n          join bi_new.dt_accounts a on s.account_id = a.galileo_account_id\n          join WEB_DB.SUBSCRIPTION_INVOICE si on s.SUBSCRIPTION_ID = si.SUBSCRIPTION_ID\n          where s.plan_group ilike '%planet%protection%'\n            and pp.unique_account_id = a.unique_account_id\n            and pp.date between si.PERIOD_START::date and si.PERIOD_END::date\n            and si.STATUS = 'paid'\n        )\n    ),\n              psh AS (\n   SELECT USER_ID, PAUSED AS is_pyc_paused, all_dates.date AS date\n        FROM (\n                 SELECT '2020-10-01'::DATE + i - 1 AS date -- Generates dates till 2034, needs to be replaced with date dimension in future\n                 FROM (\n                          SELECT ROW_NUMBER() OVER (ORDER BY SEQ4()) AS i\n                          FROM TABLE (\n                              GENERATOR(\n                                      ROWCOUNT => 4000\n                                  )\n                              )\n                      )\n                 WHERE i <= CURRENT_DATE - '2020-10-01'::DATE + 1\n             ) all_dates\n                 JOIN (\n            SELECT user_id,\n                   paused,\n                   last_updated,\n                   COALESCE(LEAD(last_updated, 1) OVER (PARTITION BY USER_ID ORDER BY last_updated), CURRENT_DATE + 1)::date AS last_updated_next\n            FROM (SELECT user_id,\n                         paused,\n                         UPDATED_AT::date                                                                    AS last_updated,\n                         ROW_NUMBER() OVER (PARTITION BY USER_ID, UPDATED_AT::date ORDER BY UPDATED_AT DESC) AS row_num\n                  FROM adw.bank_db.PYC_SETTING_HISTORY)\n            WHERE row_num = 1 ) psh_history ON all_dates.date >= psh_history.last_updated\n            AND all_dates.date < psh_history.last_updated_next\n            ),\n\n  transactions AS (\n    SELECT unique_account_id\n      , post_date\n      , sum(CASE WHEN transaction_type IN ('ACH Withdrawal', 'Coastal ACH Debit', 'Money Transfer') AND amount < 0 THEN amount ELSE 0 END) AS ach_withdrawal_amount\n      , min(CASE WHEN transaction_type IN ('ACH Withdrawal', 'Coastal ACH Debit', 'Money Transfer') AND amount < 0 THEN amount ELSE 0 END) AS largest_ach_withdrawal_amount\n      , sum(CASE WHEN transaction_type IN ('ACH Withdrawal', 'Coastal ACH Debit', 'Money Transfer') AND amount < 0 THEN 1 ELSE 0 END) AS ach_withdrawal_count\n      , sum(CASE WHEN transaction_type IN ('Debit Card - No PIN', 'Purchase', 'Unique Transactions', 'Retail Sale')  THEN amount ELSE 0 END) AS dbt_card_no_pin_amount\n      , min(CASE WHEN transaction_type IN ('Debit Card - No PIN', 'Purchase', 'Unique Transactions', 'Retail Sale') THEN amount ELSE 0 END) AS largest_dbt_card_no_pin_amount\n      , sum(CASE WHEN transaction_type IN ('Debit Card - No PIN', 'Purchase', 'Unique Transactions', 'Retail Sale')  THEN 1 ELSE 0 END) AS dbt_card_no_pin_count\n      , sum(CASE WHEN transaction_type IN ('Interest','Interest Payment', 'Interest Posting', 'Interest Paid') THEN amount ELSE 0 END) AS interest_amount\n      , sum(CASE WHEN transaction_type IN ('Check Withdrawal', 'Bill Pay Check Payment', 'Bill Payment - Check', 'Convenience Check') THEN amount ELSE 0 END) AS check_withdrawal_amount\n      , min(CASE WHEN transaction_type IN ('Check Withdrawal', 'Bill Pay Check Payment', 'Bill Payment - Check', 'Convenience Check') THEN amount ELSE 0 END) AS largest_check_withdrawal_amount\n      , sum(CASE WHEN transaction_type IN ('Check Withdrawal', 'Bill Pay Check Payment', 'Bill Payment - Check', 'Convenience Check') THEN 1 ELSE 0 END) AS check_withdrawal_count\n      , sum(CASE WHEN transaction_type IN('Wire Transfer - Withdrawal', 'API funds transfer') AND amount < 0 THEN amount ELSE 0 END) AS wire_withdrawal_amount\n      , min(CASE WHEN transaction_type IN ('Wire Transfer - Withdrawal', 'API funds transfer') AND amount < 0 THEN amount ELSE 0 END) AS largest_wire_withdrawal_amount\n      , sum(CASE WHEN transaction_type IN ('Wire Transfer - Withdrawal', 'API funds transfer') AND amount < 0 THEN 1 ELSE 0 END) AS wire_withdrawal_count\n      , sum(CASE WHEN transaction_type IN ('Card to Card') THEN amount ELSE 0 END) as internal_transfer_deposit\n      , sum(CASE WHEN transaction_type in ('C2C - Customer Initiated') THEN amount ELSE 0 END) as internal_transfer_withdrawal\n      , sum(CASE WHEN transaction_type IN ('ATM Deposit', 'Money Transfer') AND amount > 0 THEN amount ELSE 0 END) AS atm_deposit_amount\n      , max(CASE WHEN transaction_type IN ('ATM Deposit', 'Money Transfer') AND amount > 0 THEN amount ELSE 0 END) AS largest_atm_deposit_amount\n      , sum(CASE WHEN transaction_type IN ('ATM Deposit', 'Money Transfer') AND amount > 0 THEN 1 ELSE 0 END) AS atm_deposit_count\n      , sum(CASE transaction_type WHEN 'ATM Withdrawal' THEN amount ELSE 0 END) AS atm_withdrawal_amount\n      , min(CASE transaction_type WHEN 'ATM Withdrawal' THEN amount ELSE 0 END) AS largest_atm_withdrawal_amount\n      , sum(CASE transaction_type WHEN 'ATM Withdrawal' THEN 1 ELSE 0 END) AS atm_withdrawal_count\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Pre-auth completion') THEN amount ELSE 0 END) AS dbt_card_pin_amount\n      , min(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Pre-auth completion') THEN amount ELSE 0 END) AS largest_dbt_card_pin_amount\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Pre-auth completion') THEN 1 ELSE 0 END) AS dbt_card_pin_count\n      , sum(CASE WHEN transaction_type IN ('Wire Transfer - Deposit', 'API funds transfer offset') THEN amount ELSE 0 END) AS wire_deposit_amount\n      , max(CASE WHEN transaction_type IN ('Wire Transfer - Deposit', 'API funds transfer offset') THEN amount ELSE 0 END) AS largest_wire_deposit_amount\n      , sum(CASE WHEN transaction_type IN ('Wire Transfer - Deposit', 'API funds transfer offset') THEN 1 ELSE 0 END) AS wire_deposit_count\n      , sum(CASE WHEN transaction_type IN ('ATM Fee Refund', 'Domestic ATM Fee Rebate', 'Int''l ATM Fee Rebate', 'Academy Credit', 'Fee Rebate') THEN amount ELSE 0 END) AS atm_fee_refund_amount\n      , sum(CASE WHEN transaction_type in ('ACH Deposit', 'Coastal ACH Deposit', 'E-Check') THEN amount ELSE 0 END) AS ach_deposit_amount\n      , max(CASE WHEN transaction_type in ('ACH Deposit', 'Coastal ACH Deposit', 'E-Check') THEN amount ELSE 0 END) AS largest_ach_deposit_amount\n      , sum(CASE WHEN transaction_type in ('ACH Deposit', 'Coastal ACH Deposit', 'E-Check') THEN 1 ELSE 0 END) AS ach_deposit_count\n      , sum(CASE WHEN transaction_type IN ('Check Deposit', 'RDC Other Check Deposit', 'Other Check Deposit') THEN amount ELSE 0 END) AS check_deposit_amount\n      , max(CASE WHEN transaction_type IN ('Check Deposit', 'RDC Other Check Deposit', 'Other Check Deposit') THEN amount ELSE 0 END) AS largest_check_deposit_amount\n      , sum(CASE WHEN transaction_type IN ('Check Deposit', 'RDC Other Check Deposit', 'Other Check Deposit') THEN 1 ELSE 0 END) AS check_deposit_count\n      , sum(CASE WHEN transaction_type in ('PWIF Monthly Summit Tip Fee', 'PWIF Payment', 'Aspiration Pay What is Fair') THEN amount ELSE 0 END) AS actual_pwif_paid\n      , sum(CASE WHEN transaction_type in ('Promotional Credit') THEN amount ELSE 0 END) as promo\n      , sum(CASE WHEN transaction_type in ('Cashback Rewards') THEN amount ELSE 0 END) as cashback\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN amount ELSE 0 END) AS aim_debit_amount\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN 1 ELSE 0 END) AS aim_debit_count\n      , avg(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN aim_planet_score ELSE NULL END)::decimal(38,6) AS aim_planet_transaction_average\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -aim_planet_score * amount ELSE NULL END)\n        /nullif(sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -amount ELSE NULL END)::decimal(38,6),0) AS aim_planet_dollar_weighted_average\n      , avg(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN aim_people_score ELSE NULL END) AS aim_people_transaction_average\n      , sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -aim_people_score * amount ELSE NULL END)\n        /nullif(sum(CASE WHEN transaction_type IN ('Debit Card - PIN', 'Purchase with PIN', 'Debit Card - No PIN', 'Purchase') AND is_aim_scored THEN -amount ELSE NULL END)::decimal(38,6),0) AS aim_people_dollar_weighted_average\n      , sum(CASE WHEN transaction_type IN('Reversal-Credit Account', 'Merchant Credit', 'Temp Provisional Credit', 'Cashback Rewards', 'Chargeback', 'Arbitration Chargeback', 'STAR Chargeback', 'Charge Off',\n                                         'Returned ACH Items', 'Debit Chargeback', 'Final Dispute', 'Visa Chargeback', 'Admin Adjustment',\n                                         'RDC Other Check Dep Ret', 'Debit or Credit Adjustment', 'Maestro Load', 'UNKNOWN',\n                                          'Debit Card Return', 'Deposit Verification', 'Balance Transfer', 'Paypal Deposit', 'Radius ACH transfer adj', 'Convenience Check Adjustment',\n                                         'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment', 'Foreign Transaction Fee', 'Domestic Wire Out Fee',\n                                         'International Wire Out Fee', 'Domestic Wire In Fee', 'International Wire In Fee', 'Cancelled acct or failedid refund adjustment', 'Repayment of Overdraft Funds',\n                                         'Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees', 'Closing Transfer to Card', 'MasterCard Load',\n                                         'Refund', 'Wire Transfer - Deposit - Reversal', 'Debit Card Load') AND amount > 0 THEN 1 ELSE 0 END)::decimal(38,6) as other_deposit_count\n      , sum(CASE WHEN transaction_type IN('Reversal-Credit Account',  'Merchant Credit', 'Temp Provisional Credit', 'Cashback Rewards', 'Chargeback', 'Arbitration Chargeback', 'STAR Chargeback', 'Charge Off',\n                                         'Returned ACH Items', 'Debit Chargeback', 'Final Dispute', 'Visa Chargeback', 'Admin Adjustment',\n                                         'RDC Other Check Dep Ret', 'Debit or Credit Adjustment', 'Maestro Load', 'UNKNOWN',\n                                          'Debit Card Return', 'Deposit Verification', 'Balance Transfer', 'Paypal Deposit', 'Radius ACH transfer adj.', 'Convenience Check Adjustment',\n                                         'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment', 'Foreign Transaction Fee', 'Domestic Wire Out Fee',\n                                         'International Wire Out Fee', 'Domestic Wire In Fee', 'International Wire In Fee', 'Cancelled acct or failedid refund adjustment', 'Repayment of Overdraft Funds',\n                                         'Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees', 'Closing Transfer to Card', 'MasterCard Load',\n                                         'Refund', 'Wire Transfer - Deposit - Reversal', 'Debit Card Load') AND amount > 0 THEN amount ELSE 0 END)::decimal(38,6) as other_deposit_amount\n      , sum(CASE WHEN transaction_type IN('Repayment of Overdraft Funds', 'Settlement Reversals', 'Domestic Wire In Fee', 'Domestic Wire Out Fee', 'International Wire In Fee', 'International Wire Out Fee',\n                                          'C2C - Customer Initiated', 'Charge Off Recovery', 'ATM Intl. Fee', 'Express mail fee', 'Foreign Transaction Fee','Over the Counter Cash Access Fee (International)', '2nd Presentment',\n                                         'Returned ACH Items', 'Charge Off Recovery', 'Debit 2nd Presentment', 'Final Dispute',\n                                         'Visa Chargeback', 'Admin Adjustment', 'Visa Second Presentment', 'RDC Other Check Dep Ret', 'ACH Debit Adjustment', 'Temp Provisional Credit',\n                                          'Radius ACH transfer adj.', 'Convenience Check Adjustment', 'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment',\n                                         'Cancelled acct or failedid refund adjustment','Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees',\n                                          'Arbitration Chargeback', 'Reversal-Credit Account', 'Cash Disbursements', 'Wire Transfer - Withdrawal - Reversal', 'Coastal ACH Reversal',\n                                          'Charge Off Recovery', 'Express mail fee', 'Closing Transfer from Savings', 'Force Post Settle-Could not match to an Auth', 'Reversal-Debiting Account',\n                                           'Auth', 'Over the Counter Cash Access Fee (International)') AND amount < 0 THEN 1 ELSE 0 END)::decimal(38,6) as other_withdrawal_count\n      , sum(CASE WHEN transaction_type IN('Repayment of Overdraft Funds', 'Settlement Reversals', 'Domestic Wire In Fee', 'Domestic Wire Out Fee', 'International Wire In Fee', 'International Wire Out Fee',\n                                          'C2C - Customer Initiated', 'Charge Off Recovery', 'ATM Intl. Fee', 'Express mail fee', 'Foreign Transaction Fee','Over the Counter Cash Access Fee (International)', '2nd Presentment',\n                                         'Returned ACH Items', 'Charge Off Recovery', 'Debit 2nd Presentment', 'Final Dispute',\n                                         'Visa Chargeback', 'Admin Adjustment', 'Visa Second Presentment', 'RDC Other Check Dep Ret', 'ACH Debit Adjustment', 'Temp Provisional Credit',\n                                          'Radius ACH transfer adj.', 'Convenience Check Adjustment', 'Wire Transfer - Fee', 'CS Agent Initiated Adjustment', 'Chargeback/Credit Temporary Adjustment',\n                                         'Cancelled acct or failedid refund adjustment','Outgoing Wire Transfer Reversal', 'Outgoing Wire Transfer', 'Transfer for Program Secured DDA', 'Write off Fees',\n                                          'Arbitration Chargeback', 'Reversal-Credit Account', 'Cash Disbursements', 'Wire Transfer - Withdrawal - Reversal', 'Coastal ACH Reversal',\n                                          'Charge Off Recovery', 'Express mail fee', 'Closing Transfer from Savings', 'Force Post Settle-Could not match to an Auth', 'Reversal-Debiting Account',\n                                          'Auth', 'Over the Counter Cash Access Fee (International)') AND amount < 0 THEN amount ELSE 0 END)::decimal(38,6) as other_withdrawal_amount\n      , sum(CASE WHEN DESCRIPTION in ('Monthly Planet Protection Charge', 'Annual Planet Protection Charge', 'Planet Protection Refund',\n                                      'Monthly Aspiration Plus Charge', 'Annual Aspiration Plus Charge', 'Aspiration Plus Refund') THEN amount ELSE 0 END) as aplus_fee_paid\n      , sum(CASE WHEN TRANSACTION_TYPE in ('Web Service Adjustment')\n                  and (DESCRIPTION like 'Planted%Tree%' or DESCRIPTION = 'Plant Your Change Transfer') THEN amount ELSE 0 END) as pyc_revenue_amount\n      , sum(CASE WHEN TRANSACTION_TYPE in ('Purchase', 'Purchase with PIN', 'Debit Card - No PIN',\n                                           'Debit Card - PIN', 'Retail Sale', 'Unique Transactions', 'Pre-auth completion')\n                  THEN INTERCHANGE_FEE_AMOUNT ELSE 0 END) as interchange_fee_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = true THEN 1 ELSE 0 END) AS planet_protection_subscribed_debit_count\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = false THEN 1 ELSE 0 END) AS planet_protection_unsubscribed_debit_count\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = true THEN amount ELSE 0 END) AS planet_protection_subscribed_debit_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = false THEN amount ELSE 0 END) AS planet_protection_unsubscribed_debit_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = true THEN emissions_amount ELSE 0 END) AS planet_protection_subscribed_debit_emissions_amount\n       , sum(CASE WHEN amount < 0 and emissions_amount is not null and is_planet_protection_subscribed = false THEN emissions_amount ELSE 0 END) AS planet_protection_unsubscribed_debit_emissions_amount\n    FROM bi_new.dt_depository_transactions\n    where post_date >= (current_date - 30)\n    GROUP BY 1, 2\n    )\n     , final_txn as (\n  SELECT a.unique_account_id\n    , account_type\n    , a.date\n    , a.daily_balance\n    , a.original_balance\n    , a.spend_daily_balance\n    , a.save_daily_balance\n    , a.has_set_recurring_deposit\n    , CASE WHEN acc.initial_transfer_posted_date IS NULL OR acc.initial_transfer_posted_date > a.date THEN FALSE ELSE TRUE END AS is_funded\n    , CASE WHEN account_type = 'Checking' THEN coalesce(daily_bill_pay_amount, 0) ELSE NULL END AS daily_bill_pay_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(daily_bill_pay_count, 0) ELSE NULL END AS daily_bill_pay_count\n    , CASE WHEN termination_date IS NULL OR termination_date > a.date THEN FALSE ELSE TRUE END AS is_terminated\n    , CASE WHEN tco.charge_off_date IS NULL OR tco.charge_off_date > a.date THEN FALSE ELSE TRUE END AS is_charged_off   \n    , coalesce(monthly_fee_setting, daily_balance * yearly_percent_setting / 12) AS monthly_usd_fee_setting\n    , coalesce(yearly_percent_setting, CASE WHEN daily_balance = 0 THEN 0 ELSE monthly_fee_setting * 12 / (1.0 * daily_balance) END) AS yearly_percent_fee_setting\n    , coalesce(previous_day_monthly_fee_setting, daily_balance * previous_day_yearly_percent_setting / 12) AS previous_day_monthly_usd_fee_setting\n    , coalesce(previous_day_yearly_percent_setting, CASE WHEN daily_balance = 0 THEN 0 ELSE previous_day_monthly_fee_setting * 12 / (1.0 * daily_balance) END) AS previous_day_yearly_percent_fee_setting\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_withdrawal_amount, 0) ELSE NULL END AS ach_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_withdrawal_count, 0) ELSE NULL END AS ach_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_ach_withdrawal_amount, 0) ELSE NULL END AS largest_ach_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_deposit_amount, 0) ELSE NULL END AS ach_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(ach_deposit_count, 0) ELSE NULL END AS ach_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_ach_deposit_amount, 0) ELSE NULL END AS largest_ach_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_no_pin_amount, 0) ELSE NULL END AS dbt_card_no_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_no_pin_count, 0) ELSE NULL END AS dbt_card_no_pin_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_dbt_card_no_pin_amount, 0) ELSE NULL END AS largest_dbt_card_no_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_pin_amount, 0) ELSE NULL END AS dbt_card_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(dbt_card_pin_count, 0) ELSE NULL END AS dbt_card_pin_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_dbt_card_pin_amount, 0) ELSE NULL END AS largest_dbt_card_pin_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(interest_amount, 0) ELSE NULL END AS interest_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_withdrawal_amount, 0) ELSE NULL END AS check_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_withdrawal_count, 0) ELSE NULL END AS check_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_check_withdrawal_amount, 0) ELSE NULL END AS largest_check_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_deposit_amount, 0) ELSE NULL END AS check_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(check_deposit_count, 0) ELSE NULL END AS check_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(actual_pwif_paid, 0) ELSE NULL END AS actual_pwif_paid\n    , CASE WHEN account_type = 'Checking' THEN coalesce(cashback, 0) ELSE NULL END AS cashback\n    , CASE WHEN account_type = 'Checking' THEN coalesce(promo, 0) ELSE NULL END AS promo\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_check_deposit_amount, 0) ELSE NULL END AS largest_check_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_withdrawal_amount, 0) ELSE NULL END AS wire_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_withdrawal_count, 0) ELSE NULL END AS wire_withdrawal_count\n    , CASE when account_type = 'Checking' THEN coalesce(internal_transfer_deposit, 0) ELSE NULL END AS internal_transfer_deposit\n    , CASE when account_type = 'Checking' THEN coalesce(internal_transfer_withdrawal, 0) ELSE NULL END AS internal_transfer_withdrawal\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_wire_withdrawal_amount, 0) ELSE NULL END AS largest_wire_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_deposit_amount, 0) ELSE NULL END AS wire_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(wire_deposit_count, 0) ELSE NULL END AS wire_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_wire_deposit_amount, 0) ELSE NULL END AS largest_wire_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_deposit_amount, 0) ELSE NULL END AS atm_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_deposit_count, 0) ELSE NULL END AS atm_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_atm_deposit_amount, 0) ELSE NULL END AS largest_atm_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_withdrawal_amount, 0) ELSE NULL END AS atm_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_withdrawal_count, 0) ELSE NULL END AS atm_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(largest_atm_withdrawal_amount, 0) ELSE NULL END AS largest_atm_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(atm_fee_refund_amount, 0) ELSE NULL END AS atm_fee_refund_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_debit_amount, 0) ELSE NULL END AS aim_debit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_debit_count, 0) ELSE NULL END AS aim_debit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_people_transaction_average, 0) ELSE NULL END AS aim_people_transaction_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_people_dollar_weighted_average, 0) ELSE NULL END AS aim_people_dollar_weighted_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(0.5 * aim_people_transaction_average + 0.5 * aim_people_dollar_weighted_average, 0) ELSE NULL END AS daily_aim_people_score\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_planet_transaction_average, 0) ELSE NULL END AS aim_planet_transaction_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aim_planet_transaction_average, 0) ELSE NULL END AS aim_planet_dollar_weighted_average\n    , CASE WHEN account_type = 'Checking' THEN coalesce(0 / 5 * aim_planet_transaction_average + 0.5 * aim_planet_dollar_weighted_average, 0) ELSE NULL END AS daily_aim_planet_score\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_deposit_count, 0) ELSE NULL END AS other_deposit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_deposit_amount, 0) ELSE NULL END AS other_deposit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_withdrawal_count, 0) ELSE NULL END AS other_withdrawal_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(other_withdrawal_amount, 0) ELSE NULL END AS other_withdrawal_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(aplus_fee_paid, 0) ELSE NULL END AS aplus_fee_paid\n    , CASE WHEN account_type = 'Checking' THEN coalesce(pyc_revenue_amount, 0) ELSE NULL END AS pyc_revenue_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(interchange_fee_amount, 0) ELSE NULL END AS interchange_fee_amount\n    , CASE WHEN account_type = 'Checking' AND pps.unique_account_id IS NOT NULL THEN TRUE ELSE FALSE END AS planet_protection_subscription_active\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_subscribed_debit_count, 0) ELSE NULL END AS planet_protection_subscribed_debit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_unsubscribed_debit_count, 0) ELSE NULL END AS planet_protection_unsubscribed_debit_count\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_subscribed_debit_amount, 0) ELSE NULL END AS planet_protection_subscribed_debit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_unsubscribed_debit_amount, 0) ELSE NULL END AS planet_protection_unsubscribed_debit_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_subscribed_debit_emissions_amount, 0) ELSE NULL END AS planet_protection_subscribed_debit_emissions_amount\n    , CASE WHEN account_type = 'Checking' THEN coalesce(planet_protection_unsubscribed_debit_emissions_amount, 0) ELSE NULL END AS planet_protection_unsubscribed_debit_emissions_amount\n    , csh.SEGMENTS as RFM_SCORE\n    , CASE WHEN account_type = 'Checking' THEN psh.is_pyc_paused ELSE NULL END AS is_pyc_paused\n  FROM (\n    SELECT *\n    FROM etl.DAILY_BALANCES\n    WHERE DATE >= (current_date - 30)\n    UNION ALL\n    SELECT *\n    FROM bi_new.dt_investment_daily_balances_tmp_3\n    WHERE DATE >= (current_date - 30)\n    ) a\n  JOIN bi_new.dt_accounts acc ON a.unique_account_id = acc.unique_account_id\n  LEFT JOIN billpay pay ON a.unique_account_id = pay.unique_account_id AND a.date = pay.check_creation_date\n  LEFT JOIN bi_new.dt_account_daily_fee_settings_tmp dfs ON a.unique_account_id = dfs.unique_account_id AND a.date = dfs.date\n  LEFT JOIN transactions b ON a.unique_account_id = b.unique_account_id AND a.date = b.post_date\n  LEFT JOIN planet_protection_subscription pps ON a.unique_account_id = pps.unique_account_id AND a.date = pps.date\n  LEFT JOIN etl.tmp_charge_off tco on acc.UNIQUE_ACCOUNT_ID = tco.UNIQUE_ACCOUNT_ID     \n  LEFT JOIN rdl.cma_segments_history csh on a.unique_account_id = csh.unique_account_id AND a.date = csh.file_date\n  LEFT JOIN psh ON acc.USER_ID = psh.USER_ID AND a.date = psh.date\n\n)\n  SELECT a.*\n    , a.monthly_usd_fee_setting - a.previous_day_monthly_usd_fee_setting AS day_over_day_monthly_fee_setting_change\n    , a.yearly_percent_fee_setting - a.previous_day_yearly_percent_fee_setting AS day_over_day_yearly_fee_setting_change\n    , a.unique_account_id || '-' || to_varchar(a.date,'yyyymmdd') AS unique_id\n  FROM final_txn a\n  order by a.unique_account_id, a.date\n);\n\n\n\n\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_2;\nDROP TABLE IF EXISTS bi_new.dt_investment_daily_balances_tmp_3;\nDROP TABLE IF EXISTS bi_new.dt_account_daily_fee_settings_tmp;\nDROP TABLE IF EXISTS bi_new.dt_summit_daily_balances_tmp_2;\nDROP TABLE IF EXISTS etl.tmp_charge_off;\n\n--append new data to daily table\ndrop table if exists bi_new.dt_account_daily_data;\ncreate table bi_new.dt_account_daily_data clone bi.dt_account_daily_data;\n\ndelete from bi_new.dt_account_daily_data\nwhere date >= (select min(date) from bi_new.dt_account_daily_data_new);\n\ninsert into bi_new.dt_account_daily_data\nselect *\nfrom bi_new.dt_account_daily_data_new;\n\ndrop table if exists bi_new.dt_account_daily_data_new;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023012":{"id":3023012,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-336,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023082],"outputSuccessConnectorIDs":[3023034],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_user_daily_data"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n--audit trail data for logins\ndrop table if exists tmp_audit_trail;\ncreate temp table tmp_audit_trail\n--cluster by (user_id) \nas\nselect user_id,\n       date_created::date as date_created,\n       client_id,\n       ip_address,\n       mobile_platform\nfrom web_db.user_audit_trail\nwhere audit_trail ilike 'Logged In';\n\nDROP TABLE IF EXISTS bi_new.dt_user_daily_data;\nCREATE TABLE bi_new.dt_user_daily_data\n--cluster by (user_id)\nAS\n(\n  with ios_logins AS (\n      SELECT\n        date_created :: date as date,\n        user_id,\n        count(*) as count\n      FROM tmp_audit_trail\n      WHERE ((client_id = '3827973437184' and ip_address not like '206.108.41.10%')\n               OR mobile_platform = 'ios')\n      GROUP BY 1, 2\n  ),\n      android_logins AS (\n        SELECT\n          date_created :: date as date,\n          user_id,\n          count(*) as count\n        FROM tmp_audit_trail\n        WHERE ((client_id = '171738288438772' and ip_address not like '206.108.41.10%')\n                 OR mobile_platform in ('android','Android'))\n        GROUP BY 1, 2\n    ),\n      web_logins AS (\n        SELECT\n          date_created :: date as date,\n          user_id,\n          count(*) as count\n        FROM tmp_audit_trail\n        WHERE (((client_id NOT IN ('171738288438772', '3827973437184') OR client_id IS NULL)\n                   and ip_address not like '206.108.41.10%')\n                 and (mobile_platform not in ('ios','android','Android') or mobile_platform is null))\n        GROUP BY 1, 2\n    ),\n      ace_tickets_10_min AS (\n        SELECT\n          user_id,\n          most_recent_prior_login::date as date,\n          count(*) as ticket_count\n        FROM bi_new.dt_ace_tickets\n        WHERE datediff(min,most_recent_prior_login::timestamp,created_at::timestamp) <= 10\n        GROUP BY 1, 2\n    ),\n\n\tfunded_refer as (\n\t\tselect u.inviting_user_id,\n\t\t\t\tu.date_created::date as inviting_date,\n\t\t\t\tu.invited_user_id\n\t\tFROM web_db.user_signup u\n               left join bi_new.dt_accounts a on u.invited_user_id = a.user_id\n\t\t\t   \t\t\t\t\t\t\t\t and a.account_type = 'Checking'\n\t\twhere a.initial_transfer_posted_date is not null\n\t)\n\n\tSELECT b.user_id,\n\t\ta.date,\n\n\t\tcase\n\t\t\twhen wl.user_id is null then false\n\t\t\telse true\n\t\tend as has_web_login,\n\n\t\tcase\n\t\t\twhen il.user_id is null then false\n\t\t\telse true\n\t\tend as has_ios_login,\n\n\t\tcase\n\t\t\twhen al.user_id is null then false\n\t\t\telse true\n\t\tend as has_android_login,\n\n\t        nvl(wl.count,0) as count_web_login,\n\t        nvl(il.count,0) as count_ios_login,\n\t        nvl(al.count,0) as count_android_login,\n\t        nvl(ace.ticket_count,0) as count_ace_ticket_10_min,\n\n    nsc.nps_rating as nps_score,\n\n\t\tsum(daily_balance)           AS daily_total_assets,\n\n\t\tsum(case\n\t\t\t\twhen b.account_type = 'Checking' then daily_balance\n\t\t\t\telse null\n\t\t\tend) as daily_summit_assets,\n\n\t\tsum(case\n\t\t\t\twhen b.account_type <> 'Checking' then daily_balance\n\t\t\t\telse null\n\t\t\tend) as daily_investment_assets,\n\n     \t\tsum(original_balance)           AS daily_total_assets_actual,\n\n     \t\tsum(case\n     \t\t\t\twhen b.account_type = 'Checking' then original_balance\n     \t\t\t\telse null\n     \t\t\tend) as daily_summit_assets_actual,\n\n     \t\tsum(case\n     \t\t\t\twhen b.account_type = 'Checking' then a.spend_daily_balance\n     \t\t\t\telse null\n     \t\t\tend) as daily_summit_spend_assets_actual,\n\n     \t\tsum(case\n     \t\t\t\twhen b.account_type = 'Checking' then a.save_daily_balance\n     \t\t\t\telse null\n     \t\t\tend) as daily_summit_save_assets_actual,\n\n     \t\tsum(case\n     \t\t\t\twhen b.account_type <> 'Checking' then original_balance\n     \t\t\t\telse null\n     \t\t\tend) as daily_investment_assets_actual,\n\n\n\t\tsum(monthly_usd_fee_setting) AS monthly_usd_fee_setting,\n\n\t\tCASE\n\t\t\tWHEN sum(daily_balance) > 0 THEN sum(monthly_usd_fee_setting) * 12 / sum(daily_balance)\n\t\t\tELSE 0\n\t\tEND AS yearly_percent_fee_setting,\n\n\t\tcount(*)                     AS opened_accounts,\n\n\t\tsum(case\n\t\t\twhen fr.invited_user_id is not null then 1\n\t\t\telse 0 end ) \t\t\tAS num_funded_daily_referrals\n\n\tFROM bi_new.dt_account_daily_data a\n\tINNER JOIN bi_new.dt_accounts b ON a.unique_account_id = b.unique_account_id\n\tleft JOIN web_logins wl on b.user_id = wl.user_id and a.date = wl.date\n\tleft JOIN ios_logins il on b.user_id = il.user_id and a.date = il.date\n\tleft JOIN android_logins al on b.user_id = al.user_id and a.date = al.date\n\tleft JOIN ace_tickets_10_min ace on b.user_id = ace.user_id and a.date = ace.date\n\tleft join funded_refer fr on b.user_id = fr.inviting_user_id\n\t\t\t\t\t\t\t\tand a.date = fr.inviting_date\n\t\t\t\t\t\t\t\tand b.account_type = 'Checking'\n  left join (\n    SELECT\n      da.user_id,\n      nsc.pull_date,\n      nps_rating\n    FROM dataops_ace_db.nps_survey_candidate nsc\n    JOIN bi_new.dt_accounts da ON nsc.unique_account_id=da.unique_account_id\n    WHERE 1=1\n      AND nsc.zendesk_nps_survey_id is not null\n      AND nps_rating is not null\n    ) nsc ON b.user_id=nsc.user_id AND nsc.pull_date=a.date\n\tGROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n)\n;\n\n\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023013":{"id":3023013,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-208,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023084],"outputSuccessConnectorIDs":[3023047],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Replace the schema"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"drop schema if exists bi_old cascade;\nalter schema bi rename to bi_old;\nalter schema bi_new rename to bi;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023014":{"id":3023014,"inputCardinality":"MANY","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":-1343684451,"x":-960,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023026,3023028],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023041,3023085],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Or"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023015":{"id":3023015,"inputCardinality":"MANY","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":235671163,"x":-688,"y":-64,"width":32,"height":32,"inputConnectorIDs":[3023001,3023049],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023042],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"And"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023016":{"id":3023016,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-560,"y":16,"width":32,"height":32,"inputConnectorIDs":[3023039],"outputSuccessConnectorIDs":[3023038],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_credit_users"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\nUSE WAREHOUSE ETL;\n--create the credit version of dt_users\ndrop table if exists bi_new.dt_credit_users;\ncreate table bi_new.dt_credit_users as\nwith wait_list as (\n    select\n        lower(wl.email) as email,\n        wl.PRODUCT_ID,\n        wl.date_created,\n        wl.utm_content,\n        wl.utm_campaign,\n        wl.utm_medium,\n        wl.utm_source,\n        wl.utm_term,\n        wl.initial_url,\n        wl.referral_url,\n        lower(nullif(trim(split_part(CASE WHEN right(wl.referral_domain,1) = '.'\n                                          THEN left(wl.referral_domain,length(wl.referral_domain) - 1)\n                                          ELSE wl.referral_domain\n                                     END,':',1)),'')) AS referral_domain_clean,\n        true as credit_lead_submit\n    from web_db.wait_list_user wl\n    where PRODUCT_ID = 8\n    union\n    select\n        lower(pwl.email) as email,\n        pwl.PRODUCT_ID,\n        pwl.date_created,\n        pwl.utm_content,\n        pwl.utm_campaign,\n        pwl.utm_medium,\n        pwl.utm_source,\n        pwl.utm_term,\n        pwl.initial_url,\n        pwl.referral_url,\n        lower(nullif(trim(split_part(CASE WHEN right(pwl.referral_domain,1) = '.'\n                                          THEN left(pwl.referral_domain,length(pwl.referral_domain) - 1)\n                                          ELSE pwl.referral_domain\n                                     END,':',1)),'')) AS referral_domain_clean,\n       true as credit_lead_submit\n    from web_db.PRODUCT_WAITLIST pwl\n    where PRODUCT_ID = 8\n)\n, wait_list_ranked as (\n    select  ifnull(e.PRIMARY_EMAIL, wl.email) as user_email,\n            wl.email,\n            wl.PRODUCT_ID,\n            wl.date_created,\n            wl.utm_content,\n            wl.utm_campaign,\n            wl.utm_medium,\n            wl.utm_source,\n            wl.utm_term,\n            nvl(nullif(trim(wl.initial_url),''),su.url) as initial_url,\n            wl.referral_url,\n            CASE WHEN wl.referral_domain_clean IS NULL THEN 'direct'\n                        --when all numbers or there = no period, keep as is\n                 WHEN try_to_numeric(regexp_replace(wl.referral_domain_clean,'[.]','')) is not null OR\n                      charindex('.',wl.referral_domain_clean) = 0 THEN wl.referral_domain_clean\n                 ELSE\n                    --handle two-part (.com.uk) versus one-part (.com) top level domain\n                    CASE WHEN left(reverse(left(reverse(wl.referral_domain_clean),6)),4) IN\n                              ('.co.','com.') AND wl.referral_domain_clean ILIKE '%.co%'\n                         THEN reverse(split_part(reverse(wl.referral_domain_clean),'.',3))\n                         ELSE reverse(split_part(reverse(wl.referral_domain_clean),'.',2))\n                    END\n                 END AS referral_domain_clean,\n            row_number() over (partition by USER_EMAIL order by wl.DATE_CREATED) as rn,\n            --Data-1258 Change - Workaround to handle the duplicate Users with more than 1 email/user ids\n             row_number() over (partition by wl.email order by wl.DATE_CREATED) as rn2\n            ,wl.credit_lead_submit\n    from wait_list wl\n    left join etl.DT_USERS_EMAIL e on wl.email = e.EMAIL\n    left join etl.segment_url su on wl.email = su.email\n                                and wl.date_created::date = su.received_at::date\n                                and ifnull(nullif(trim(wl.utm_campaign),''),'99999') = ifnull(su.context_campaign_name,'99999')\n                                and ifnull(nullif(trim(wl.utm_source),''),'99999') = ifnull(su.context_campaign_source,'99999')\n)\n, alloy_eval as (\n    select b.user_id,\n           a.USER_PRODUCT_APPLICATION_ID,\n           a.WORKFLOW,\n           a.CREATED_AT,\n           a.OUTCOME,\n           a.BIRTH_DATE,\n           a.INCOME,\n           a.APPLICATION_VERSION_ID,\n           --want most recent application, and credit_underwriting as the preferred data if available\n          row_number() over (partition by b.USER_ID order by a.USER_PRODUCT_APPLICATION_ID desc,\n                                                  a.WORKFLOW asc,\n                                                  a.CREATED_AT desc) as rn\n    from rdl.CREDIT_ALLOY_EVALUATIONS_FLATTENED a\n    join WEB_DB.USER_PRODUCT_APPLICATION b on a.USER_PRODUCT_APPLICATION_ID = b.id\n)\n, manual_review as (\n    select b.user_id,\n           a.USER_PRODUCT_APPLICATION_ID,\n           a.WORKFLOW,\n           a.CREATED_AT,\n           a.OUTCOME,\n           --want most recent review, and credit_underwriting as the preferred data if available\n          row_number() over (partition by b.USER_ID order by a.USER_PRODUCT_APPLICATION_ID desc,\n                                                  a.WORKFLOW asc,\n                                                  a.CREATED_AT desc) as rn\n    from AA_DB.CREDIT_ALLOY_REVIEW a\n    join WEB_DB.USER_PRODUCT_APPLICATION b on a.USER_PRODUCT_APPLICATION_ID = b.id\n)\n, alloy_plus_manual_review as (\n    select ae.USER_ID,\n           ae.CREATED_AT as CIP_status_date,\n           ae.OUTCOME || CASE WHEN ae.OUTCOME ilike 'Manual%Review'\n                              THEN cast(' - ' || coalesce(mr.outcome,'pending') AS VARCHAR(50))\n                              ELSE ''\n                         END AS CIP_status,\n           mr.CREATED_AT as CIP_manual_review_date,\n           case when ae.WORKFLOW = 'credit_underwriting' then ae.APPLICATION_VERSION_ID else null end as ALLOY_APPLICATION_VERSION,\n           ae.BIRTH_DATE,\n           ae.INCOME\n    from alloy_eval ae\n    left join manual_review mr on ae.USER_PRODUCT_APPLICATION_ID = mr.USER_PRODUCT_APPLICATION_ID and mr.rn = 1\n    where ae.rn = 1\n)\nselect\n      u.USER_EMAIL\n    , u.HAS_VALIDATED_EMAIL\n    , u.USER_ID\n    , u.HAS_ENTERED_CREDENTIALS\n    , u.ENTERED_CREDENTIALS_DATE\n    , u.EXTERNAL_USER_ID\n    , u.LEAD_SOURCE as CMA_LEAD_SOURCE\n    , u.LEAD_ARRIVAL_DATE as CMA_LEAD_ARRIVAL_DATE\n    , wl.DATE_CREATED as LEAD_ARRIVAL_DATE\n    , wl.UTM_SOURCE\n    , case when up.SHOW_IN_DASHBOARD = true then 'Partner' else null end as utm_category\n    , wl.UTM_CONTENT\n    , wl.referral_domain_clean as referral_domain\n    , wl.REFERRAL_URL\n    , u.INITIAL_PRODUCT_SELECTED\n    , u.IS_SIGNED_UP\n    , wl.UTM_CAMPAIGN\n    , regexp_substr(wl.initial_url,'click_?id=([^&]*)',1,1,'e') AS utm_click_id\n    , regexp_substr(wl.initial_url,'sub_?id1?=([^&]*)',1,1,'e') AS utm_click_sub_id\n    , regexp_substr(wl.initial_url,'sub_?id2=([^&]*)',1,1,'e') AS utm_click_sub_id2\n    , regexp_substr(wl.initial_url,'sub_?id3=([^&]*)',1,1,'e') AS utm_click_sub_id3\n    , wl.initial_url AS utm_initial_url\n    , regexp_replace(wl.initial_url,'(.*&gclid=([^&]*))?(.*)','$2') AS gcl_id\n    , wl.UTM_MEDIUM\n    , wl.UTM_TERM\n    , u.USER_DISABLED\n    , utm.UTM_LANDER\n    , nvl(cmp1.value, split_part(wl.utm_campaign,'-',1)) AS utm_campaign_product\n    , nvl(cmp2.value, ltrim(regexp_substr(wl.utm_campaign,'-.*',1),'-')) AS utm_campaign_marketing_campaign\n    , nvl(cnt1.value, split_part(wl.utm_content,'-',1)) AS utm_content_creative_type\n    , nvl(cnt2.value, split_part(wl.utm_content,'-',2)) AS utm_content_creative_description\n    , nvl(cnt3.value, split_part(wl.utm_content,'-',3)) AS utm_content_cta\n    , nvl(cnt4.value, split_part(wl.utm_content,'-',4)) AS utm_content_placement\n    , nvl(cnt5.value, split_part(wl.utm_content,'-',5)) AS utm_content_variable\n    , decode(regexp_replace(wl.utm_content,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$|(((-)[^-]+){4})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9$12$12$12$12$12')\n       , '-----', split_part(split_part(wl.utm_content,'-',6),' ',2)\n       ) AS utm_content_ad_id\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', trm1.value\n       , '------', trm1.value\n       ) AS utm_term_audience_type\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', trm2.value\n       , '------', null\n       ) AS utm_term_seed_audience\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', trm3.value\n       , '------', null\n       ) AS utm_term_lal_percentage\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', trm4.value\n       , '------', null\n       ) AS utm_term_messaging\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', null\n       , '------', split_part(wl.utm_term,'-',2)\n       ) AS utm_term_ad_id\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', null\n       , '------', split_part(wl.utm_term,'-',3)\n       ) AS utm_term_ad_platform\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', null\n       , '------', split_part(wl.utm_term,'-',4)\n       ) AS utm_term_ad_placement\n    , decode(regexp_replace(wl.utm_term,'(^([^-]-[^-]+)((((-)[^-]+){3})$|(((-)[^-]+){5})$))|(^.*$)','$6$6$6$6$9$9$9$9$9$9')\n       , '----', split_part(wl.utm_term,'-',5)\n       , '------', split_part(wl.utm_term,'-',5) || rtrim(concat(' ',split_part(wl.utm_term,'-',6))) || rtrim(concat(' ',split_part(wl.utm_term,'-',7)))\n       ) AS utm_term_start_date\n    , u.HAS_CREDIT_PRODUCT_APPLICATION as HAS_STARTED_APPLICATION\n    , u.HAS_OPENED_ASPIRATION_ACCOUNT AS HAS_OPENED_NON_CREDIT_ACCOUNT\n    --,HAS_ATTEMPTED_TO_LINK_BANK -- version 2\n    --,HAS_VERIFIED_BANK -- version 2\n    --,HAS_ACCEPTED_TERMS_AND_CONDITIONS -- version 2\n    , u.ZIP_CODE\n    , u.STATE\n    , u.CITY\n    , u.STREET_LINE_2\n    , u.STREET_LINE_1\n    , u.PHONE_NUMBER\n    , u.is_phone_validated\n    , u.FIRST_NAME\n    , u.LAST_NAME\n    , u.MIDDLE_NAME\n    , apmr.INCOME\n    --,MARITAL_STATUS -- not available\n    --,GENDER -- not available\n    , apmr.BIRTH_DATE as DATE_OF_BIRTH\n    , datediff('months', apmr.BIRTH_DATE, CURRENT_DATE) / 12 as CUSTOMER_AGE\n    --,EMPLOYMENT -- not available\n    --,HAS_RISK_COHORTS - version 2 ??\n    --, u.INVITING_USER_ID\n    , apmr.CIP_STATUS\n    , apmr.CIP_STATUS_DATE\n    , apmr.CIP_MANUAL_REVIEW_DATE\n    --,ALLOY_CUSTOM_MODEL_SCORE -- not applicable for credit\n    --,ALLOY_CUSTOM_MODEL_VERSION -- not applicable for credit\n    , apmr.ALLOY_APPLICATION_VERSION\n--     ,UTM_SOURCE_CLEAN\n--     ,UTM_CHANNEL_TYPE\n--     ,UTM_CHANNEL_GROUPING\n    , u.MOST_CURRENT_NPS_SCORE\n    , u.MOST_CURRENT_NPS_SURVEY_DATE\n    --,IS_FRAUD_OR_CHARGEOFF -- ??\n    --,FRAUD_OR_CHARGEOFF_TYPE -- ??\n    --,TOTAL_AMOUNT_CHARGED_OFF -- ??\n    --,HARD_LOSS_CHARGE_OFF -- ??\n    --,FEES_CHARGED_OFF -- ??\n    --,NUMBER_INVITES_SENT -- ?? current version relies on dt_accounts\n    --NUM_FUNDED_REFERRALS -- version 2 - new credit version\n    --EXTERNAL_BANK_ACCOUNT_CONNECTED_DATE --version 2 - new credit version\n    , u.HAS_CREDIT_LEAD\n    --Data-1258 Change - Workaround to handle the duplicate Users with more than 1 email/user ids\n    , case when wl.credit_lead_submit = true or wl2.credit_lead_submit = true then true else false end as CREDIT_LEAD_SUBMIT\nfrom etl.dt_users u\n\nleft join wait_list_ranked wl on lower(u.USER_EMAIL) = wl.user_email and wl.rn = 1\n\n--Data-1258 Change - Workaround to handle the duplicate Users with more than 1 email/user ids\nleft join wait_list_ranked wl2 on lower(u.USER_EMAIL) = wl2.email and wl2.rn2 = 1\n\nLEFT JOIN web_db.dt_utm_fields_master utm ON utm.utm_generated_url_final = wl.initial_url\n\nLEFT JOIN rdl.utm_lookup cmp1 ON cmp1.utm = 'Campaign' AND cmp1.part = '1' AND lower(cmp1.code) = lower(split_part(wl.utm_campaign,'-',1))\nLEFT JOIN rdl.utm_lookup cmp2 ON cmp2.utm = 'Campaign' AND cmp2.part = '2' AND lower(cmp2.code) = lower(split_part(wl.utm_campaign,'-',2))\nLEFT JOIN rdl.utm_lookup cnt1 ON cnt1.utm = 'Content'  AND cnt1.part = '1' AND lower(cnt1.code) = lower(split_part(wl.utm_content,'-',1))\nLEFT JOIN rdl.utm_lookup cnt2 ON cnt2.utm = 'Content'  AND cnt2.part = '2' AND lower(cnt2.code) = lower(split_part(wl.utm_content,'-',2))\nLEFT JOIN rdl.utm_lookup cnt3 ON cnt3.utm = 'Content'  AND cnt3.part = '3' AND lower(cnt3.code) = lower(split_part(wl.utm_content,'-',3))\nLEFT JOIN rdl.utm_lookup cnt4 ON cnt4.utm = 'Content'  AND cnt4.part = '4' AND lower(cnt4.code) = lower(split_part(wl.utm_content,'-',4))\nLEFT JOIN rdl.utm_lookup cnt5 ON cnt5.utm = 'Content'  AND cnt5.part = '5' AND lower(cnt5.code) = lower(split_part(wl.utm_content,'-',5))\nLEFT JOIN rdl.utm_lookup trm1 ON trm1.utm = 'Term'     AND trm1.part = '1' AND lower(trm1.code) = lower(split_part(wl.utm_term,'-',1))\nLEFT JOIN rdl.utm_lookup trm2 ON trm2.utm = 'Term'     AND trm2.part = '2' AND lower(trm2.code) = lower(split_part(wl.utm_term,'-',2))\nLEFT JOIN rdl.utm_lookup trm3 ON trm3.utm = 'Term'     AND trm3.part = '3' AND lower(trm3.code) = lower(split_part(wl.utm_term,'-',3))\nLEFT JOIN rdl.utm_lookup trm4 ON trm4.utm = 'Term'     AND trm4.part = '4' AND lower(trm4.code) = lower(split_part(wl.utm_term,'-',4))\nLEFT JOIN rdl.utm_partnership up ON wl.utm_source = up.utm_source\n\nLEFT JOIN alloy_plus_manual_review apmr ON u.USER_ID = apmr.USER_ID\n\n--only take credit-related leads or those with a credit product\nwhere u.has_credit_lead = true\nor u.initial_product_selected = 'Credit'\nor u.HAS_CREDIT_PRODUCT_APPLICATION = true\n;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023017":{"id":3023017,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":160,"y":224,"width":32,"height":32,"inputConnectorIDs":[3023031],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"grant for teams"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"grant usage on schema bi to role looker_role;\ngrant select on all tables in schema bi to role looker_role;\ngrant usage on schema bi to data_engineering_group;\ngrant select on all tables in schema bi to data_engineering_group;\ngrant usage on schema bi to data_science_analytics;\ngrant select on all tables in schema bi to data_science_analytics;\ngrant usage on schema bi to read_only_internal_users;\ngrant select on all tables in schema bi to read_only_internal_users;\ngrant usage on schema bi to svc_segment;\ngrant select on all tables in schema bi to svc_segment;\ngrant usage on schema bi to Exactius;\ngrant select on all tables in schema bi to role Exactius;\n\ngrant select on all views in schema rdl to role looker_role;\ngrant select on all views in schema rdl to role data_engineering_group;\ngrant select on all views in schema rdl to role data_science_analytics;\ngrant select on all views in schema rdl to role read_only_internal_users;\ngrant select on all views in schema rdl to role svc_segment;\n\ngrant USAGE on SCHEMA bi to ANODOT_POC_ROLE;\nGRANT SELECT ON TABLE BI.DT_DEPOSITORY_TRANSACTIONS TO ANODOT_POC_ROLE;\n\ngrant usage on schema web_db to svc_segment;\ngrant select on all tables in schema web_db to svc_segment;\n\ngrant usage on schema bi to role MAR_FULL_ROLE;\ngrant select on all tables in schema bi to role MAR_FULL_ROLE;"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023018":{"id":3023018,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-288,"y":-336,"width":32,"height":32,"inputConnectorIDs":[3023036],"outputSuccessConnectorIDs":[3023004],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_leads"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\nDROP TABLE IF EXISTS bi_new.dt_leads;\n\nCREATE TABLE bi_new.dt_leads \ncluster by (user_id)\nAS\n(\n    WITH account_steps AS (\n        SELECT\n          us.invited_user_id AS user_id,\n          product_id,\n          account_type_id,\n          CASE WHEN upa.user_id IS NULL\n            THEN FALSE\n          ELSE TRUE END      AS has_started_application,\n          CASE\n          WHEN fee_amount IS NOT NULL\n            THEN TRUE\n          WHEN gross_income IS NOT NULL\n            THEN TRUE\n          WHEN funding_amount IS NOT NULL\n            THEN TRUE\n          WHEN first_name IS NULL\n            THEN FALSE\n          ELSE TRUE END      AS has_completed_contact_details,\n          CASE\n          WHEN fee_amount IS NOT NULL\n            THEN TRUE\n          WHEN funding_amount IS NOT NULL\n            THEN TRUE\n          WHEN gross_income IS NULL\n            THEN FALSE\n          ELSE TRUE END      AS has_completed_employment_and_finances,\n          CASE WHEN funding_amount IS NULL\n            THEN FALSE\n          ELSE TRUE END      AS has_entered_funding_amount,\n          CASE\n          WHEN uba.id IS NOT NULL\n            THEN TRUE\n          WHEN fee_amount IS NULL\n            THEN FALSE\n          ELSE TRUE END      AS has_entered_fee_amount,\n          CASE WHEN uba.id IS NULL\n            THEN FALSE\n          ELSE TRUE END      AS has_entered_bank_information,\n          CASE WHEN uba.is_verified = TRUE\n            THEN TRUE\n          ELSE FALSE END     AS has_successfully_linked_bank,\n          CASE\n          WHEN status = 4\n            THEN TRUE\n          WHEN tc.user_id IS NULL OR uba.is_verified IS NULL OR uba.is_verified = FALSE\n            THEN FALSE\n          ELSE TRUE END      AS has_accepted_terms_and_conditions,\n          CASE WHEN status = 4\n            THEN TRUE\n          ELSE FALSE END     AS has_funded_account\n        FROM web_db.user_signup us\n          LEFT JOIN web_db.user_product_application upa\n            ON us.invited_user_id = upa.user_id\n          LEFT JOIN web_db.user_profile up\n            ON upa.user_id = up.user_id\n          LEFT JOIN web_db.user_investment_profile uip\n            ON uip.user_id = upa.user_id\n          LEFT JOIN web_db.user_payment_account uba\n            ON uba.id = user_bank_account_id\n          LEFT JOIN (\n                      SELECT\n                        user_id\n                      FROM web_db.user_terms_conditions\n                      GROUP BY 1) tc\n            ON tc.user_id = us.invited_user_id\n    )\n      , user_steps AS (\n        SELECT\n          user_id,\n          CASE WHEN sum(CASE has_started_application\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_started_application,\n          CASE WHEN sum(CASE has_completed_contact_details\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_completed_contact_details,\n          CASE WHEN sum(CASE has_completed_employment_and_finances\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_completed_employment_and_finances,\n          CASE WHEN sum(CASE has_entered_funding_amount\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_entered_funding_amount,\n          CASE WHEN sum(CASE has_entered_fee_amount\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_entered_fee_amount,\n          CASE WHEN sum(CASE has_entered_bank_information\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_entered_bank_information,\n          CASE WHEN sum(CASE has_successfully_linked_bank\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_successfully_linked_bank,\n          CASE WHEN sum(CASE has_accepted_terms_and_conditions\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_accepted_terms_and_conditions,\n          CASE WHEN sum(CASE has_funded_account\n                        WHEN TRUE\n                          THEN 1\n                        ELSE 0 END) >= 1\n            THEN TRUE\n          ELSE FALSE END AS has_funded_account\n        FROM account_steps\n        GROUP BY 1\n    )\n\n\n    SELECT\n      CASE\n      WHEN ui.code = 'mi'\n        THEN 'iOS Signup'\n      WHEN ui.code = 'ma'\n        THEN 'Android Signup'\n      WHEN ui.inviting_user_id > 1\n        THEN 'Direct Invite'\n      WHEN wl.id IS NOT NULL\n        THEN 'Wait List'\n      WHEN ui.id IS NOT NULL\n        THEN 'Direct Invite'\n      ELSE 'Direct URL'\n      END                                                                     AS lead_source,\n      CASE\n        WHEN ui.code IN ('mi', 'ma') THEN convert_timezone('America/Los_Angeles',us.date_created)\n        WHEN wl.id IS NOT NULL THEN convert_timezone('America/Los_Angeles',wl.date_created)\n        WHEN ui.id IS NOT NULL THEN convert_timezone('America/Los_Angeles',ui.date_created)\n        ELSE convert_timezone('America/Los_Angeles',us.date_created)\n      END                                                                     AS lead_arrival_date,\n      convert_timezone('America/Los_Angeles',wl.date_created)                      AS wait_list_date,\n      convert_timezone('America/Los_Angeles',ui.date_created)                      AS invitation_date,\n      convert_timezone('America/Los_Angeles',us.date_created)                      AS signup_date,\n      wl.email                                                                AS wait_list_email,\n      ui.id as user_invitation_id,\n      CASE WHEN wl.id IS NULL OR ui.code IN ('mi', 'ma')\n        THEN FALSE\n      ELSE TRUE END                                                           AS is_wait_list_user,\n      CASE WHEN ui.id IS NULL OR ui.code IN ('mi', 'ma')\n        THEN FALSE\n      ELSE TRUE END                                                           AS is_invitation_sent,\n      CASE WHEN us.id IS NULL\n        THEN FALSE\n      ELSE TRUE END                                                           AS is_signed_up,\n      CASE WHEN uwa.user_id IS NULL\n        THEN FALSE\n      ELSE TRUE END                                                           AS has_created_account,\n      wl.utm_source                                                           AS wait_list_utm_source,\n      wl.utm_medium                                                           AS wait_list_utm_medium,\n      wl.utm_term                                                             AS wait_list_utm_term,\n      wl.utm_content                                                          AS wait_list_utm_content,\n      wl.utm_campaign                                                         AS wait_list_utm_campaign,\n      CASE\n      WHEN wl.id IS NULL\n        THEN 'Not On Wait List'\n      WHEN wl.product_id = 1 AND wl.account_type_id = 2\n        THEN 'Redwood Individual'\n      WHEN wl.product_id = 1 AND wl.account_type_id = 3\n        THEN 'Redwood IRA'\n      WHEN wl.product_id = 2 AND wl.account_type_id = 2\n        THEN 'Flagship Individual'\n      WHEN wl.product_id = 2 AND wl.account_type_id = 3\n        THEN 'Flagship IRA'\n      WHEN wl.product_id IN (3, 4)\n        THEN 'Checking'\n      ELSE 'Unattributed'\n      END                                                                     AS wait_list_product_type,\n      wl.is_sierra_club_referral,\n      wl.is_accepting_email,\n      CASE WHEN ui.inviting_user_id > 1 OR us.inviting_user_id > 1\n        THEN TRUE\n      ELSE FALSE END                                                          AS is_referral,\n      CASE WHEN ui.id IS NULL AND wl.is_accepting_email = FALSE\n        THEN TRUE\n      ELSE FALSE END                                                          AS wait_list_opt_out,\n      CASE\n      WHEN has_funded_account\n        THEN 'Has Funded Account'\n      WHEN has_accepted_terms_and_conditions\n        THEN 'Has Accepted Terms & Conditions'\n      WHEN has_successfully_linked_bank\n        THEN 'Has Successfully Linked Bank'\n      WHEN has_entered_bank_information\n        THEN 'Has Entered Bank Information'\n      WHEN has_entered_fee_amount\n        THEN 'Has Entered Fee Amount'\n      WHEN has_entered_funding_amount\n        THEN 'Has Entered Funding Amount'\n      WHEN has_completed_employment_and_finances\n        THEN 'Has Completed Employment and Finances'\n      WHEN has_completed_contact_details\n        THEN 'Has Completed Contact Details'\n      WHEN has_started_application\n        THEN 'Has Started Application'\n      WHEN us.invited_user_id IS NOT NULL\n        THEN 'Has Created Credentials'\n      ELSE 'Not Created Credentials'\n      END                                                                     AS funnel_stage,\n      coalesce(has_accepted_terms_and_conditions, FALSE)                      AS has_accepted_terms_and_conditions,\n      coalesce(has_successfully_linked_bank, FALSE)                           AS has_successfully_linked_bank,\n      coalesce(has_entered_bank_information, FALSE)                           AS has_entered_bank_information,\n      coalesce(has_entered_fee_amount, FALSE)                                    has_entered_fee_amount,\n      coalesce(has_entered_funding_amount, FALSE)                                has_entered_funding_amount,\n      coalesce(has_completed_employment_and_finances, FALSE)                  AS has_completed_employment_and_finances,\n      coalesce(has_completed_contact_details, FALSE)                          AS has_completed_contact_details,\n      coalesce(has_started_application, FALSE)                                AS has_started_application,\n      us.invited_user_id                                                      AS user_id,\n      first_inception_date,\n      CASE WHEN wl.date_created IS NULL OR first_inception_date IS NULL\n        THEN NULL\n      ELSE greatest((first_inception_date::date - wl.date_created :: DATE)::int,\n                    0) END                                                    AS days_between_wait_list_and_first_account,\n      CASE WHEN ui.date_created IS NULL OR first_inception_date IS NULL\n        THEN NULL\n      ELSE greatest((first_inception_date::date - ui.date_created :: DATE)::int,\n                    0) END                                                    AS days_between_invitation_and_first_account,\n      CASE WHEN wl.date_created IS NULL OR ui.date_created IS NULL\n        THEN NULL\n      ELSE greatest((ui.date_created :: DATE - wl.date_created :: DATE)::int, 0) END AS days_between_wait_list_and_invitation,\n      CASE WHEN us.date_created IS NULL OR ui.date_created IS NULL\n        THEN NULL\n      ELSE greatest((us.date_created :: DATE - ui.date_created :: DATE)::int, 0) END AS days_between_invitation_and_signup,\n      CASE WHEN first_inception_date IS NULL OR us.date_created IS NULL\n        THEN NULL\n      ELSE greatest((first_inception_date::date - us.date_created :: DATE)::int, 0) END    AS days_between_signup_and_first_account\n    FROM\n      web_db.user_signup us\n      FULL OUTER JOIN web_db.user_invitation ui\n        ON us.user_invitation_id = ui.id\n      FULL OUTER JOIN web_db.wait_list_user wl\n        ON wl.email = ui.email\n      LEFT JOIN (\n                  SELECT\n                    user_id\n                  FROM web_db.user_product_application upa\n                  WHERE status = 4\n                  GROUP BY 1) uwa\n        ON uwa.user_id = us.invited_user_id\n      LEFT JOIN (\n                  SELECT\n                    user_id\n                  FROM web_db.user_product_application upa\n                  GROUP BY 1) app\n        ON app.user_id = us.invited_user_id\n      LEFT JOIN (\n                  SELECT\n                    user_id,\n                    min(inception_date) AS first_inception_date\n                  FROM (\n                         SELECT\n                           user_id,\n                           inception_date\n                         FROM web_db.depository d INNER JOIN web_db.user_account ua\n                             ON d.account_id = ua.account_id\n                         WHERE inception_date IS NOT NULL\n                         UNION ALL\n                         SELECT\n                           user_id,\n                           inception_date\n                         FROM web_db.investment i INNER JOIN web_db.user_account ua\n                             ON i.account_id = ua.account_id\n                         WHERE inception_date IS NOT NULL\n                       ) a\n                  GROUP BY 1\n                ) fa\n        ON fa.user_id = us.invited_user_id\n      LEFT JOIN user_steps st\n        ON st.user_id = us.invited_user_id\n  )\n;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023019":{"id":3023019,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-96,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023043],"outputSuccessConnectorIDs":[3023003],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_user_monthly_data"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\nDROP TABLE IF EXISTS bi_new.dt_user_monthly_data;\n\nCREATE TABLE bi_new.dt_user_monthly_data \n--cluster by (user_id)\nAS\n(\n    WITH end_of_month_data AS (SELECT\n                                 b.user_id,\n                                 a.month,\n                                 b.daily_total_assets         AS end_of_month_assets,\n                                 b.daily_total_assets_actual  AS end_of_month_assets_actual,\n                                 b.daily_summit_assets_actual AS end_of_month_summit_assets_actual,\n                                 b.daily_summit_spend_assets_actual AS end_of_month_summit_spend_assets_actual,\n                                 b.daily_summit_save_assets_actual  AS end_of_month_summit_save_assets_actual,                               \n                                 b.monthly_usd_fee_setting    AS total_monthly_usd_fee_setting,\n                                 b.yearly_percent_fee_setting AS total_yearly_percent_fee_setting,\n                                 b.opened_accounts            AS opened_accounts\n                               FROM (\n                                      SELECT\n                                        date_trunc('month', convert_timezone('America/Los_Angeles',date)) :: DATE AS month,\n                                        max(date)                         AS max_date\n                                      FROM bi_new.dt_user_daily_data\n                                      GROUP BY 1\n                                    ) a INNER JOIN bi_new.dt_user_daily_data b\n                                   ON a.max_date = b.date)\n      , avg_data AS (\n        SELECT\n          a.user_id,\n          date_trunc('month', convert_timezone('America/Los_Angeles',date)) :: DATE AS month,\n          avg(daily_total_assets)           AS average_daily_assets,\n          min(daily_total_assets)           AS min_daily_assets,\n          max(daily_total_assets)           AS peak_assets,\n          max(daily_summit_assets)          as peak_summit_assets,\n          avg(daily_total_assets_actual)           AS average_daily_assets_actual,\n          min(daily_total_assets_actual)           AS min_daily_assets_actual,\n          max(daily_total_assets_actual)           AS peak_assets_actual,\n          avg(daily_summit_assets_actual)          AS average_summit_assets_actual,\n          min(daily_summit_assets_actual)          AS min_summit_assets_actual,\n          max(daily_summit_assets_actual)          AS peak_summit_assets_actual,\n          avg(daily_summit_spend_assets_actual)    AS average_summit_spend_assets_actual,\n          min(daily_summit_spend_assets_actual)    AS min_summit_spend_assets_actual,\n          max(daily_summit_spend_assets_actual)    AS peak_summit_spend_assets_actual,\n          avg(daily_summit_save_assets_actual)     AS average_summit_save_assets_actual,\n          min(daily_summit_save_assets_actual)     AS min_summit_save_assets_actual,\n          max(daily_summit_save_assets_actual)     AS peak_summit_save_assets_actual,\n          max(daily_investment_assets_actual)      AS peak_investment_assets_actual,          \n          max(case when daily_investment_assets > 0\n            then daily_investment_assets\n              else null end)                as peak_investment_assets,\n          sum(case when has_ios_login or has_android_login or has_web_login\n            then 1\n              else 0 end)                   as unique_daily_logins,\n          sum(case when has_ios_login\n            then 1\n              else 0 end)                   as unique_ios_daily_logins,\n          sum(case when has_android_login\n            then 1\n              else 0 end)                   as unique_android_daily_logins,\n          sum(case when has_web_login\n            then 1\n              else 0 end)                   as unique_web_daily_logins,\n          sum(num_funded_daily_referrals)   as num_funded_monthly_referrals,\n          max(nps_score) as nps_score\n        FROM bi_new.dt_user_daily_data a\n        GROUP BY 1, 2\n    )\n\n    SELECT\n      a.user_id,\n      a.month,\n      a.total_yearly_percent_fee_setting,\n      a.total_monthly_usd_fee_setting,\n      coalesce(c.total_fee_billed, 0) as total_fee_billed,\n      a.end_of_month_assets,\n      a.end_of_month_assets_actual,\n      a.end_of_month_summit_assets_actual,\n      a.end_of_month_summit_spend_assets_actual,\n      a.end_of_month_summit_save_assets_actual,    \n      a.opened_accounts,\n      b.average_daily_assets,\n      b.min_daily_assets,\n      b.peak_assets,\n      b.peak_summit_assets,\n      b.peak_investment_assets,\n      b.average_daily_assets_actual,\n      b.min_daily_assets_actual,\n      b.peak_assets_actual,\n      b.average_summit_assets_actual,\n      b.min_summit_assets_actual,\n      b.peak_summit_assets_actual,\n      b.average_summit_spend_assets_actual,\n      b.min_summit_spend_assets_actual,\n      b.peak_summit_spend_assets_actual,\n      b.average_summit_save_assets_actual,\n      b.min_summit_save_assets_actual,\n      b.peak_summit_save_assets_actual,\n      b.peak_investment_assets_actual,    \n      b.unique_daily_logins,\n      b.unique_ios_daily_logins,\n      b.unique_android_daily_logins,\n      b.unique_web_daily_logins,\n      b.num_funded_monthly_referrals,\n      b.nps_score,\n\n      ROW_NUMBER() OVER(order by null) AS unique_id\n    FROM end_of_month_data a INNER JOIN avg_data b\n        ON a.user_id = b.user_id AND a.month = b.month\n      left JOIN (\n                  select\n                    user_id,\n                    month,\n                    sum(billed_pwif_this_month) as total_fee_billed\n                  FROM bi_new.dt_account_monthly_data a inner JOIN bi_new.dt_accounts b\n                      on a.unique_account_id = b.unique_account_id\n                  group by 1, 2) c\n        on a.user_id = c.user_id and a.month = c.month\n  )\n;\n\n\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023020":{"id":3023020,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":96,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023003],"outputSuccessConnectorIDs":[3023030],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Update account migration batch info"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"SET TIMEZONE = 'America/Los_Angeles';\n\nalter table bi_new.dt_accounts add migration_batch varchar(64);\nalter table bi_new.dt_users add checking_invite_list_batch varchar(64);\n\nupdate bi_new.dt_users\nset checking_invite_list_batch = 'Invite list batch #1 - 2k'\nwhere user_email in (select mb.email_address from rdl.migration_batches mb where mb.migration_group_category = 'Invite list batch #1 - 2k')\n  and checking_invite_list_batch is null\n  and user_id in (select wls.user_id from web_db.wait_list_summit wls)\n;\n\nupdate bi_new.dt_users\nset checking_invite_list_batch = 'Invite list batch #2 - 8k'\nwhere user_email in (select mb.email_address from rdl.migration_batches mb where mb.migration_group_category = 'Invite list batch #2 - 8k')\n  and checking_invite_list_batch is null\n  and user_id in (select wls.user_id from web_db.wait_list_summit wls)\n;\n\nupdate bi_new.dt_users\nset checking_invite_list_batch = 'Invite list batch #3 - 12k'\nwhere user_email in (select mb.email_address from rdl.migration_batches mb where mb.migration_group_category = 'Invite list batch #3 - 12k')\n  and checking_invite_list_batch is null\n  and user_id in (select wls.user_id from web_db.wait_list_summit wls)\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Employee Testing'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Employee Testing'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Friends & Family'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Customer Wish'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'First 500 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'High-Active,Lower-Value'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Second batch - 1000 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'High-Active,Lower-Value 2nd run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Third batch - 5000 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'High-Active,Lower-Value 3rd run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Fourth batch - 15000 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'High-Active,Lower-Value 4th run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Fifth batch - 30000 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Higher-Value,Less-Active 5th run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Sixth batch - 36000 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Lower-Value,Less-Active 6th run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Seventh batch - 14000 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Last Batch 1st run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Eighth batch - 2303 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Last Batch 2nd run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Ninth batch - 49 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Last Batch 3rd run'\n                            )\n\tand migration_batch is null\n;\n\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Joint primary users batch - 512 customers'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Joint Primary 1st run'\n                            )\n\tand migration_batch is null\n;\n\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Expedited Customers - 1st batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Expedited Customers 1st run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Expedited Customers - 2nd batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Expedited Customers 2nd run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Expedited Customers - 3rd batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Expedited Customers 3rd run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Expedited Customers - 4th batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Expedited Customers 4th run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Expedited Customers - 5th batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Expedited Customers 5th run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Expedited Customers - 6th batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category = 'Expedited Customers 6th run'\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Unsubscribed Customers - 1st batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category in ('Unsubscribes 1st run', 'Expedited Customers 6th run (invalid emails)')\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Unsubscribed Customers - 2nd batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category in ('Unsubscribes 2nd run')\n                            )\n\tand migration_batch is null\n;\n\nupdate bi_new.dt_accounts\nset migration_batch = 'Unsubscribes Joint Primary 1st batch'\nwhere 1=1\n\tand account_type = 'Checking'\n\tand user_id in (\n                            select dtu.user_id\n                            from bi_new.dt_users dtu\n                            inner join rdl.migration_batches rmb on (rmb.user_id = dtu.user_id)\n                            where 1=1\n                              and rmb.migration_group_category in ('Unsubscribes Joint Primary 1st run')\n                            )\n\tand migration_batch is null\n;\n"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023021":{"id":3023021,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"CONDITIONAL","executionHint":"FLOW","implementationID":-1357378929,"x":-832,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023050],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[3023044],"outputFalseConnectorIDs":[3023045],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"If 5pm"}}}},"visible":true},"2":{"slot":2,"name":"Mode","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"Simple"}}}},"visible":true},"3":{"slot":3,"name":"Condition","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"job_hour"},"2":{"slot":2,"type":"STRING","value":"Is"},"3":{"slot":3,"type":"STRING","value":"Equal to"},"4":{"slot":4,"type":"STRING","value":"17"}}}},"visible":true},"4":{"slot":4,"name":"Combine Conditions","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"And"}}}},"visible":true},"5":{"slot":5,"name":"Condition","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":""}}}},"visible":false}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023022":{"id":3023022,"inputCardinality":"ONE","outputCardinality":"MANY","connectorHint":"SUCCESS_FAIL","executionHint":"EXECUTE","implementationID":-798585337,"x":-560,"y":-336,"width":32,"height":32,"inputConnectorIDs":[3023006],"outputSuccessConnectorIDs":[3023048],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"dt_accounts_unfunded"}}}},"visible":true},"2":{"slot":2,"name":"SQL Script","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"set timezone = 'America/Los_Angeles';\n\nDROP TABLE IF EXISTS bi.dt_accounts_with_unfunded;\nCREATE TABLE bi.dt_accounts_with_unfunded\nAS\n(\nWITH qualifying_depository\nAS\n(\n\tSELECT DISTINCT\n\t\td.id         AS depository_id,\n\t\td.account_id\n\tFROM web_db.depository d\n\tWHERE d.inception_date IS NOT NULL\n\t\tAND d.inception_date >= '2017-01-01'\n\t\tAND d.current_balance = 0\n-- \t\tAND d.id = 211527\n)\n\n, ua_sec_rem\nAS\n(\n\tSELECT ua.*\n\tFROM\n\t(\n\t\tSELECT account_id,\n\t\t\tMIN(date_created) AS min_date\n\t\tFROM web_db.user_account\n\t\tGROUP BY 1\n\t) a\n\tINNER JOIN web_db.user_account ua ON a.account_id = ua.account_id AND a.min_date = ua.date_created\n)\n\n, active_upa_count\nAS\n(\n\tSELECT qd.depository_id,\n\t\tSUM(CASE\n\t\t\t\tWHEN upa.is_admin_disabled != TRUE THEN 1\n\t\t\t\tELSE 0\n\t\t\tEND) AS active_upa_count\n\tFROM qualifying_depository qd\n\tLEFT JOIN ua_sec_rem ua ON qd.account_id = ua.account_id\n\tLEFT JOIN web_db.user_payment_account upa ON ua.user_id = upa.user_id\n\tWHERE upa.depository_id IS NULL\n\tGROUP BY 1\n)\n-- select *\n-- from active_upa_count\n-- ;\n\n, transaction_count\nAS\n(\n\tSELECT qd.depository_id,\n\t\tSUM(CASE\n\t\t\t\tWHEN NOT mt.description ILIKE 'YIELD=%' AND NOT mt.description ILIKE 'N/A' THEN 1\n\t\t\t\tELSE 0\n\t\t\tEND) AS transaction_count\n\tFROM qualifying_depository qd\n\tLEFT JOIN web_db.miser_transaction mt ON qd.depository_id = mt.depository_id\n\tGROUP BY 1\n\n\tUNION\n\n\tSELECT qd.depository_id,\n\t\tCOUNT(*) AS transaction_count\n\tFROM qualifying_depository qd\n\tINNER JOIN web_db.posted_transaction pt on qd.depository_id = pt.depository_id\n\tINNER JOIN web_db.galileo_posted_transaction gpt ON pt.id = gpt.posted_transaction_id\n\tWHERE gpt.transaction_code_type NOT IN ('ADz', 'PMIT', 'PMMZ')\n\tGROUP BY 1\n)\n-- select *\n-- from transaction_count\n-- ;\n\n, excluded_deposits\nAS\n(\n\tSELECT depository_id,\n\t\tSUM(COALESCE(amount, 0)) AS interest_paid\n\tFROM web_db.miser_transaction\n\tWHERE description LIKE 'YIELD=%' OR (amount <= 1 AND amount > 0)\n\tGROUP BY 1\n\n\tUNION\n\n\tSELECT pt.depository_id,\n\t\tSUM(COALESCE(pt.amount, 0)) AS interest_paid\n\tFROM web_db.posted_transaction pt\n\tINNER JOIN web_db.galileo_posted_transaction gpt ON (gpt.posted_transaction_id = pt.id)\n\tWHERE gpt.transaction_code_type IN ('ADz', 'PMIT', 'PMMZ') OR (pt.amount <= 1 AND pt.amount > 0)\n\tGROUP BY 1\n)\n-- select *\n-- from excluded_deposits ed\n-- where ed.depository_id = 211527\n-- ;\n\n\n\n, failed_galileo_transactions\nAS\n(\n\t\t\tselect\n\t\t\t\t'g'|| pt.depository_id as unique_account_id\n\t\t\t\t,row_number() over (partition by unique_account_id order by pt.post_date) as transaction_number\n\t\t\t\t,gl.description as transaction_type\n\t\t\tfrom web_db.galileo_posted_transaction gpt\n\t\t\tinner join web_db.posted_transaction pt on gpt.posted_transaction_id = pt.id\n\t\t\tinner JOIN web_db.galileo_lookup gl on (gl.code = gpt.transaction_code_type AND gl.file = 'P' AND gl.field_name = 'TRANSACTION CODE/TYPE')\n)\n\n,failed_transactions\nAS\n(\n      SELECT 'r' || depository_id AS unique_account_id\n      FROM web_db.miser_transaction mt\n      INNER JOIN web_db.depository d ON mt.depository_id = d.id AND mt.transaction_date <= inception_date + 10\n      WHERE description LIKE 'ACH RETURN%'\n      \tOR description LIKE '%REVERSAL OF ACH%'\n      \tOR description LIKE '%PAID ACH NSF%'\n      \tOR description LIKE '%ACH REVERSAL%'\n      GROUP BY 1\n\n\t\t\tunion all\n\n\t\t\tselect unique_account_id\n\t\t\tfrom failed_galileo_transactions fgt\n\t\t\twhere (fgt.transaction_type ilike 'Coastal ACH Reversal'\n\t\t\t\t\t\t\t\tor fgt.transaction_type ilike 'API funds transfer'\n\t\t\t\t\t\t\t\tor fgt.transaction_type ilike 'Reversal-Credit Account'\n\t\t\t\t\t\t\t\tor fgt.transaction_type ilike 'Reversal-Debiting Account'\n\t\t\t\t\t\t\t\tor fgt.transaction_type ilike 'Settlement Reversals'\n\t\t\t\t\t\t\t\tor fgt.transaction_type ilike 'Returned ACH Items'\n\t\t\t\t\t\t\t\tor fgt.transaction_type ilike 'Force Post Settle-Could not match to an Auth'\n\t\t\t\t\t\t\t\tor fgt.transaction_type ilike 'RDC Other Check Dep Ret'\n\t\t\t\t\t\t\t\t)\n\t\t\t\tand fgt.transaction_number = 2\n)\n-- select *\n-- from failed_transactions ft\n-- where ft.unique_account_id ilike 'r211527'\n-- ;\n\n, galileo_balance\nas\n(\n        SELECT upa.account_id\n            , t.file_date as balance_date\n            , MAX(CASE WHEN t.type_of_account = '6'\n                       THEN (trim(t.current_balance_sign) || trim(t.current_balance))::dec(18,2) END) AS spend_current_balance\n            , MAX(CASE WHEN t.type_of_account = '8'\n                       THEN (trim(t.current_balance_sign) || trim(t.current_balance))::dec(18,2) END) AS save_current_balance\n        FROM rdl.raw_galileo_customer_master_data t\n        JOIN aog_db.galileo_accounts ga ON (ga.galileo_account_number = t.galileo_account_id)\n        JOIN web_db.user_product_application upa ON (upa.id = ga.aspiration_application_id)\n        WHERE ga.active = true\n            AND upa.account_type_id = 2\n        GROUP BY ga.aspiration_user_id, t.file_date, upa.account_id\n),\n\ndata\nAS\n(\n\tSELECT\n\t\ta.*,\n\t\taccount_number AS radius_account_number,\n\t\tip.interest_paid\n\tFROM\n\t(\n\t\tSELECT\n\t\t  d.id as depository_id,\n\t\t\td.account_id,\n\t\t\td.inception_date,\n\t\t\tMAX(IFNULL(gb.spend_current_balance, 0) + IFNULL(gb.save_current_balance, 0) + IFNULL(db.current_balance, 0)) AS largest_post_30_day_balance\n\t\tFROM failed_transactions ft\n\t\tINNER JOIN web_db.depository d ON 'r' || d.id = ft.unique_account_id\n\t\tLEFT JOIN web_db.depository_balance db on d.id = db.depository_id AND db.balance_date >= least(d.inception_date + 30,\n\t\t\t\t\t\t                                                                                    (\n\t\t\t\t\t\t\t                                                                                    SELECT MAX(balance_date)::date\n\t\t\t\t\t\t\t                                                                                    FROM web_db.depository_balance\n\t\t\t\t\t\t                                                                                    )\n\t\t\t\t\t\t                                                                                )\n\t\tLEFT JOIN galileo_balance gb on d.account_id = gb.account_id and gb.balance_date >= least(d.inception_date + 30,\n\t\t   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( SELECT MAX(balance_date)::date FROM galileo_balance\n\t\t\t\t\t\t                                                                                    )\n\t\t\t\t\t\t                                                                                )\n\t\t  GROUP BY 1, 2,3\n\t) a LEFT JOIN excluded_deposits ip ON a.depository_id = ip.depository_id\n\tINNER JOIN web_db.user_payment_account upa ON a.depository_id = upa.depository_id\n)\n-- select *\n-- from data\n-- where depository_id = 211527\n-- ;\n\n\n, excluded_accounts\nAS\n(\n\tSELECT depository_id\n\tFROM data\n\tWHERE largest_post_30_day_balance <= coalesce(interest_paid, 0)\n\t\tAND inception_date >= '2017-12-01'\n\n\tUNION\n\n\tSELECT qd.depository_id\n\tFROM qualifying_depository qd\n\tINNER JOIN web_db.depository d on qd.depository_id = d.id\n\tLEFT JOIN active_upa_count auc ON qd.depository_id = auc.depository_id\n\tLEFT JOIN transaction_count tc ON qd.depository_id = tc.depository_id\n\tWHERE auc.active_upa_count = 0\n\t\tAND IFNULL(tc.transaction_count, 0) = 0\n\t\tAND d.inception_date >= '2017-12-01'\n)\n-- select *\n-- from excluded_accounts\n-- where depository_id = 211527\n-- ;\n\n, radius_accounts\nAS\n(\n\t\tSELECT ua.user_id,\n\t\t\td.id AS radius_id\n\t\tFROM web_db.depository d\n\t\tINNER JOIN ua_sec_rem ua ON ua.account_id = d.account_id\n\t\tINNER JOIN web_db.account a on a.id = d.account_id\n\t\tWHERE a.custodian_id = 2\n\t\t\tAND d.product_id = 3\n\t\t\tAND d.inception_date IS NOT NULL\n)\n-- select *\n-- from radius_accounts\n-- where radius_id = 211527\n-- ;\n\n\n, galileo_accounts\nAS\n(\n\t\tSELECT ua.user_id,\n\t\t\td.id AS galileo_id,\n            depo.galileo_save_id,\n\t\t\td.inception_date as galileo_inception_date,\n\n\t     \tcase\n\t\t        when d.product_id = 4 and depo.account_id is not null then d.inception_date\n\t\t        else null\n\t        end AS spend_enable_date\n\n\t\tFROM (\n          select id,\n                account_id,\n                product_id,\n                min(inception_date) OVER (PARTITION BY account_id ORDER BY inception_date asc nulls last) AS inception_date,\n                row_number() over(partition by account_id order by product_id) AS rowNum\n          from web_db.depository\n          where product_id in (4, 5)\n         ) AS d\n\t\tINNER JOIN ua_sec_rem ua on ua.account_id = d.account_id\n\t\tINNER JOIN web_db.account a on a.id = d.account_id\n    LEFT JOIN (\n                select id as galileo_save_id,\n                    account_id,\n                    inception_date\n                from web_db.depository\n                where product_id = 5\n              ) depo on depo.account_id = d.account_id\n\n\t\tWHERE a.custodian_id = 3\n        AND d.rowNum = 1\n--\t\t\tAND d.product_id = 4\n--\t\t\tAND d.inception_date IS NOT NULL -- termporary fix until soft eng fixes inception_date for migrated accounts\n    )\n-- select *\n-- from galileo_accounts\n-- where galileo_id = 211654\n-- ;\n\n\n, account_map\nAS\n(\n\t\tSELECT COALESCE(r.user_id, g.user_id)                                    AS user_id,\n\t\t\tr.radius_id,\n\t\t\tg.galileo_id,\n            g.galileo_save_id,\n\t\t\tCOALESCE('r' || r.radius_id, '') || COALESCE('g' || g.galileo_id, '') AS unique_account_id,\n\t\t\tg.galileo_inception_date,\n\t\t\tg.spend_enable_date\n\t\tFROM radius_accounts r\n\t\tFULL OUTER JOIN galileo_accounts g ON r.user_id = g.user_id\n  )\n-- select *\n-- from account_map\n-- where radius_id = 211527\n-- ;\n\n\n, filtered_account_map\nas\n(\n    select am.*,\n            CASE\n                WHEN exc_r.depository_id is null--am.radius_id not in (select ea.depository_id from excluded_accounts ea)\n                  OR am.radius_id IS NULL\n                  OR exc_g.depository_id is null--am.galileo_id not in (select ea.depository_id from excluded_accounts ea)\n                  OR am.galileo_id IS NULL\n                  OR (radius_id is not null and galileo_id is not null) THEN false\n                ELSE true\n            END AS unfunded_account_ind\n    from account_map am\n    left join excluded_accounts exc_r on am.radius_id = exc_r.depository_id\n    left join excluded_accounts exc_g on am.galileo_id = exc_g.depository_id\n--     where (radius_id is not null and galileo_id is not null\n-- \t\t\tor ( (am.radius_id not in (select ea.depository_id from excluded_accounts ea) OR am.radius_id IS NULL)\n--                  and (am.galileo_id not in (select ea.depository_id from excluded_accounts ea) OR am.galileo_id IS NULL)\n--               )\n--           )\n)\n-- select *\n-- from filtered_account_map\n-- where 1=1\n-- \t\tand radius_id = 211527\n-- -- \tand galileo_id is null\n-- ;\n\n\n  , current_fee as (\n      select depository_id,\n              fee_amount\n      from (\n              select depository_id,\n                      fee_amount,\n                      row_number() over (partition by depository_id order by depository_id desc) row_num\n              from web_db.depository_fee_history\n            ) as a\n      where row_num = 1\n  )\n\n, consolidated_data\nAS\n(\n    SELECT\n      am.unique_account_id,\n\t\t\tam.unfunded_account_ind,\n      am.user_id,\n      'Checking'                                                       AS account_type,\n      coalesce(r.inception_date, am.galileo_inception_date)            AS inception_date,\n\n      CASE WHEN am.radius_id IS NOT NULL THEN g.date_created END       AS migration_date,\n\n      coalesce(upa_r.funding_amount, upa_g.funding_amount)             AS funding_amount,\n      coalesce(upa_r.fee_amount, upa_g.fee_amount)                     AS opening_monthly_usd_fee_setting,\n      (coalesce(upa_r.fee_amount, upa_g.fee_amount) * 12) /\n      nullif((1.0 * coalesce(upa_r.funding_amount, upa_g.funding_amount)),0)     AS opening_yearly_percent_fee_setting,\n      case\n        when cf_g.depository_id > cf_a.depository_id then cf_g.fee_amount\n        else cf_a.fee_amount end                                       AS current_monthly_usd_fee_setting,\n     null                                                               AS current_yearly_percent_fee_setting,\n      coalesce(upa_r.user_bank_account_id, upa_g.user_bank_account_id) AS funding_bank_account_id,\n      coalesce(upa_r.ip_address, upa_g.ip_address)                     AS application_ip_address,\n\n      coalesce(upa_r.date_created,  case\n                                      when g.product_id = 5 then null -- temporary make it null to be able to find save only accounts\n                                      else upa_g.date_created\n                                    end)                                AS application_created_datetime,\n\n      case when g.id IS NOT NULL\n        then gdclosed.termination_date::date\n      else r_a.termination_date::date end                                    AS termination_date,\n\n      coalesce(gd.current_balance, g.current_balance,   CASE\n                                                            -- nullify balance when it is post termination date\n                                                            WHEN CURRENT_DATE <= r_a.termination_date::date THEN r.current_balance\n                                                            ELSE 0\n                                                        END) AS current_balance,\n      gd.spend_current_balance,\n      gd.save_current_balance,\n      null                                                             AS initial_monthly_recurring_investment_amount,\n      null                                                             AS current_monthly_recurring_investment_amount,\n      radius_id,\n      galileo_id,\n      null                                                             AS investment_id,\n      case when g.id IS NULL\n        then case when r_ua.account_id IS NOT NULL\n          then true\n             else false end\n      else\n        case when g_ua.account_id IS NOT NULL\n          then true\n        else false end end                                             AS is_joint_account,\n      upa.account_number                                               AS summit_account_number,\n      case when b.account_number IS NULL\n        then false\n      else true end                                                    AS is_charged_off,\n      b.chargeoff_reason,\n      b.total_amount_charged_off,\n      b.hard_loss_charge_off,\n      b.fees_charged_off,\n      case when ex.depository_id IS NULL\n        then false\n      else true end                                                    AS is_ineligible_for_migration,\n\n      coalesce(g_a.is_admin_disabled, r_a.is_admin_disabled)            AS is_admin_disabled,\n      gd.spend_galileo_prn,\n      gd.save_galileo_prn,\n      gd_dbt_act.debit_card_activation_date,\n      gd_dbt_ship.debit_card_shipping_date,\n      case when gd_dbt_act.debit_card_activation_date >= gd_dbt_ship.debit_card_shipping_date\n           then datediff(day,gd_dbt_ship.debit_card_shipping_date,gd_dbt_act.debit_card_activation_date)\n           else null end AS debit_card_days_to_activation,\n\n      am.spend_enable_date AS spend_enable_date,\n      am.galileo_save_id\n\n    FROM filtered_account_map am\n    LEFT JOIN web_db.depository r on r.id = am.radius_id\n\tLEFT JOIN web_db.depository g on g.id = am.galileo_id\n\tLEFT JOIN web_db.user_product_application upa_r on upa_r.user_id = am.user_id AND upa_r.product_id = r.product_id AND upa_r.status IN (3, 4)\n\tLEFT JOIN web_db.user_product_application upa_g on upa_g.user_id = am.user_id AND upa_g.product_id = g.product_id AND upa_g.status IN (3, 4)\n\tLEFT JOIN web_db.account r_a on r_a.id = r.account_id\n\tLEFT JOIN web_db.account g_a on g_a.id = g.account_id\n  LEFT JOIN current_fee cf_a on cf_a.depository_id = am.radius_id\n  LEFT JOIN current_fee cf_g on cf_g.depository_id = am.galileo_id\n    LEFT JOIN\n    (\n\t    SELECT\n\t\t\tga.aspiration_user_id,\n\t\t\tSUM(rgcmd.current_balance) as current_balance,\n\t\t\tMAX(case when rgcmd.type_of_account = '6' then rgcmd.current_balance end) as spend_current_balance,\n\t\t\tMAX(case when rgcmd.type_of_account = '8' then rgcmd.current_balance end) as save_current_balance,\n\t\t\tMAX(case when rgcmd.type_of_account = '6' then ga.pmt_ref_no end) as spend_galileo_prn,\n\t\t\tMAX(case when rgcmd.type_of_account = '8' then ga.pmt_ref_no end) as save_galileo_prn\n\n\t    FROM\n\t    (\n\t    \tSELECT t.galileo_account_id,\n\t    \t\tt.type_of_account,\n\t    \t\t(trim(t.current_balance_sign) || trim(t.current_balance))::dec(18,2) AS current_balance,\n\t    \t\tROW_NUMBER() OVER(PARTITION BY t.galileo_account_id ORDER BY t.file_date DESC) AS rn\n\t\t    FROM rdl.raw_galileo_customer_master_data t\n\t    ) AS rgcmd\n\t    INNER JOIN aog_db.galileo_accounts ga ON (ga.galileo_account_number = rgcmd.galileo_account_id)\n\t    INNER JOIN web_db.user_product_application upa ON (upa.id = ga.aspiration_application_id)\n\t    WHERE rgcmd.rn = 1\n\t  \t\tAND ga.active = true\n\t  \t\tAND upa.account_type_id = 2\n\t\tGROUP BY ga.aspiration_user_id\n    ) AS gd ON (gd.aspiration_user_id = am.user_id)\n\n\tLEFT JOIN\n\t(\n\t  with cte_ship_date as (\n            select acd.prn,\n                   acd.file_date,\n                   acd.card_id,\n                   row_number() over (partition by acd.prn order by acd.file_date asc nulls last,\n                                                                    acd.card_id::int asc nulls last) as row_num\n            from rdl.raw_galileo_account_card_data acd\n            inner join rdl.raw_galileo_customer_master_data cmd on (cmd.galileo_account_id = acd.galileo_account_id)\n            where cmd.type_of_account = '6'\n              and acd.status = 'Y'\n      )\n        select prn,\n\t       file_date as debit_card_shipping_date,\n\t       card_id\n        from cte_ship_date\n        where row_num = 1\n      ) AS gd_dbt_ship ON (gd_dbt_ship.prn = gd.spend_galileo_prn)\n\n\tLEFT JOIN\n\t(\n\t\tselect acd.prn,\n\t\t       acd.card_id,\n\t\t       min(acd.file_date) as debit_card_activation_date\n\t\tfrom rdl.raw_galileo_account_card_data acd\n\t\tinner join rdl.raw_galileo_customer_master_data cmd on (cmd.galileo_account_id = acd.galileo_account_id)\n\t\twhere cmd.type_of_account = '6'\n\t          and acd.status = 'N'\n\t\tgroup by 1,2\n\t) AS gd_dbt_act ON gd_dbt_ship.prn = gd_dbt_act.prn\n                       AND gd_dbt_ship.card_id = gd_dbt_act.card_id\n\n    LEFT JOIN\n    (\n        SELECT ga.aspiration_account_number, min(rgcmd.file_date) as termination_date\n        FROM rdl.raw_galileo_customer_master_data rgcmd\n        INNER JOIN aog_db.galileo_accounts ga ON (ga.galileo_account_number = rgcmd.galileo_account_id)\n        INNER JOIN web_db.user_product_application upa ON (upa.id = ga.aspiration_application_id)\n        WHERE rgcmd.type_of_account = '6'\n          and rgcmd.status in ('C', 'Z')\n          AND ga.card_id IS NOT NULL\n          AND ga.active = true\n          AND upa.account_type_id = 2\n        group by ga.aspiration_account_number\n\n    ) AS gdclosed ON (gdclosed.aspiration_account_number = g_a.account_number)\n\n      LEFT JOIN (\n                  SELECT distinct\n                    account_id\n                  FROM ua_sec_rem\n                  WHERE user_account_type = 2) r_ua\n        on r_a.id = r_ua.account_id\n      LEFT JOIN (\n                  SELECT distinct\n                    account_id\n                  FROM ua_sec_rem\n                  WHERE user_account_type = 2) g_ua\n        on g_a.id = g_ua.account_id\n      LEFT JOIN web_db.user_payment_account upa\n        on upa.depository_id = r.id AND upa.user_id = am.user_id\n      LEFT JOIN web_db.dt_input_fraud_users b\n        on upa.account_number = b.account_number :: text\n      LEFT JOIN web_db.dt_input_radius_accounts ex\n        on ex.depository_id = am.radius_id\n\n    UNION ALL\n\n    select\n      'i' || i.id                                  AS unique_account_id,\n\t\t\tNULL \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAS unfunded_account_ind,\n      ua.user_id,\n      CASE WHEN i.fund_id = 1 AND a.account_type_id = 2\n        THEN 'Flagship Individual'\n      WHEN i.fund_id = 1 AND a.account_type_id = 3\n        THEN 'Flagship IRA'\n      WHEN i.fund_id = 2 AND a.account_type_id = 2\n        THEN 'Redwood Individual'\n      WHEN i.fund_id = 2 AND a.account_type_id = 3\n        THEN 'Redwood IRA'\n      END                                          AS account_type,\n      i.inception_date,\n      null                                         AS migration_date,\n      upa.funding_amount,\n      (upa.fee_amount * upa.funding_amount) / 12.0 AS opening_monthly_usd_fee_setting,\n      upa.fee_amount                               AS opening_yearly_percent_fee_setting,\n     (i.current_value * i.fee_pct) / 12.0            AS current_monthly_usd_fee_setting,\n     null                                          AS current_yearly_percent_fee_setting,\n      upa.user_bank_account_id                     AS funding_bank_id,\n      upa.ip_address                               AS application_ip_address,\n      upa.date_created                             AS application_created_datetime,\n      a.termination_date,\n      i.current_value                              AS current_balance,\n      null\t\t\t\t\t\t\t\t\t\t\tAS spend_current_balance,\n      null\t\t\t\t\t\t\t\t\t\t\tAS save_current_balance,\n      COALESCE(CASE\n               WHEN recurring_frequency = 1\n                 THEN recurring_amount\n               WHEN recurring_frequency = 2\n                 THEN 4 * recurring_amount\n               WHEN recurring_frequency = 3\n                 THEN 2 * recurring_amount\n               END, 0)                             AS initial_monthly_recurring_investment_amount,\n      coalesce(CASE WHEN b.is_disabled = TRUE or cancel_date IS NOT NULL\n        THEN 0\n               WHEN frequency = 1\n                 THEN amount\n               WHEN frequency = 2\n                 THEN 4 * amount\n               WHEN frequency = 3\n                 THEN 2 * amount\n               END, 0.0)                           AS current_monthly_recurring_investment_amount,\n      null                                         AS radius_id,\n      null                                         AS galileo_id,\n      i.id                                         AS investment_id,\n      null                                         AS is_joint_account,\n      null                                         AS summit_account_number,\n      null                                         AS is_charged_off,\n      null                                         AS chargeoff_reason,\n      null                                         AS total_amount_charged_off,\n      null                                         AS hard_loss_charge_off,\n      null                                         AS fees_charged_off,\n      null                                         AS is_ineligible_for_migration,\n      a.is_admin_disabled,\n      NULL AS spend_galileo_prn,\n      NULL AS save_galileo_prn,\n      NULL AS debit_card_activation_date,\n      NULL AS debit_card_shipping_date,\n      NULL AS debit_card_days_to_activation,\n      NULL AS spend_enable_date,\n      NULL AS galileo_save_id\n\n    FROM web_db.investment i\n      INNER JOIN web_db.user_account ua\n        on ua.account_id = i.account_id\n      INNER JOIN web_db.account a\n        on a.id = i.account_id\n      INNER JOIN web_db.user_product_application upa\n        on upa.user_id = ua.user_id AND case when fund_id = 1\n        then 2\n                                        when fund_id = 2\n                                          then 1 end = upa.product_id AND upa.account_type_id = a.account_type_id\n      LEFT JOIN (\n                  SELECT\n                    investment_id,\n                    max(id) AS max_id\n                  FROM web_db.recurring_order_txn\n                  GROUP BY 1\n                ) ab\n        on ab.investment_id = i.id\n      LEFT JOIN web_db.recurring_order_txn b\n        ON ab.investment_id = b.investment_id AND ab.max_id = b.id\n    WHERE i.inception_date IS NOT NULL\n    )\n\n\tSELECT *,\n\t\tCASE\n\t\t\tWHEN account_creation_order > 1 THEN true\n\t\t\tELSE false\n\t\tEND AS is_cross_sell_account\n\tFROM\n\t(\n\t\tSELECT *,\n\t\t\tRANK() OVER (PARTITION BY user_id ORDER BY inception_date, application_created_datetime) AS account_creation_order\n\t\tFROM consolidated_data\n\t) a\n)\n;"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"DISABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]},"3023023":{"id":3023023,"inputCardinality":"MANY","outputCardinality":"MANY","connectorHint":"UNCONDITIONAL","executionHint":"FLOW","implementationID":235671163,"x":-208,"y":96,"width":32,"height":32,"inputConnectorIDs":[3023025,3023034],"outputSuccessConnectorIDs":[],"outputFailureConnectorIDs":[],"outputUnconditionalConnectorIDs":[3023043],"outputTrueConnectorIDs":[],"outputFalseConnectorIDs":[],"exportMappings":{},"parameters":{"1":{"slot":1,"name":"Name","elements":{"1":{"slot":1,"values":{"1":{"slot":1,"type":"STRING","value":"And 2"}}}},"visible":true}},"expectedFailure":null,"activationStatus":"ENABLED","outputIterationConnectorIDs":[],"inputIterationConnectorIDs":[]}},"successConnectors":{"3023001":{"id":3023001,"sourceID":3022966,"targetID":3023015},"3023002":{"id":3023002,"sourceID":3022975,"targetID":3022973},"3023003":{"id":3023003,"sourceID":3023019,"targetID":3023020},"3023004":{"id":3023004,"sourceID":3023018,"targetID":3022961},"3023005":{"id":3023005,"sourceID":3022953,"targetID":3022963},"3023006":{"id":3023006,"sourceID":3022953,"targetID":3023022},"3023007":{"id":3023007,"sourceID":3022971,"targetID":3023009},"3023024":{"id":3023024,"sourceID":3022973,"targetID":3022953},"3023025":{"id":3023025,"sourceID":3022972,"targetID":3023023},"3023026":{"id":3023026,"sourceID":3023011,"targetID":3023014},"3023027":{"id":3023027,"sourceID":3022972,"targetID":3022974},"3023028":{"id":3023028,"sourceID":3022969,"targetID":3023014},"3023029":{"id":3023029,"sourceID":3022974,"targetID":3023008},"3023030":{"id":3023030,"sourceID":3023020,"targetID":3023008},"3023031":{"id":3023031,"sourceID":3022965,"targetID":3023017},"3023032":{"id":3023032,"sourceID":3022963,"targetID":3022962},"3023033":{"id":3023033,"sourceID":3022960,"targetID":3022965},"3023034":{"id":3023034,"sourceID":3023012,"targetID":3023023},"3023035":{"id":3023035,"sourceID":3022962,"targetID":3022966},"3023036":{"id":3023036,"sourceID":3022964,"targetID":3023018},"3023037":{"id":3023037,"sourceID":3022962,"targetID":3022961},"3023038":{"id":3023038,"sourceID":3023016,"targetID":3022971},"3023039":{"id":3023039,"sourceID":3022951,"targetID":3023016},"3023046":{"id":3023046,"sourceID":3022970,"targetID":3022967},"3023047":{"id":3023047,"sourceID":3023013,"targetID":3022960},"3023048":{"id":3023048,"sourceID":3023022,"targetID":3022964},"3023049":{"id":3023049,"sourceID":3022967,"targetID":3023015},"3023050":{"id":3023050,"sourceID":3022966,"targetID":3023021}},"failureConnectors":{},"unconditionalConnectors":{"3023040":{"id":3023040,"sourceID":3022961,"targetID":3022970},"3023041":{"id":3023041,"sourceID":3023014,"targetID":3022972},"3023042":{"id":3023042,"sourceID":3023015,"targetID":3022951},"3023043":{"id":3023043,"sourceID":3023023,"targetID":3023019},"3023082":{"id":3023082,"sourceID":3023009,"targetID":3023012},"3023084":{"id":3023084,"sourceID":3023010,"targetID":3023013},"3023085":{"id":3023085,"sourceID":3023014,"targetID":3023009},"3023086":{"id":3023086,"sourceID":3022968,"targetID":3022975},"3023087":{"id":3023087,"sourceID":3023008,"targetID":3023010}},"trueConnectors":{"3023044":{"id":3023044,"sourceID":3023021,"targetID":3022969}},"falseConnectors":{"3023045":{"id":3023045,"sourceID":3023021,"targetID":3023011}},"iterationConnectors":{},"noteConnectors":{},"notes":{},"variables":{"DB_ADW":{"definition":{"name":"DB_ADW","type":"TEXT","scope":"TASKBATCH","description":"","visibility":"PUBLIC"},"value":"ADW_DEV"},"Schema_ETL":{"definition":{"name":"Schema_ETL","type":"TEXT","scope":"TASKBATCH","description":"","visibility":"PUBLIC"},"value":"ETL"},"Schema_RDL":{"definition":{"name":"Schema_RDL","type":"TEXT","scope":"TASKBATCH","description":"","visibility":"PUBLIC"},"value":"RDL"},"Schema_WebDB":{"definition":{"name":"Schema_WebDB","type":"TEXT","scope":"TASKBATCH","description":"","visibility":"PUBLIC"},"value":"WEB_DB"},"WH_ETL":{"definition":{"name":"WH_ETL","type":"TEXT","scope":"TASKBATCH","description":"","visibility":"PUBLIC"},"value":"ETL"},"job_hour":{"definition":{"name":"job_hour","type":"TEXT","scope":"BRANCH","description":"","visibility":"PUBLIC"},"value":""},"schema_bi_new":{"definition":{"name":"schema_bi_new","type":"TEXT","scope":"TASKBATCH","description":"","visibility":"PUBLIC"},"value":"bi_new"}},"grids":{}},"info":{"name":"testgit_DT_tables_generation","description":"","type":"ORCHESTRATION","tag":"5ebce484-f8b9-4bca-94b2-e923e303989b"}}